<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[docker-mongodb]]></title>
    <url>%2F2019%2F07%2F27%2Fdocker-mongodb%2F</url>
    <content type="text"><![CDATA[1.Docker命令拉取MongoDB镜像1docker pull mongo:4.0 2.启动MongoDB容器实例2.1.创建MongoDB存储文件夹12cd /datamkdir mongodb 2.2.启动MongoDB容器实例1docker run -p 27017:27017 -v /data/mongodb:/data/db --name mymongodb -d -e MONGO_INITDB_ROOT_USERNAME=root -e MONGO_INITDB_ROOT_PASSWORD=123456 mongo:4.0 2.3.创建Collection和用户1234567docker exec -it mymongodb mongoshow dbsuse admin;//db = db.getSiblingDB(&apos;Collection1&apos;);// 创建一个名为&quot;newDB&quot;的DBdb.createUser(&#123; user: &apos;root&apos;, pwd: &apos;123456&apos;, roles: [ &#123; role: &quot;root&quot;, db: &quot;admin&quot; &#125; ] &#125;);db.createCollection(&quot;Collection1&quot;); // 在&quot;newDB&quot;中创建一个名为&quot;newCollection&quot;的Collectionshow users 3.安装mongo-express客户端3.1.Docker命令拉取MongoDB镜像1docker pull mongo-express:0.49 3.2.启动MongoDB容器实例1docker run -it --restart=always --name mymongoexpress --link mongodb:mongo-db -d -p 8081:8081 -e ME_CONFIG_OPTIONS_EDITORTHEME=&quot;3024-night&quot; -e ME_CONFIG_BASICAUTH_USERNAME=&quot;root&quot; -e ME_CONFIG_BASICAUTH_PASSWORD=&quot;123456&quot; -e ME_CONFIG_MONGODB_ADMINUSERNAME=&quot;root&quot; -e ME_CONFIG_MONGODB_ADMINPASSWORD=&quot;123456&quot; mongo-express:0.49 1docker run -d --name mymongoexpress -p 8081:8081 --link mymongodb:mongo --env ME_CONFIG_MONGODB_ADMINUSERNAME=&apos;root&apos; --env ME_CONFIG_MONGODB_ADMINPASSWORD=&apos;123456&apos; mongo-express:0.49 3.3.防火墙开启8081端口12firewall-cmd --add-port=8081/tcpfirewall-cmd --query-port=8081/tcp]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>MongoDB</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MongoDB Atlas平台使用教程]]></title>
    <url>%2F2019%2F06%2F22%2FMongoDB-Atlas%2F</url>
    <content type="text"><![CDATA[MongoDB Atlas是MongoDB的云平台。 1.注册 https://www.mongodb.com/ -&gt; Sign In 2.创建一个Free Clusters，可导入Sample Data Cluster0包含3个节点： Cluster0的Sample Data： 3.点击左侧菜单Network Access创建访问白名单 0.0.0.0表示所有IP Addresses都可以访问。) 4.点击左侧菜单Database Access创建用户 5.点击Clusters-&gt;CONNECT创建连接方式 6.选择Application的连接方式 7.选择Java语言 8.测试代码 1234567891011121314151617181920212223242526public boolean connectMongoDBAtlas() &#123; boolean result = false; try &#123; MongoClientURI uri = new MongoClientURI( &quot;mongodb://&lt;username&gt;:&lt;password&gt;@cluster0-shard-00-00-zmwgt.azure.mongodb.net:27017,cluster0-shard-00-01-zmwgt.azure.mongodb.net:27017,cluster0-shard-00-02-zmwgt.azure.mongodb.net:27017/admin?ssl=true&amp;replicaSet=Cluster0-shard-0&amp;authSource=admin&amp;retryWrites=true&amp;w=majority&quot;); MongoClient mongoClient = new MongoClient(uri); MongoDatabase database = mongoClient.getDatabase(&quot;sample_airbnb&quot;); MongoCollection&lt;Document&gt; collection = database.getCollection(&quot;listingsAndReviews&quot;); //MongoCollection&lt;Document&gt; collection = database.getCollection(&quot;a&quot;); //查询所有文档，遍历输出结果 FindIterable&lt;Document&gt; documents = collection.find().limit(10); for (Document d : documents) &#123; System.out.println(d.toJson()); &#125; result = true; &#125; catch (Exception e) &#123; result = false; System.out.println(&quot;Error:&quot; + e.getMessage()); &#125; finally &#123; &#125; return result;&#125; 代码结果： 10.MongoDB Express连接Atlas SRV Record模式不需要指定27017端口 Data Preview：]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>MongoDB</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[69个经典Spring面试题和答案]]></title>
    <url>%2F2018%2F12%2F17%2FJava%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF%20-%207%2F</url>
    <content type="text"><![CDATA[69个经典Spring面试题和答案 Java后端技术1. 什么是spring? Spring 是个java企业级应用的开源开发框架。Spring主要用来开发Java应用，但是有些扩展是针对构建J2EE平台的web应用。Spring 框架目标是简化Java企业级应用开发，并通过POJO为基础的编程模型促进良好的编程习惯。 2. 使用Spring框架的好处是什么？ 轻量：Spring 是轻量的，基本的版本大约2MB 控制反转：Spring通过控制反转实现了松散耦合，对象们给出它们的依赖，而不是创建或查找依赖的对象们 面向切面的编程(AOP)：Spring支持面向切面的编程，并且把应用业务逻辑和系统服务分开 容器：Spring 包含并管理应用中对象的生命周期和配置 MVC框架：Spring的WEB框架是个精心设计的框架，是Web框架的一个很好的替代品 事务管理：Spring 提供一个持续的事务管理接口，可以扩展到上至本地事务下至全局事务（JTA） 异常处理：Spring 提供方便的API把具体技术相关的异常（比如由JDBC，Hibernate or JDO抛出的）转化为一致的unchecked 异常 3. Spring由哪些模块组成？ 以下是Spring 框架的基本模块： Core module Bean module Context module Expression Language module JDBC module ORM module OXM module Java Messaging Service(JMS) module Transaction module Web module Web-Servlet module Web-Struts module Web-Portlet module 4. 核心容器（应用上下文) 模块 这是基本的Spring模块，提供spring 框架的基础功能，BeanFactory 是 任何以spring为基础的应用的核心。Spring 框架建立在此模块之上，它使Spring成为一个容器。 5. BeanFactory – BeanFactory 实现举例 Bean 工厂是工厂模式的一个实现，提供了控制反转功能，用来把应用的配置和依赖从正真的应用代码中分离。 最常用的BeanFactory 实现是XmlBeanFactory 类。 6. XMLBeanFactory 最常用的就是org.springframework.beans.factory.xml.XmlBeanFactory ，它根据XML文件中的定义加载beans。该容器从XML 文件读取配置元数据并用它去创建一个完全配置的系统或应用。 7. 解释AOP模块 AOP模块用于发给我们的Spring应用做面向切面的开发， 很多支持由AOP联盟提供，这样就确保了Spring和其他AOP框架的共通性。这个模块将元数据编程引入Spring。 8. 解释JDBC抽象和DAO模块 通过使用JDBC抽象和DAO模块，保证数据库代码的简洁，并能避免数据库资源错误关闭导致的问题，它在各种不同的数据库的错误信息之上，提供了一个统一的异常访问层。它还利用Spring的AOP 模块给Spring应用中的对象提供事务管理服务。 9. 解释对象/关系映射集成模块 Spring 通过提供ORM模块，支持我们在直接JDBC之上使用一个对象/关系映射映射(ORM)工具，Spring 支持集成主流的ORM框架，如Hiberate,JDO和 iBATIS SQL Maps。Spring的事务管理同样支持以上所有ORM框架及JDBC。 10. 解释WEB 模块 Spring的WEB模块是构建在application context 模块基础之上，提供一个适合web应用的上下文。这个模块也包括支持多种面向web的任务，如透明地处理多个文件上传请求和程序级请求参数的绑定到你的业务对象。它也有对Jakarta Struts的支持。 12. Spring配置文件 Spring配置文件是个XML 文件，这个文件包含了类信息，描述了如何配置它们，以及如何相互调用。 13. 什么是Spring IOC 容器？ Spring IOC 负责创建对象，管理对象（通过依赖注入（DI），装配对象，配置对象，并且管理这些对象的整个生命周期。 14. IOC的优点是什么？ IOC 或 依赖注入把应用的代码量降到最低。它使应用容易测试，单元测试不再需要单例和JNDI查找机制。最小的代价和最小的侵入性使松散耦合得以实现。IOC容器支持加载服务时的饿汉式初始化和懒加载。 15. ApplicationContext通常的实现是什么？ FileSystemXmlApplicationContext ：此容器从一个XML文件中加载beans的定义，XML Bean 配置文件的全路径名必须提供给它的构造函数。 ClassPathXmlApplicationContext：此容器也从一个XML文件中加载beans的定义，这里，你需要正确设置classpath因为这个容器将在classpath里找bean配置。 WebXmlApplicationContext：此容器加载一个XML文件，此文件定义了一个WEB应用的所有bean。 16. Bean 工厂和 Application contexts 有什么区别？ Application contexts提供一种方法处理文本消息，一个通常的做法是加载文件资源（比如镜像），它们可以向注册为监听器的bean发布事件。另外，在容器或容器内的对象上执行的那些不得不由bean工厂以程序化方式处理的操作，可以在Application contexts中以声明的方式处理。Application contexts实现了MessageSource接口，该接口的实现以可插拔的方式提供获取本地化消息的方法。 17. 一个Spring的应用看起来象什么？ 一个定义了一些功能的接口 这实现包括属性，它的Setter ， getter 方法和函数等 Spring AOP Spring 的XML 配置文件 使用以上功能的客户端程序 依赖注入 18. 什么是Spring的依赖注入？ 依赖注入，是IOC的一个方面，是个通常的概念，它有多种解释。这概念是说你不用创建对象，而只需要描述它如何被创建。你不在代码里直接组装你的组件和服务，但是要在配置文件里描述哪些组件需要哪些服务，之后一个容器（IOC容器）负责把他们组装起来。 19. 有哪些不同类型的IOC（依赖注入）方式？ 构造器依赖注入：构造器依赖注入通过容器触发一个类的构造器来实现的，该类有一系列参数，每个参数代表一个对其他类的依赖。 Setter方法注入：Setter方法注入是容器通过调用无参构造器或无参static工厂 方法实例化bean之后，调用该bean的setter方法，即实现了基于setter的依赖注入。 20. 哪种依赖注入方式你建议使用，构造器注入，还是 Setter方法注入？ 你两种依赖方式都可以使用，构造器注入和Setter方法注入。最好的解决方案是用构造器参数实现强制依赖，setter方法实现可选依赖。 Spring Beans 21.什么是Spring beans？ Spring beans 是那些形成Spring应用的主干的java对象。它们被Spring IOC容器初始化，装配，和管理。这些beans通过容器中配置的元数据创建。比如，以XML文件中 的形式定义。 Spring 框架定义的beans都是单件beans。在bean tag中有个属性”singleton”，如果它被赋为TRUE，bean 就是单件，否则就是一个 prototype bean。默认是TRUE，所以所有在Spring框架中的beans 缺省都是单件。 22. 一个 Spring Bean 定义 包含什么？ 一个Spring Bean 的定义包含容器必知的所有配置元数据，包括如何创建一个bean，它的生命周期详情及它的依赖。 23. 如何给Spring 容器提供配置元数据？ 这里有三种重要的方法给Spring 容器提供配置元数据。 XML配置文件。 基于注解的配置。 基于java的配置。 24. 你怎样定义类的作用域？ 当定义一个 在Spring里，我们还能给这个bean声明一个作用域。它可以通过bean 定义中的scope属性来定义。如，当Spring要在需要的时候每次生产一个新的bean实例，bean的scope属性被指定为prototype。另一方面，一个bean每次使用的时候必须返回同一个实例，这个bean的scope 属性 必须设为 singleton。 25. 解释Spring支持的几种bean的作用域 Spring框架支持以下五种bean的作用域： singleton : bean在每个Spring ioc 容器中只有一个实例。 prototype：一个bean的定义可以有多个实例。 request：每次http请求都会创建一个bean，该作用域仅在基于web的Spring ApplicationContext情形下有效。 session：在一个HTTP Session中，一个bean定义对应一个实例。该作用域仅在基于web的Spring ApplicationContext情形下有效。 global-session：在一个全局的HTTP Session中，一个bean定义对应一个实例。该作用域仅在基于web的Spring ApplicationContext情形下有效。 缺省的Spring bean 的作用域是Singleton。 26. Spring框架中的单例bean是线程安全的吗？ 不，Spring框架中的单例bean不是线程安全的。 27. 解释Spring框架中bean的生命周期 Spring容器 从XML 文件中读取bean的定义，并实例化bean。 Spring根据bean的定义填充所有的属性。 如果bean实现了BeanNameAware 接口，Spring 传递bean 的ID 到 setBeanName方法。 如果Bean 实现了 BeanFactoryAware 接口， Spring传递beanfactory 给setBeanFactory 方法。 如果有任何与bean相关联的BeanPostProcessors，Spring会在postProcesserBeforeInitialization()方法内调用它们。 如果bean实现IntializingBean了，调用它的afterPropertySet方法，如果bean声明了初始化方法，调用此初始化方法。 如果有BeanPostProcessors 和bean 关联，这些bean的postProcessAfterInitialization() 方法将被调用。 如果bean实现了 DisposableBean，它将调用destroy()方法。 28. 哪些是重要的bean生命周期方法？ 你能重载它们吗？ 有两个重要的bean 生命周期方法，第一个是setup ， 它是在容器加载bean的时候被调用。第二个方法是 teardown 它是在容器卸载类的时候被调用。 The bean 标签有两个重要的属性（init-method和destroy-method）。用它们你可以自己定制初始化和注销方法。它们也有相应的注解（@PostConstruct和@PreDestroy）。 29. 什么是Spring的内部bean？ 当一个bean仅被用作另一个bean的属性时，它能被声明为一个内部bean，为了定义inner bean，在Spring 的 基于XML的 配置元数据中，可以在 或 元素内使用 元素，内部bean通常是匿名的，它们的Scope一般是prototype。 30. 在 Spring中如何注入一个java集合？ Spring提供以下几种集合的配置元素： 类型用于注入一列值，允许有相同的值。 类型用于注入一组值，不允许有相同的值。 类型用于注入一组键值对，键和值都可以为任意类型。 类型用于注入一组键值对，键和值都只能为String类型。 31. 什么是bean装配？ 装配，或bean 装配是指在Spring 容器中把bean组装到一起，前提是容器需要知道bean的依赖关系，如何通过依赖注入来把它们装配到一起。 32. 什么是bean的自动装配？ Spring 容器能够自动装配相互合作的bean，这意味着容器不需要和配置，能通过Bean工厂自动处理bean之间的协作。 33. 解释不同方式的自动装配 有五种自动装配的方式，可以用来指导Spring容器用自动装配方式来进行依赖注入 no：默认的方式是不进行自动装配，通过显式设置ref 属性来进行装配。 byName：通过参数名 自动装配，Spring容器在配置文件中发现bean的autowire属性被设置成byname，之后容器试图匹配、装配和该bean的属性具有相同名字的bean。 byType：通过参数类型自动装配，Spring容器在配置文件中发现bean的autowire属性被设置成byType，之后容器试图匹配、装配和该bean的属性具有相同类型的bean。如果有多个bean符合条件，则抛出错误。 constructor：这个方式类似于byType， 但是要提供给构造器参数，如果没有确定的带参数的构造器参数类型，将会抛出异常。 autodetect：首先尝试使用constructor来自动装配，如果无法工作，则使用byType方式。 34.自动装配有哪些局限性？ 自动装配的局限性是： 重写：你仍需用 和 配置来定义依赖，意味着总要重写自动装配。 基本数据类型：你不能自动装配简单的属性，如基本数据类型，String字符串，和类。 模糊特性：自动装配不如显式装配精确，如果有可能，建议使用显式装配。 35. 你可以在Spring中注入一个null 和一个空字符串吗？ 可以。 Spring注解 36. 什么是基于Java的Spring注解配置? 给一些注解的例子 基于Java的配置，允许你在少量的Java注解的帮助下，进行你的大部分Spring配置而非通过XML文件。 以@Configuration 注解为例，它用来标记类可以当做一个bean的定义，被Spring IOC容器使用。另一个例子是@Bean注解，它表示此方法将要返回一个对象，作为一个bean注册进Spring应用上下文。 37. 什么是基于注解的容器配置？ 相对于XML文件，注解型的配置依赖于通过字节码元数据装配组件，而非尖括号的声明。 开发者通过在相应的类，方法或属性上使用注解的方式，直接组件类中进行配置，而不是使用xml表述bean的装配关系。 38. 怎样开启注解装配？ 注解装配在默认情况下是不开启的，为了使用注解装配，我们必须在Spring配置文件中配置 context:annotation-config/元素。 39. @Required 注解 这个注解表明bean的属性必须在配置的时候设置，通过一个bean定义的显式的属性值或通过自动装配，若@Required注解的bean属性未被设置，容器将抛出BeanInitializationException。 40. @Autowired 注解 @Autowired 注解提供了更细粒度的控制，包括在何处以及如何完成自动装配。它的用法和@Required一样，修饰setter方法、构造器、属性或者具有任意名称和/或多个参数的PN方法。 41. @Qualifier 注解 当有多个相同类型的bean却只有一个需要自动装配时，将@Qualifier 注解和@Autowire 注解结合使用以消除这种混淆，指定需要装配的确切的bean。 Spring数据访问 42.在Spring框架中如何更有效地使用JDBC？ 使用SpringJDBC 框架，资源管理和错误处理的代价都会被减轻。所以开发者只需写statements 和 queries从数据存取数据，JDBC也可以在Spring框架提供的模板类的帮助下更有效地被使用，这个模板叫JdbcTemplate （例子见这里here） 43. JdbcTemplate JdbcTemplate 类提供了很多便利的方法解决诸如把数据库数据转变成基本数据类型或对象，执行写好的或可调用的数据库操作语句，提供自定义的数据错误处理。 44. Spring对DAO的支持 Spring对数据访问对象（DAO）的支持旨在简化它和数据访问技术如JDBC，Hibernate or JDO 结合使用。这使我们可以方便切换持久层。编码时也不用担心会捕获每种技术特有的异常。 45. 使用Spring通过什么方式访问Hibernate？ 在Spring中有两种方式访问Hibernate： 控制反转 Hibernate Template和 Callback 继承 HibernateDAOSupport提供一个AOP 拦截器 46. Spring支持的ORM Spring支持以下ORM： Hibernate iBatis JPA (Java Persistence API) TopLink JDO (Java Data Objects) OJB 47.如何通过HibernateDaoSupport将Spring和Hibernate结合起来？ 用Spring的 SessionFactory 调用 LocalSessionFactory。集成过程分三步： 配置the Hibernate SessionFactory 继承HibernateDaoSupport实现一个DAO 在AOP支持的事务中装配 48. Spring支持的事务管理类型 Spring支持两种类型的事务管理： 编程式事务管理：这意味你通过编程的方式管理事务，给你带来极大的灵活性，但是难维护。 声明式事务管理：这意味着你可以将业务代码和事务管理分离，你只需用注解和XML配置来管理事务。 49. Spring框架的事务管理有哪些优点？ 它为不同的事务API 如 JTA，JDBC，Hibernate，JPA 和JDO，提供一个不变的编程模式。 它为编程式事务管理提供了一套简单的API而不是一些复杂的事务API如 它支持声明式事务管理。 它和Spring各种数据访问抽象层很好得集成。 50. 你更倾向用那种事务管理类型？ 大多数Spring框架的用户选择声明式事务管理，因为它对应用代码的影响最小，因此更符合一个无侵入的轻量级容器的思想。声明式事务管理要优于编程式事务管理，虽然比编程式事务管理（这种方式允许你通过代码控制事务）少了一点灵活性。 Spring面向切面编程（AOP） 51. 解释AOP 面向切面的编程，或AOP， 是一种编程技术，允许程序模块化横向切割关注点，或横切典型的责任划分，如日志和事务管理。 52. Aspect 切面 AOP核心就是切面，它将多个类的通用行为封装成可重用的模块，该模块含有一组API提供横切功能。比如，一个日志模块可以被称作日志的AOP切面。根据需求的不同，一个应用程序可以有若干切面。在Spring AOP中，切面通过带有@Aspect注解的类实现。 52. 在Spring AOP 中，关注点和横切关注的区别是什么？ 关注点是应用中一个模块的行为，一个关注点可能会被定义成一个我们想实现的一个功能。 横切关注点是一个关注点，此关注点是整个应用都会使用的功能，并影响整个应用，比如日志，安全和数据传输，几乎应用的每个模块都需要的功能。因此这些都属于横切关注点。 54. 连接点 连接点代表一个应用程序的某个位置，在这个位置我们可以插入一个AOP切面，它实际上是个应用程序执行Spring AOP的位置。 55. 通知 通知是个在方法执行前或执行后要做的动作，实际上是程序执行时要通过SpringAOP框架触发的代码段。 Spring切面可以应用五种类型的通知： before：前置通知，在一个方法执行前被调用 after：在方法执行之后调用的通知，无论方法执行是否成功 after-returning：仅当方法成功完成后执行的通知 after-throwing：在方法抛出异常退出时执行的通知 around：在方法执行之前和之后调用的通知 56. 切点 切入点是一个或一组连接点，通知将在这些位置执行。可以通过表达式或匹配的方式指明切入点。 57. 什么是引入？ 引入允许我们在已存在的类中增加新的方法和属性。 58. 什么是目标对象？ 被一个或者多个切面所通知的对象。它通常是一个代理对象。也指被通知（advised）对象。 59. 什么是代理？ 代理是通知目标对象后创建的对象。从客户端的角度看，代理对象和目标对象是一样的。 60. 有几种不同类型的自动代理？ BeanNameAutoProxyCreator DefaultAdvisorAutoProxyCreator Metadata autoproxying 61. 什么是织入。什么是织入应用的不同点？ 织入是将切面和到其他应用类型或对象连接或创建一个被通知对象的过程。 织入可以在编译时，加载时，或运行时完成。 62. 解释基于XML Schema方式的切面实现 在这种情况下，切面由常规类以及基于XML的配置实现。 63. 解释基于注解的切面实现 在这种情况下(基于@AspectJ的实现)，涉及到的切面声明的风格与带有java5标注的普通java类一致。 Spring 的MVC 64. 什么是Spring的MVC框架？ Spring 配备构建Web 应用的全功能MVC框架。Spring可以很便捷地和其他MVC框架集成，如Struts，Spring 的MVC框架用控制反转把业务对象和控制逻辑清晰地隔离。它也允许以声明的方式把请求参数和业务对象绑定。 65. DispatcherServlet Spring的MVC框架是围绕DispatcherServlet来设计的，它用来处理所有的HTTP请求和响应。 66. WebApplicationContext WebApplicationContext 继承了ApplicationContext 并增加了一些WEB应用必备的特有功能，它不同于一般的ApplicationContext ，因为它能处理主题，并找到被关联的servlet。 67. 什么是Spring MVC框架的控制器？ 控制器提供一个访问应用程序的行为，此行为通常通过服务接口实现。控制器解析用户输入并将其转换为一个由视图呈现给用户的模型。Spring用一个非常抽象的方式实现了一个控制层，允许用户创建多种用途的控制器。 68. @Controller 注解 该注解表明该类扮演控制器的角色，Spring不需要你继承任何其他控制器基类或引用Servlet API。 69. @RequestMapping 注解 该注解是用来映射一个URL到一个类或一个特定的方处理法上。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>面试题</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java面试题84题系列全集]]></title>
    <url>%2F2018%2F12%2F16%2FJava%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF%20-%206%2F</url>
    <content type="text"><![CDATA[Java面试题84题系列全集 Java后端技术目录 01.面试的整体流程 02.java的垮平台原理 03.搭建一个java的开发环境 04.java中int占几个字节 05.java面向对象的特征 06.装箱和拆箱 07.==和equals的区别 08.String 09.讲一下java中的集合 10.ArrayList 和LinkedList的区别 11.HashMap和HashTable的区别 12.实现一个拷贝文件的工具类要使用字节流还是字符串 13.线程的的实现方式？怎么启动线程？怎么区分线程？ 14.线程并发库和线程池的作用 15.设计模式和常用的设计模式 16.http get post请求的区别 17.说说你对Servlet的理解 18.Servlet的生命周期 19.Servlet中forward和redirect的区别 20.jsp和Servlet的相同点和不同点 21.内置对象和四大作用域和页面传值 22.Session和Cookie的区别和使用场景 23.mvc模式和mvc各部分的实现 24.数据库分类和常用数据库 25.关系型数据库的三范式 26.事务的四大特征 27.mysql数据库最大连接数 28.mysql和oracle的分页语句 29.触发器的使用场景？ 30.存储过程的优点 31.jdbc调用存储过程 32.简单说一下你对jdbc的理解 33.写一个jdbc的访问oracle的列子 34.jdbc中preparedStatement比Statement的好处 35.数据库连接池的作用 36.HTML 37.简单介绍了一下Ajax 38.js和JQuery的关系 39.jQuery中的常用选择器 40.jQuery中页面加载完毕事件 41.jQuery中Ajax和原生js实现Ajax的关系 42.简单说一下html5 43.简单说一下css3 44.bootstrap的是什么 45.什么是框架 46.简单介绍一下MVC模式 47.简单说一下对mvc框架的理解 48.struts2的执行流程或者struts2的原理 49.Struts2的拦截器是什么 50.Spring MVC的执行流程 51.SpringMVC和Struts2的不同 52.简单介绍一下Spring或者Spring的两大核心 53.AOP是什么？都用它做什么？ 54.Spring事务的传播特性和隔离级别 55.ORM是什么？ORM框架是什么？ 56.ibatis和hibernate有什么不同 57.hibernate对象状态及其转换 58：hibernate的缓存 59.webservice的使用场景 60.activiti的简单介绍 61.linux的使用场景 62.linux常用命令 63：怎么操作linux服务器 64：有没有使用过云主机 65：数据库优化方面的事情 66：如果查询和定位慢查询 67：数据库优化之数据库表设计遵循范式 68：选择合适的数据库引擎 69：选择合适的索引 70：使用索引的一些技巧 71：数据库优化之分表 72：数据库的读写分离 73：数据库优化之缓存 74：sql语句优化小技巧 75：批量插入几百万条数据 76：有没有使用过redis 77：redis的使用场景 78：redis存储对象的方式 79：redis数据淘汰机制 80：java访问redis级redis集群 81：微信公众号分类和微信开发原理 82：怎么把微信和业务平台进行绑定 83：项目的分类和项目参与者 84：项目流程和业务注意事项]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>面试题</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018年Java面试题汇总 - 5]]></title>
    <url>%2F2018%2F12%2F15%2FJava%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF%20-%205%2F</url>
    <content type="text"><![CDATA[2018年Java面试题汇总 - 5 Java后端技术一、Java相关 乐观悲观锁的设计，如何保证原子性，解决的问题； char和double的字节，以及在内存的分布是怎样； 对象内存布局，然后讲下对象的死亡过程？ 对象头，详细讲下； sync原理详细，sync内抛异常会怎样，死锁吗？还是释放掉？怎么排查死锁？死锁会怎样？有没有什么更好的替代方案？ 详细讲一下集合，HashSet源码，HashMap源码，如果要线程安全需要怎么做？ 多线程是解决什么问题的？线程池解决什么问题？ 线程池，如何设计的，里面的参数有多少种，里面的工作队列和线程队列是怎样的结构，如果给你，怎样设计线程池？ AQS原理，ReentranLock源码，设计原理，整体过程。 继续聊多线程源码，sync原理，然后一个场景设计题； float f = 1.4f;double d = 1.4d; 与 float f = 1.5f;double d = 1.5d; 是否为true，内存是怎样的； split的源码，split(“a|b|c”);得出多少个数组； 把所有认识熟用的JUC( java.util.concurrent(简称JUC)包)下的类写出来，讲下使用，然后讲下原生的线程操作; 开闭原则，解析工厂方法模式，建造者模式，区别。手撸出来。 讲下JVM的大页模式，JVM内存模型; 什么是敏捷开发，防御性编程，并行编程。Team Leader的思考; 逃逸分析是什么，作用是什么，用途是什么; 怎么认为一个类是线程安全？线程安全的定义是什么？Java有多少个关键字进行同步？为什么这样设计？（聊了一大堆，一堆为什么）； 两个线程设计题。记得一个是：t1,t2,t3，让t1，t2执行完才执行t3，原生实现。 写个后缀表达式，为什么要设计后缀表达式，有什么好处？然后写下中缀。 我看你做过性能优化，比如你怎么分析项目里面的OOM的，内存泄露呢？详细说思路; 说下多线程，我们什么时候需要分析线程数，怎么分析，分析什么因素; 抽象方法和类方法的区别，static的抽象方法可以吗？ 说下Java的克隆体系; 涉及OOM、JVM优化、源码问题、数据库优化、多线程等问题; CPU高？什么情况CPU高？解决什么问题？ 你有遇到过临界区问题吗？有遇到过吗？你在项目遇到这个问题是怎样解决的？ volatile关键字作用; Java的多态怎么实现; 解释一下自旋; 解释一下信号量; 什么情况下会触发类加载； Java内存抖动严重，优化的思路； 二、数据库相关 SQL优化思路，联合索引与底层树结构的映像关系，索引结构（B+、B-），为什么用这样的结构； 讲下MySQL的集群？集群遇到过什么问题？sql的优化？ 你目前为止遇到的最大数据量是多少？知道100万时候怎么设计吗？1000万呢？过几十亿呢？ MySQL有多少个参数可调，除了最大连接数。全部列出来，一个个分析。 聊下优化过的索引，怎么优化; 红黑树和平衡树的区别，为什么数据库不用红黑树; mysql有哪些锁，意向锁有什么用; 数据库高并发下的优化思路; 数据库什么情况下索引会失效; 三、数据结构和操作系统相关 数据结构学过吧，聊一下？学过什么结构？讲下树和队列？B树呢？ 操作系统学过吧，聊一下？讲一下系统内存是怎样的？分段分页虚拟内存？ 页面置换算法呢？多少种？有最优的置换算法吗？ 你学过什么课程？然后聊下操作系统，内核、用户之类。 反转链表手撸; 快排，给一串数组，把具体每次patition写下，最终结果也写45, 32, 41, 35, 38, 20, 50; 一个整数status, 判断第K个比特位是否为比特1; 把递归实现的快排改成非递归，你知道非递归有什么好处吗; 举例使用分治思想的算法; 四、网络相关 讲下请求头细节？ Http和Https？Http1.0,1.1,2.0，讲下长连接和短连接？Https是怎样的？如果我篡改了公钥呢？怎么防止？ Get和Post，讲下区别，要我模拟出抓包来。 详细讲下Cookie和Session，Token，OAuth2.0协议; 拥塞算法知道吗？哪些，分别怎样？ 学过计算机网络是吧？socket熟悉吗？对它的读写缓冲区有理解吗？怎么的？那滑动窗口是怎样的？为什么这样设计？ 再聊下Http的Http basic authentication; Https的过程; 五、框架相关 聊下Spring源码，知道多少，都聊一下； 聊下Spring注解，@Autowire，@Resource，以及他们的解析过程； 聊一下架构，接入层架构，服务层架构。聊下技术栈，Spring Boot，Spring Cloud、Docker； Spring ioc的具体优势，和直接New一个对象有什么区别; Servlet生命周期，是否单例，为什么是单例; Spring Mvc初始化过程； 五、分布式相关 多少种RPC框架？ 一致性哈希是干嘛的？ 搭建高并发高可用系统需要怎样设计？考虑哪些东西，有多少说多少。 你对缓存有什么理解？缓存是解决什么问题？后端缓存有哪些，分别解决什么问题？ 聊一下分布式锁； 你是怎么设计系统缓存的，为什么，什么场景； 也来说下，削峰的多种实现，Redis？MQ？ 为什么用mq就能削峰？解决什么问题？ 六、设计题 有几台机器存储着几亿淘宝搜索日志，你只有一台2g的电脑，怎么选出搜索热度最高的十个搜索关键词; 如何设计算法压缩一段URL; 有一个页面能同时展示两个广告，现在有五个广告，设计算法使五个广告展示概率为1:2:3:4:5； 有25匹马，五个赛道，用最少比赛次数将25匹马排序； 七、其他相关 Tomcat缓存，聊下缓存的整体理解，知道多少种缓存； 解释下Mucene原理，倒排索引，怎样进行中文分词，基于什么进行分词； TopN的大数据量题； 你对接入层要思考什么东西？遇到过哪些问题？搭建系统要考量哪些因素？ 然后项目问题，优化问题； 熟悉maven是吧？我们来聊下Maven的源码原理，Maven冲突的时候，怎么选择依赖包，我们怎么查，我们遇到两个不一样的版本，我们应该如何去选择，为什么？ 项目如何分组，性能优化小组应该做哪些; 我们来说下接入层的搭建，认知分析; 问下项目的系统构建，思考，为什么这样构建？ 如何判断一段代码的好坏;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>面试题</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018年Java面试题汇总 - 4]]></title>
    <url>%2F2018%2F12%2F14%2FJava%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF%20-%204%2F</url>
    <content type="text"><![CDATA[2018年Java面试题汇总 - 4 Java后端技术一、Java基础 为什么JVM调优经常会将-Xms和-Xmx参数设置成一样； Java线程池的核心属性以及处理流程； Java内存模型，方法区存什么； CMS垃圾回收过程； Full GC次数太多了，如何优化； 直接内存如何管理的； Java线程池的几个参数的意义和实现机制； Java线程池使用无界任务队列和有界任务队列的优劣对比； CountDownLatch和CyclicBarrier的区别； Java中有哪些同步方案（重量级锁、显式锁、并发容器、并发同步器、CAS、volatile、AQS等） 如果你的项目出现了内存泄露，怎么监控这个问题呢； 标记清除和标记整理的区别和优缺点，为何标记整理会发生stop the world； 线程池，如何根据CPU的核数来设计线程大小，如果是计算机密集型的呢，如果是IO密集型的呢？ 让你设计一个cache如何设计； String中hashcode是怎么实现的； JDK中哪些实现了单例模式？ 多个线程同时读写，读线程的数量远远⼤于写线程，你认为应该如何解决并发的问题？你会选择加什么样的锁？ 线程池内的线程如果全部忙，提交⼀个新的任务，会发⽣什么？队列全部塞满了之后，还是忙，再提交会发⽣什么？ synchronized关键字锁住的是什么东西？在字节码中是怎么表示的？在内存中的对象上表现为什么？ wait/notify/notifyAll⽅法需不需要被包含在synchronized块中？这是为什么？ ExecutorService你一般是怎么⽤的？是每个Service放一个还是个项目放一个？有什么好处？ 二、数据库 InnoDB的插入缓冲和两次写的概率和意义； 如果建了⼀个单列索引，查询的时候查出2列，会⽤到这个单列索引吗？（会用到） 如果建了⼀个包含多个列的索引，查询的时候只⽤了第⼀列，能不能⽤上这个索引？查三列呢？ 接上题，如果where条件后⾯带有⼀个 i + 5 &lt; 100 会使⽤到这个索引吗？ like %aaa%会使⽤索引吗? like aaa%呢? drop、truncate、delete的区别？ 平时你们是怎么监控数据库的? 慢SQL是怎么排查的？（慢查询日志） 你们数据库是否⽀持emoji表情，如果不⽀持，如何操作?选择什么编码方式？如果支持一个表情占几个字节?(utf8mb4)； 如果查询很慢，你会想到的第⼀个⽅式是什么？（数据库索引） 三、Linux基础 Linux下可以在/proc目录下可以查看CPU的核心数等；cat /proc/下边会有很多系统内核信息可供显示； 说一下栈的内存是怎么分配的； Linux各个目录有了解过吗？/etc、/bin、/dev、/lib、/sbin这些常见的目录主要作用是什么？ 说一下栈帧的内存是怎么分配的； Linux下排查某个死循环的线程； 动态链接和静态链接的区别； 进程的内存分布； 如何查找一个进程打开所有的文件； 说一下常使用的协议及其对应的端口； 为什么会有内核态，保护模式你知道吗? 文件是怎么在磁盘上存储的？ 有了进程为何还要线程呢，不同进程和线程他们之间有什么不同。（进程是资源管理的最小单位，线程是程序执行的最小单位。在操作系统设计上，从进程演化出线程，最主要的目的就是更好的支持SMP以及减小（进程/线程）上下文切换开销。） InnoDB聚集索引B+树叶子节点和磁盘什么顺序相同; 文件系统，进程管理和调度，内存管理机制、虚地址保护模式； 四、网络基础 HTTP1.0和HTTP1.1的区别； DHCP如何实现分配IP的； 发现阶段（DHCP客户端在网络中广播发送DHCP DISCOVER请求报文，发现DHCP服务器，请求IP地址租约）、提供阶段（DHCP服务器通过DHCP OFFER报文向DHCP客户端提供IP地址预分配）、选择阶段（DHCP客户端通过DHCP REQUEST报文确认选择第一个DHCP服务器为它提供IP地址自动分配服务）和确认阶段（被选择的DHCP服务器通过DHCP ACK报文把在DHCP OFFER报文中准备的IP地址租约给对应DHCP客户端）。 OSI七层模型，每层都说下自己的理解和知道的，说的越多越好； 五、框架相关 Servlet如何保证单例模式,可不可以编程多例的哪？ Dubbo请求流程以及原理； Spring框架如何实现事务的； 如果一个接⼝有2个不同的实现, 那么怎么来Autowire一个指定的实现？(可以使用Qualifier注解限定要注入的Bean，也可以使用Qualifier和Autowire注解指定要获取的bean，也可以使用Resource注解的name属性指定要获取的Bean) Spring框架中需要引用哪些jar包，以及这些jar包的用途； Spring Boot没有放到web容器⾥为什么能跑HTTP服务？ Spring中循环注入是什么意思，可不可以解决，如何解决； Spring的声明式事务 @Transaction注解⼀般写在什么位置? 抛出了异常会⾃动回滚吗？有没有办法控制不触发回滚? MyBatis怎么防止SQL注入； Tomcat本身的参数你⼀般会怎么调整？ 了解哪几种序列化协议？如何选择合适的序列化协议； Redis渐进式rehash过程？ 比如我有个电商平台，做每日订单的异常检测，服务端代码应该写；]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>面试题</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018年Java面试题汇总 - 3]]></title>
    <url>%2F2018%2F12%2F13%2FJava%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF%20-%203%2F</url>
    <content type="text"><![CDATA[2018年Java面试题汇总 - 3 Java后端技术一、基础题 怎么解决Hash冲突；（开放地址法、链地址法、再哈希法、建立公共溢出区等） 写出一个必然会产生死锁的伪代码； Spring IoC涉及到的设计模式；（工厂模式、单利模式。。） toString()方法什么情况下需要重写； 判断对象相等时，什么情况下只需要重写 equals()，什么情况下需要重写 equals(),hashcode()？ Set内存放的元素为什么不可以重复，内部是如何保证和实现的？ 如何保证分布式缓存的一致性(分布式缓存一致性hash算法?)？分布式session实现？ Java 8流式迭代的好处？ 项目中用到的JDK的哪些特性？ 说一下TreeMap的实现原理？红黑树的性质？红黑树遍历方式有哪些？如果key冲突如何解决？setColor()方法在什么时候用？什么时候会进行旋转和颜色转换？ Spring的bean的创建时机？依赖注入的时机？ ArrayList和LinkList的删除一个元素的时间复杂度；（ArrayList是O(N)，LinkList是O(1)）； CopyOnWriteArrayList是什么； 序列化和反序列化底层如何实现的（ObjectOutputStream 、ObjectInputStream、 readObject writeObject）； 如何调试多线程的程序； 一个线程连着调用start两次会出现什么情况？（由于状态只有就绪、阻塞、执行，状态是无法由执行转化为执行的，所以会报不合法的状态！） HashMap在什么时候时间复杂度是O（1），什么时候是O（n），什么时候又是O（logn）； wait方法能不能被重写？（wait是final类型的，不可以被重写，不仅如此，notify和notifyall都是final类型的），wait能不能被中断； 一个Controller调用两个Service，这两Service又都分别调用两个Dao，问其中用到了几个数据库连接池的连接？ 二、网络基础 HTTP、TCP、UDP的区别和联系； TCP和UDP各自的优势，知道哪些使用UDP协议的成功案例； TCP和UDP各用了底层什么协议； 单个UDP报文最大容量； 单个TCP报文最大容量； TCP报头格式、UDP报头格式； Server遭遇SYN Flood应当怎么处理； Web开发中如何防范XSS？ 拆包和粘包的问题，如何解决，如果我们的包没有固定长度的话，我们的应用程序应该如何解决； 三、操作系统 为什么要内存对齐； 为什么会有大端小端，htol这一类函数的作用； top显示出来的系统信息都是什么含义；（重要！） Linux地址空间，怎么样进行寻址的； Linux如何查找目录或者文件的； 四、分布式其他 分库与分表带来的分布式困境与应对之策； Solr如何实现全天24小时索引更新； 五、Redis Redis插槽的分配（key的有效部分使用CRC16算法计算出哈希值，再将哈希值对16384取余，得到插槽值）; Redis主从是怎么选取的（一种是主动切换，另一种是使用sentinel自动方式）; Redis复制的过程; Redis队列应用场景； Redis主节点宕机了怎么办，还有没有同步的数据怎么办; 六、系统设计开放性题目 秒杀系统设计，超卖怎么搞; 你们的图片时怎么存储的，对应在数据库中时如何保存图片的信息的？ 假如成都没有一座消防站，现在问你要建立几座消防站，每个消防站要配多少名消防官兵，多少辆消防车，请你拿出一个方案； 基于数组实现一个循环阻塞队列； 常见的ipv4地址的展现形式如“168.0.0.1”，请实现ip地址和int类型的相互转换。（使用位移的方式） 现网某个服务部署在多台Liunx服务器上，其中一台突然出现CPU 100%的情况，而其他服务器正常，请列举可能导致这种情况发生的原因？如果您遇到这样的情况，应如何定位？内存？CPU？发布？debug？请求量？ 七、大数据量问题（后边会有专题单独讨论） 给定a、b两个文件，各存放50亿个url，每个url各占64字节，内存限制是4G，让你找出a、b文件共同的url？ 海量日志数据，提取出某日访问百度次数最多的那个IP； 一个文本文件，大约有一万行，每行一个词，要求统计出其中最频繁出现的前10个词，请给出思想，给出时间复杂度分析。 此话题后边会有专门的文章探讨，如果有等不及的小伙伴，可以移步参考： 1、https://blog.csdn.net/v\_july\_v/article/details/6279498 2、https://blog.csdn.net/v\_july\_v/article/details/7382693 八、逻辑思维题 有两根粗细均匀的香（烧香拜佛的香），每一根烧完都花一个小时，怎么样能够得到15min？ 假定你有8个撞球，其中有1个球比其他的球稍重,如果只能利用天平来断定哪一个球重,要找到较重的球,要称几次?（2次）； 实验室里有1000个一模一样的瓶子，但是其中的一瓶有毒。可以用实验室的小白鼠来测试哪一瓶是毒药。如果小白鼠喝掉毒药的话，会在一个星期的时候死去，其他瓶子里的药水没有任何副作用。请问最少用多少只小白鼠可以在一个星期以内查出哪瓶是毒药；（答案是10只） 假设有一个池塘，里面有无穷多的水。现有2个空水壶，容积分别为5升和6升。问题是如何只用这2个水壶从池塘里取得3升的水；]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>面试题</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018年Java面试题汇总 - 2]]></title>
    <url>%2F2018%2F12%2F12%2FJava%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF%20-%202%2F</url>
    <content type="text"><![CDATA[2018年Java面试题汇总 - 2 Java后端技术一、Java相关 Arraylist与LinkedList默认空间是多少； Arraylist与LinkedList区别与各自的优势List 和 Map 区别； 谈谈HashMap，哈希表解决hash冲突的方法； 为什么要重写hashcode()和equals()以及他们之间的区别与关系； Object的hashcode()是怎么计算的？ 若hashcode方法永远返回1或者一个常量会产生什么结果？ Java Collections和Arrays的sort方法默认的排序方法是什么； 引用计数法与GC Root可达性分析法区别； 浅拷贝和深拷贝的区别； String s=”abc”和String s=new String(“abc”)区别； HashSet方法里面的hashcode存在哪，如果重写equals不重写hashcode会怎么样？ 反射的作用与实现原理； Java中的回调机制； 模板方法模式； 开闭原则说一下； 发布/订阅使用场景； KMP算法（一种改进的字符串匹配算法）； JMM里边的原子性、可见性、有序性是如何体现出来的，JMM中内存屏障是什么意思， 二、多线程 AtomicInteger底层实现原理； synchronized与ReentraLock哪个是公平锁； CAS机制会出现什么问题； 用过并发包下边的哪些类； 一个线程连着调用start两次会出现什么情况？ wait方法能不能被重写，wait能不能被中断； 线程池的实现？四种线程池？重要参数及原理？任务拒接策略有哪几种？ 线程状态以及API怎么操作会发生这种转换； 常用的避免死锁方法； 三、JVM Minor GC与Full GC分别在什么时候发生？什么时候触发Full GC; GC收集器有哪些？CMS收集器与G1收集器的特点。 Java在什么时候会出现内存泄漏； Java中的大对象如何进行存储； rt.jar被什么类加载器加载，什么时间加载； 自己写的类被什么加载，什么时间加载； 自己写的两个不同的类是被同一个类加载器加载的吗？为什么？ 为什么新生代内存需要有两个Survivor区？ 几种常用的内存调试工具：jmap、jstack、jconsole； 类加载的五个过程：加载、验证、准备、解析、初始化； G1停顿吗，CMS回收步骤，CMS为什么会停顿，停顿时间； 栈主要存的数据是什么，堆呢？ 堆分为哪几块，比如说新生代老生代，那么新生代又分为什么？ 软引用和弱引用的使用场景（软引用可以实现缓存，弱引用可以用来在回调函数中防止内存泄露）； 四、数据库 数据库索引，什么是全文索引，全文索引中的倒排索引是什么原理； 数据库最佳左前缀原则是什么？ 数据库的三大范式； 悲观锁和乐观锁的原理和应用场景； 左连接、右连接、内连接、外连接、交叉连接、笛卡儿积等； 一般情况下数据库宕机了如何进行恢复（什么是Write Ahead Log机制，什么是Double Write机制，什么是Check Point）； 什么是redo日志、什么是undo日志； 数据库中的隔离性是怎样实现的；原子性、一致性、持久性又是如何实现的； 什么是组合索引，组合索引什么时候会失效； 关系型数据库和非关系型数据库区别； 数据库死锁如何解决； MySQL并发情况下怎么解决（通过事务、隔离级别、锁）； MySQL中的MVCC机制是什么意思，根据具体场景，MVCC是否有问题； MySQL数据库的隔离级别，以及如何解决幻读； 五、缓存服务器 Redis中zSet跳跃表问题； Redis的set的应用场合？ Redis高级特性了解吗？ Redis的pipeline有什么用处？ Redis集群宕机如何处理，怎么样进行数据的迁移； Redis的集群方案； Redis原子操作怎么用比较好； Redis过期策略是怎么实现的呢？ 六、SSM相关 Spring中@Autowired和@Resource注解的区别？ Spring声明一个 bean 如何对其进行个性化定制； MyBatis有什么优势； MyBatis如何做事务管理； 七、操作系统 Linux静态链接和动态链接； 什么是IO多路复用模型（select、poll、epoll）； Linux中的grep管道用处？Linux的常用命令？ 操作系统中虚拟地址、逻辑地址、线性地址、物理地址的概念及区别； 内存的页面置换算法； 内存的页面置换算法； 进程调度算法，操作系统是如何调度进程的； 父子进程、孤儿进程、僵死进程等概念； fork进程时的操作； kill用法，某个进程杀不掉的原因（僵死进程；进入内核态，忽略kill信号）； 系统管理命令（如查看内存使用、网络情况）； find命令、awk使用； Linux下排查某个死循环的线程； 八、网络相关 数据链路层是做什么的? 数据链路层的流量控制？ 网络模型的分层、IP和Mac地址在那个层、TCP和HTTP分别在那个层； TCP滑动窗口； TCP为什么可靠； TCP的同传，拆包与组装包是什么意思； Https和Http有什么区别； Http 为什么是无状态的； TCP三次握手，为什么不是三次，为什么不是四次； TCP的拥塞控制、流量控制详细说明？ Http1.0和Http2.0的区别； 两个不同ip地址的计算机之间如何通信； 地址解析协议ARP； OSI七层模型分别对应着五层模型的哪一部分； TCP三次握手数据丢失了怎么办？那如果后面又找到了呢？ 九、分布式相关 消息队列使用的场景介绍和作用（应用耦合、异步消息、流量削锋等）； 如何解决消息队列丢失消息和重复消费问题； Kafka使用过吗，什么是幂等性？怎么保证一致性，持久化怎么做，分区partition的理解，LEO是什么意思，如何保证多个partition之间数据一致性的（ISR机制），为什么Kafka可以这么快（基于磁盘的顺序读写）； 异步队列怎么实现； 你项目的并发是多少？怎么解决高并发问题？单机情况下Tomcat的并发大概是多少，MySQL的并发大致是多少？ 什么是C10K问题； 高并发情况下怎么办； 分布式理论，什么是CAP理论，什么是Base理论，什么是Paxos理论； 分布式协议的选举算法； 说一下你对微服务的理解，与SOA的区别； Dubbo的基本原理，RPC，支持哪些通信方式，服务的调用过程； Dubbo如果有一个服务挂掉了怎么办； 分布式事务，操作两个表不在一个库，如何保证一致性。 分布式系统中，每台机器如何产生一个唯一的随机值； 系统的量级、pv、uv等； 什么是Hash一致性算法？分布式缓存的一致性，服务器如何扩容（哈希环）； 正向代理、反向代理； 什么是客户端负载均衡策略、什么是服务器端负载均衡策略； 如何优化Tomcat，常见的优化方式有哪些； Nginx的Master和Worker，Nginx是如何处理请求的； 十、系统设计相关 如何防止表单重复提交（Token令牌环等方式）； 有一个url白名单，需要使用正则表达式进行过滤，但是url量级很大，大概亿级，那么如何优化正则表达式？如何优化亿级的url匹配呢？ 常见的Nginx负载均衡策略；已有两台Nginx服务器了，倘若这时候再增加一台服务器，采用什么负载均衡算法比较好？ 扫描二维码登录的过程解析； 如何设计一个生成唯一UUID的算法？ 实现一个负载均衡的算法，服务器资源分配为70%、20%、10%； 有三个线程T1 T2 T3，如何保证他们按顺序执行； 三个线程循环输出ABCABCABC…. 十一、安全相关 什么是XSS攻击，XSS攻击的一般表现形式有哪些？如何防止XSS攻击；]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>面试题</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机网络基础几道常见面试试题]]></title>
    <url>%2F2018%2F12%2F11%2FJava%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF%20-%208%2F</url>
    <content type="text"><![CDATA[计算机网络基础几道常见面试试题 Java后端技术1、OSI，TCP/IP，五层协议的体系结构，以及各层协议 OSI分层 （7层）：物理层、数据链路层、网络层、传输层、会话层、表示层、应用层。 TCP/IP分层（4层）：网络接口层、 网际层、运输层、 应用层。 五层协议 （5层）：物理层、数据链路层、网络层、运输层、 应用层。 每一层的协议如下： 物理层：RJ45、CLOCK、IEEE802.3 （中继器，集线器，网关）； 数据链路：PPP、FR、HDLC、VLAN、MAC （网桥，交换机）； 网络层：IP、ICMP、ARP、RARP、OSPF、IPX、RIP、IGRP、 （路由器）； 传输层：TCP、UDP、SPX； 会话层：NFS、SQL、NETBIOS、RPC； 表示层：JPEG、MPEG、ASII； 应用层：FTP、DNS、Telnet、SMTP、HTTP、WWW、NFS； 每一层的作用如下： 物理层：通过媒介传输比特,确定机械及电气规范（比特Bit） 数据链路层：将比特组装成帧和点到点的传递（帧Frame） 网络层：负责数据包从源到宿的传递和网际互连（包PackeT） 传输层：提供端到端的可靠报文传递和错误恢复（段Segment） 会话层：建立、管理和终止会话（会话协议数据单元SPDU） 表示层：对数据进行翻译、加密和压缩（表示协议数据单元PPDU） 应用层：允许访问OSI环境的手段（应用协议数据单元APDU） 2、IP地址的分类 A类地址：以0开头， 第一个字节范围：0~127（1.0.0.0 - 126.255.255.255）； B类地址：以10开头，第一个字节范围：128~191（128.0.0.0 - 191.255.255.255）； C类地址：以110开头，第一个字节范围：192~223（192.0.0.0 - 223.255.255.255）； 10.0.0.0—10.255.255.255，172.16.0.0—172.31.255.255， 192.168.0.0—192.168.255.255。（Internet上保留地址用于内部） IP地址与子网掩码相与得到主机号 3、TCP三次握手和四次挥手的全过程 三次握手： 第一次握手：客户端发送syn包(syn=x)到服务器，并进入SYN_SEND状态，等待服务器确认； 第二次握手：服务器收到syn包，必须确认客户的SYN（ack=x+1），同时自己也发送一个SYN包（syn=y），即SYN+ACK包，此时服务器进入SYN_RECV状态； 第三次握手：客户端收到服务器的SYN＋ACK包，向服务器发送确认包ACK(ack=y+1)，此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手。 握手过程中传送的包里不包含数据，三次握手完毕后，客户端与服务器才正式开始传送数据。理想状态下，TCP连接一旦建立，在通信双方中的任何一方主动关闭连接之前，TCP 连接都将被一直保持下去。 四次握手 与建立连接的“三次握手”类似，断开一个TCP连接则需要“四次握手”。 第一次挥手：主动关闭方发送一个FIN，用来关闭主动方到被动关闭方的数据传送，也就是主动关闭方告诉被动关闭方：我已经不 会再给你发数据了(当然，在fin包之前发送出去的数据，如果没有收到对应的ack确认报文，主动关闭方依然会重发这些数据)，但是，此时主动关闭方还可 以接受数据。 第二次挥手：被动关闭方收到FIN包后，发送一个ACK给对方，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号）。第三次挥手：被动关闭方发送一个FIN，用来关闭被动关闭方到主动关闭方的数据传送，也就是告诉主动关闭方，我的数据也发送完了，不会再给你发数据了。第四次挥手：主动关闭方收到FIN后，发送一个ACK给被动关闭方，确认序号为收到序号+1，至此，完成四次挥手。 4、各种协议 ICMP协议： 因特网控制报文协议。它是TCP/IP协议族的一个子协议，用于在IP主机、路由器之间传递控制消息。 TFTP协议： 是TCP/IP协议族中的一个用来在客户机与服务器之间进行简单文件传输的协议，提供不复杂、开销不大的文件传输服务。 HTTP协议： 超文本传输协议，是一个属于应用层的面向对象的协议，由于其简捷、快速的方式，适用于分布式超媒体信息系统。 DHCP协议： 动态主机配置协议，是一种让系统得以连接到网络上，并获取所需要的配置参数手段。 NAT协议：网络地址转换属接入广域网(WAN)技术，是一种将私有（保留）地址转化为合法IP地址的转换技术， DHCP协议：一个局域网的网络协议，使用UDP协议工作，用途：给内部网络或网络服务供应商自动分配IP地址，给用户或者内部网络管理员作为对所有计算机作中央管理的手段。 5、在浏览器中输入www.baidu.com后执行的全部过程 1、客户端浏览器通过DNS解析到www.baidu.com的IP地址220.181.27.48，通过这个IP地址找到客户端到服务器的路径。客户端浏览器发起一个HTTP会话到220.161.27.48，然后通过TCP进行封装数据包，输入到网络层。 2、在客户端的传输层，把HTTP会话请求分成报文段，添加源和目的端口，如服务器使用80端口监听客户端的请求，客户端由系统随机选择一个端口如5000，与服务器进行交换，服务器把相应的请求返回给客户端的5000端口。然后使用IP层的IP地址查找目的端。 3、客户端的网络层不用关系应用层或者传输层的东西，主要做的是通过查找路由表确定如何到达服务器，期间可能经过多个路由器，这些都是由路由器来完成的工作，我不作过多的描述，无非就是通过查找路由表决定通过那个路径到达服务器。 4、客户端的链路层，包通过链路层发送到路由器，通过邻居协议查找给定IP地址的MAC地址，然后发送ARP请求查找目的地址，如果得到回应后就可以使用ARP的请求应答交换的IP数据包现在就可以传输了，然后发送IP数据包到达服务器的地址。 6、TCP和UDP的区别？ TCP提供面向连接的、可靠的数据流传输，而UDP提供的是非面向连接的、不可靠的数据流传输。 TCP传输单位称为TCP报文段，UDP传输单位称为用户数据报。 TCP注重数据安全性，UDP数据传输快，因为不需要连接等待，少了许多操作，但是其安全性却一般。 7、TCP对应的协议和UDP对应的协议 TCP对应的协议： （1） FTP：定义了文件传输协议，使用21端口。 （2） Telnet：一种用于远程登陆的端口，使用23端口，用户可以以自己的身份远程连接到计算机上，可提供基于DOS模式下的通信服务。 （3） SMTP：邮件传送协议，用于发送邮件。服务器开放的是25号端口。 （4） POP3：它是和SMTP对应，POP3用于接收邮件。POP3协议所用的是110端口。 （5）HTTP：是从Web服务器传输超文本到本地浏览器的传送协议。 UDP对应的协议： （1） DNS：用于域名解析服务，将域名地址转换为IP地址。DNS用的是53号端口。 （2） SNMP：简单网络管理协议，使用161号端口，是用来管理网络设备的。由于网络设备很多，无连接的服务就体现出其优势。 （3） TFTP(Trival File Tran敏感词er Protocal)，简单文件传输协议，该协议在熟知端口69上使用UDP服务。 8、DNS域名系统，简单描述其工作原理。 当DNS客户机需要在程序中使用名称时，它会查询DNS服务器来解析该名称。客户机发送的每条查询信息包括三条信息：包括：指定的DNS域名，指定的查询类型，DNS域名的指定类别。基于UDP服务，端口53. 该应用一般不直接为用户使用，而是为其他应用服务，如HTTP，SMTP等在其中需要完成主机名到IP地址的转换。 9、TCP的三次握手过程？为什么会采用三次握手，若采用二次握手可以吗？ 答：建立连接的过程是利用客户服务器模式，假设主机A为客户端，主机B为服务器端。 （1）TCP的三次握手过程：主机A向B发送连接请求；主机B对收到的主机A的报文段进行确认；主机A再次对主机B的确认进行确认。 （2）采用三次握手是为了防止失效的连接请求报文段突然又传送到主机B，因而产生错误。失效的连接请求报文段是指：主机A发出的连接请求没有收到主机B的确认，于是经过一段时间后，主机A又重新向主机B发送连接请求，且建立成功，顺序完成数据传输。考虑这样一种特殊情况，主机A第一次发送的连接请求并没有丢失，而是因为网络节点导致延迟达到主机B，主机B以为是主机A又发起的新连接，于是主机B同意连接，并向主机A发回确认，但是此时主机A根本不会理会，主机B就一直在等待主机A发送数据，导致主机B的资源浪费。 （3）采用两次握手不行，原因就是上面说的实效的连接请求的特殊情况。 10、端口及对应的服务？]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>面试题</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018年Java面试题汇总 - 1]]></title>
    <url>%2F2018%2F12%2F11%2FJava%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF%20-%201%2F</url>
    <content type="text"><![CDATA[2018年Java面试题汇总 - 1 Java后端技术一、基础篇1.1、Java基础 面向对象的特征：继承、封装和多态 final, finally, finalize 的区别 Exception、Error、运行时异常与一般异常有何异同 请写出5种常见到的runtime exception int 和 Integer 有什么区别，Integer的值缓存范围 包装类，装箱和拆箱 String、StringBuilder、StringBuffer 重载和重写的区别 抽象类和接口有什么区别 说说反射的用途及实现 说说自定义注解的场景及实现 HTTP请求的GET与POST方式的区别 Session与Cookie区别 列出自己常用的JDK包 MVC设计思想 equals与==的区别 hashCode和equals方法的区别与联系 什么是Java序列化和反序列化，如何实现Java序列化？或者请解释Serializable 接口的作用 Object类中常见的方法，为什么wait notify会放在Object里边？ Java的平台无关性如何体现出来的 JDK和JRE的区别 Java 8有哪些新特性 1.2、Java常见集合 List 和 Set 区别 Set和hashCode以及equals方法的联系 List 和 Map 区别 Arraylist 与 LinkedList 区别 ArrayList 与 Vector 区别 HashMap 和 Hashtable 的区别 HashSet 和 HashMap 区别 HashMap 和 ConcurrentHashMap 的区别 HashMap 的工作原理及代码实现，什么时候用到红黑树 多线程情况下HashMap死循环的问题 HashMap出现Hash DOS攻击的问题 ConcurrentHashMap 的工作原理及代码实现，如何统计所有的元素个数 手写简单的HashMap 看过那些Java集合类的源码 1.3、进程和线程 线程和进程的概念、并行和并发的概念 创建线程的方式及实现 进程间通信的方式 说说 CountDownLatch、CyclicBarrier 原理和区别 说说 Semaphore 原理 说说 Exchanger 原理 ThreadLocal 原理分析，ThreadLocal为什么会出现OOM，出现的深层次原理 讲讲线程池的实现原理 线程池的几种实现方式 线程的生命周期，状态是如何转移的 可参考：《Java多线程编程核心技术》 1.4、锁机制 说说线程安全问题，什么是线程安全，如何保证线程安全 重入锁的概念，重入锁为什么可以防止死锁 产生死锁的四个条件（互斥、请求与保持、不剥夺、循环等待） 如何检查死锁（通过jConsole检查死锁） volatile 实现原理（禁止指令重排、刷新内存） synchronized 实现原理（对象监视器） synchronized 与 lock 的区别 AQS同步队列 CAS无锁的概念、乐观锁和悲观锁 常见的原子操作类 什么是ABA问题，出现ABA问题JDK是如何解决的 乐观锁的业务场景及实现方式 Java 8并法包下常见的并发类 偏向锁、轻量级锁、重量级锁、自旋锁的概念 可参考：《Java多线程编程核心技术》 1.5、JVM JVM运行时内存区域划分 内存溢出OOM和堆栈溢出SOE的示例及原因、如何排查与解决 如何判断对象是否可以回收或存活 常见的GC回收算法及其含义 常见的JVM性能监控和故障处理工具类：jps、jstat、jmap、jinfo、jconsole等 JVM如何设置参数 JVM性能调优 类加载器、双亲委派模型、一个类的生命周期、类是如何加载到JVM中的 类加载的过程：加载、验证、准备、解析、初始化 强引用、软引用、弱引用、虚引用 Java内存模型JMM 1.6、设计模式 常见的设计模式 设计模式的的六大原则及其含义 常见的单例模式以及各种实现方式的优缺点，哪一种最好，手写常见的单利模式 设计模式在实际场景中的应用 Spring中用到了哪些设计模式 MyBatis中用到了哪些设计模式 你项目中有使用哪些设计模式 说说常用开源框架中设计模式使用分析 动态代理很重要！！！ 1.7、数据结构 树（二叉查找树、平衡二叉树、红黑树、B树、B+树） 深度有限算法、广度优先算法 克鲁斯卡尔算法、普林母算法、迪克拉斯算法 什么是一致性Hash及其原理、Hash环问题 常见的排序算法和查找算法：快排、折半查找、堆排序等 1.**8、网络/IO基础** BIO、NIO、AIO的概念 什么是长连接和短连接 Http1.0和2.0相比有什么区别，可参考《Http 2.0》 Https的基本概念 三次握手和四次挥手、为什么挥手需要四次 从游览器中输入URL到页面加载的发生了什么？可参考《从输入URL到页面加载发生了什么》 二、数据存储和消息队列 2.1、数据库 MySQL 索引使用的注意事项 DDL、DML、DCL分别指什么 explain命令 left join，right join，inner join 数据库事物ACID（原子性、一致性、隔离性、持久性） 事物的隔离级别（读未提交、读以提交、可重复读、可序列化读） 脏读、幻读、不可重复读 数据库的几大范式 数据库常见的命令 说说分库与分表设计 分库与分表带来的分布式困境与应对之策（如何解决分布式下的分库分表，全局表？） 说说 SQL 优化之道 MySQL遇到的死锁问题、如何排查与解决 存储引擎的 InnoDB与MyISAM区别，优缺点，使用场景 索引类别（B+树索引、全文索引、哈希索引）、索引的原理 什么是自适应哈希索引（AHI） 为什么要用 B+tree作为MySQL索引的数据结构 聚集索引与非聚集索引的区别 遇到过索引失效的情况没，什么时候可能会出现，如何解决 limit 20000 加载很慢怎么解决 如何选择合适的分布式主键方案 选择合适的数据存储方案 常见的几种分布式ID的设计方案 常见的数据库优化方案，在你的项目中数据库如何进行优化的 2.2、Redis Redis 有哪些数据类型，可参考《Redis常见的5种不同的数据类型详解》 Redis 内部结构 Redis 使用场景 Redis 持久化机制，可参考《使用快照和AOF将Redis数据持久化到硬盘中》 Redis 集群方案与实现 Redis 为什么是单线程的？ 缓存雪崩、缓存穿透、缓存预热、缓存更新、缓存降级 使用缓存的合理性问题 Redis常见的回收策略 2.3、消息队列 消息队列的使用场景 消息的重发补偿解决思路 消息的幂等性解决思路 消息的堆积解决思路 自己如何实现消息队列 如何保证消息的有序性 三、开源框架和容器3.1、SSM/Servlet Servlet的生命周期 转发与重定向的区别 BeanFactory 和 ApplicationContext 有什么区别 Spring Bean 的生命周期 Spring IOC 如何实现 Spring中Bean的作用域，默认的是哪一个 说说 Spring AOP、Spring AOP 实现原理 动态代理（CGLib 与 JDK）、优缺点、性能对比、如何选择 Spring 事务实现方式、事务的传播机制、默认的事务类别 Spring 事务底层原理 Spring事务失效（事务嵌套），JDK动态代理给Spring事务埋下的坑，可参考《JDK动态代理给Spring事务埋下的坑！》 如何自定义注解实现功能 Spring MVC 运行流程 Spring MVC 启动流程 Spring 的单例实现原理 Spring 框架中用到了哪些设计模式 Spring 其他产品（Srping Boot、Spring Cloud、Spring Secuirity、Spring Data、Spring AMQP 等） 有没有用到Spring Boot，Spring Boot的认识、原理 MyBatis的原理 可参考《为什么会有Spring》 可参考《为什么会有Spring AOP》 3.2、Netty 为什么选择 Netty 说说业务中，Netty 的使用场景 原生的 NIO 在 JDK 1.7 版本存在 epoll bug 什么是TCP 粘包/拆包 TCP粘包/拆包的解决办法 Netty 线程模型 说说 Netty 的零拷贝 Netty 内部执行流程 Netty 重连实现 3.3、Tomcat Tomcat的基础架构（Server、Service、Connector、Container） Tomcat如何加载Servlet的 Pipeline-Valve机制 可参考：《四张图带你了解Tomcat系统架构！》 四、分布式4.1、Nginx 请解释什么是C10K问题或者知道什么是C10K问题吗？ Nginx简介，可参考《Nginx简介》 正向代理和反向代理. Nginx几种常见的负载均衡策略 Nginx服务器上的Master和Worker进程分别是什么 使用“反向代理服务器”的优点是什么? 4.2、分布式其他 谈谈业务中使用分布式的场景 Session 分布式方案 Session 分布式处理 分布式锁的应用场景、分布式锁的产生原因、基本概念 分布是锁的常见解决方案 分布式事务的常见解决方案 集群与负载均衡的算法与实现 说说分库与分表设计，可参考《数据库分库分表策略的具体实现方案》 分库与分表带来的分布式困境与应对之策 4.3、Dubbo** 什么是Dubbo，可参考《Dubbo入门》 什么是RPC、如何实现RPC、RPC 的实现原理，可参考《基于HTTP的RPC实现》 Dubbo中的SPI是什么概念 Dubbo的基本原理、执行流程 五、微服务 5.1、微服务 前后端分离是如何做的？ 微服务哪些框架 Spring Could的常见组件有哪些？可参考《Spring Cloud概述》 领域驱动有了解吗？什么是领域驱动模型？充血模型、贫血模型 JWT有了解吗，什么是JWT，可参考《前后端分离利器之JWT》 你怎么理解 RESTful 说说如何设计一个良好的 API 如何理解 RESTful API 的幂等性 如何保证接口的幂等性 说说 CAP 定理、BASE 理论 怎么考虑数据一致性问题 说说最终一致性的实现方案 微服务的优缺点，可参考《微服务批判》 微服务与 SOA 的区别 如何拆分服务、水平分割、垂直分割 如何应对微服务的链式调用异常 如何快速追踪与定位问题 如何保证微服务的安全、认证 5.2、安全问题 如何防范常见的Web攻击、如何方式SQL注入 服务端通信安全攻防 HTTPS原理剖析、降级攻击、HTTP与HTTPS的对比 5.3、性能优化 性能指标有哪些 如何发现性能瓶颈 性能调优的常见手段 说说你在项目中如何进行性能调优 六、其他6.1、设计能力 说说你在项目中使用过的UML图 你如何考虑组件化、服务化、系统拆分 秒杀场景如何设计 可参考：《秒杀系统的技术挑战、应对策略以及架构设计总结一二！》 6.2、业务工程 说说你的开发流程、如何进行自动化部署的 你和团队是如何沟通的 你如何进行代码评审 说说你对技术与业务的理解 说说你在项目中遇到感觉最难Bug，是如何解决的 介绍一下工作中的一个你认为最有价值的项目，以及在这个过程中的角色、解决的问题、你觉得你们项目还有哪些不足的地方 6.3、软实力 说说你的优缺点、亮点 说说你最近在看什么书、什么博客、在研究什么新技术、再看那些开源项目的源代码 说说你觉得最有意义的技术书籍 工作之余做什么事情、平时是如何学习的，怎样提升自己的能力 说说个人发展方向方面的思考 说说你认为的服务端开发工程师应该具备哪些能力 说说你认为的架构师是什么样的，架构师主要做什么 如何看待加班的问题 当然，一个完整的面试肯定不止上述的知识点，其他的诸如：Linux、数据结构、算法、逻辑思维题、系统设计题、职业规划等等都会有所涉及！总之，充分的准备是应对一切面试的不二法宝！ 欢迎留言讨论上述的问题！有哪些经常被问到的面试题也欢迎大家留言补充！]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>面试题</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[利用Gogs搭建个人Git服务]]></title>
    <url>%2F2018%2F10%2F11%2Fgogs-personal-git-server%2F</url>
    <content type="text"><![CDATA[服务器： CentOS 7容器： Docker 18环境： MySQL 5.7 + Gogs:0.11.66 1.Docker容器内安装MySQL1234567891011121314docker pull mysqldocker pull registry.docker-cn.com/library/mysql:8.0.12docker pull registry.docker-cn.com/library/mysql:5.7docker images |grep mysqldocker run --name some-mysql -e MYSQL_ROOT_PASSWORD=my-secret-pw -d mysql:tagdocker run --name mymysql -e MYSQL_ROOT_PASSWORD=123456 -d -i -p 3306:3306 6a834f03bd02/*数据卷的挂载*/docker run -i -t --name mymysql -p 3306:3306 -v /var/lib/mysql:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=123456 563a026a1511 error: database is uninitialized and password option is not specified You need to specify one of MYSQL_ROOT_PASSWORD, MYSQL_ALLOW_EMPTY_PASSWORD and MYSQL_RANDOM_ROOT_PASSWORD 进入MySQL终端教程 1234docker exec -it 63ca57bd6dc5 /bin/bashmysql -h 127.0.0.1 -u root -pmysql -h 192.168.1.105 -u root -p Welcome to the MySQL monitor. Commands end with ; or \g. Your MySQL connection id is 12 Server version: 8.0.12 MySQL Community Server - GPL Copyright (c) 2000, 2018, Oracle and/or its affiliates. All rights reserved. Oracle is a registered trademark of Oracle Corporation and/or its affiliates. Other names may be trademarks of their respective owners. Type &apos;help;&apos; or &apos;\h&apos; for help. Type &apos;\c&apos; to clear the current input statement. mysql&gt; 查看已经创建的容器1docker ps -a 查看正在运行的容器1docker ps -s docker stop mymysql docker rm mymysql docker rmi 6a834f03bd02 防火墙开启3306端口1234567firewall-cmd --query-port=3306/tcpfirewall-cmd --add-port=3306/tcpfirewall-cmd --zone=public --add-port=3306/tcp --permanentfirewall-cmd --query-port=3306/tcp 12exitclear MySQL Workbench连接 2.Docker容器内安装Gogshttps://blog.upx8.com/1660 https://github.com/gogs/gogs/tree/master/docker # Pull image from Docker Hub. $ docker pull gogs/gogs:0.11.66 # Create local directory for volume. $ mkdir -p /var/gogs # Use `docker run` for the first time. $ docker run --name=mygogs -p 10022:22 -p 10080:3000 -v /var/gogs:/data gogs/gogs:0.11.66 # Use `docker start` if you have stopped it. $ docker start gogs $ mysql -u root -p mysql&gt; # （输入密码） mysql&gt; create user &apos;gogs&apos;@&apos;localhost&apos; identified by &apos;密码&apos;; mysql&gt; grant all privileges on gogs.* to &apos;gogs&apos;@&apos;localhost&apos;; mysql&gt; flush privileges; mysql&gt; exit; 然后访问 http://192.168.1.105:10080/ Bingo：]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Git</tag>
        <tag>Docker</tag>
        <tag>Gogs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CentOS 7和Docker使用以及常用中间件安装指南]]></title>
    <url>%2F2018%2F09%2F22%2Fcentos-middlewareguide%2F</url>
    <content type="text"><![CDATA[Oracle VM Virtual Box安装CentOS 7过程Install 启动网络服务123456789ip addrvi /etc/sysconfig/network-scripts/ifcfg-ens33ONBOOT=yessudo service network restartip addr 关机/重启命令Shuntdown Command Linux centos重启命令： 1、reboot 普通重启 2、shutdown -r now 立刻重启(root用户使用) 3、shutdown -r 10 过10分钟自动重启(root用户使用) 4、shutdown -r 20:35 在时间为20:35时候重启(root用户使用) 如果是通过shutdown命令设置重启的话，可以用shutdown -c命令取消重启 Linux centos关机命令： 1、halt 立刻关机 2、poweroff 立刻关机 3、shutdown -h now 立刻关机(root用户使用) 4、shutdown -h 10 10分钟后自动关机 Putty连接Putty Firewall 安装DockerDocker 1$ sudo yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo 由于国内访问不到docker官方镜像，可以通过aliyun的源来完成。 阿里云镜像 12$ sudo systemctl start docker$ sudo systemctl enable docker Docker镜像Docker Hub Redishttps://hub.docker.com/_/redis/ 1docker pull redis 镜像加速 1$ docker pull registry.docker-cn.com/myname/myrepo:mytag 例如: 1$ docker pull registry.docker-cn.com/library/ubuntu:16.04 1$ docker pull registry.docker-cn.com/library/redis:5.0-rc-alpine3.8 12345678910111213141516171819[root@localhost /]# docker pull registry.docker-cn.com/library/redisUsing default tag: latestlatest: Pulling from library/redis802b00ed6f79: Pull complete8b4a21f633de: Pull complete92e244f8ff14: Pull completefbf4770cd9d6: Pull complete1479f3bcce09: Pull completeb4020173179f: Pull completeDigest: sha256:b77926b30ca2f126431e4c2055efcf2891ebd4b4c4a86a53cf85ec3d4c98a4c9Status: Downloaded newer image for registry.docker-cn.com/library/redis:latest[root@localhost /]# docker imagesREPOSITORY TAG IMAGE ID C REATED SIZEregistry.docker-cn.com/library/redis latest e1a73233e3be 2 weeks ago 83.4MB[root@localhost /]# docker run -d -p 6379:6379 --name myredis registry.docker-cn.co m/library/redis15ce42331abfdada499378b9021a6b8506028577e7411d9b4530f55678656aa3[root@localhost /]# docker psCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES15ce42331abf registry.docker-cn.com/library/redis &quot;docker-entrypoint.s…&quot; 28 seconds ago Up 26 seconds 0.0.0.0:6379-&gt;6379/tcp myredis 1docker run -d -p 6379:6379 --name myredis registry.docker-cn.com/library/redis 1docker run -d -p 192.168.1.105:6379:6379 --name myredis registry.docker-cn.com/library/redis /bin/bash 123456$ docker ps // 查看所有正在运行容器$ docker stop containerId // containerId 是容器的ID$ docker ps -a // 查看所有容器$ docker ps -a -q // 查看所有容器ID$ docker stop $(docker ps -a -q) // stop停止所有容器$ docker rm $(docker ps -a -q) // remove删除所有容器 6379端口防火墙 12345vi /etc/sysconfig/iptablesfirewall-cmd --add-port=6379/tcpfirewall-cmd --query-port=6379/tcp 防火墙服务 启动一个服务：systemctl start firewalld.service关闭一个服务：systemctl stop firewalld.service重启一个服务：systemctl restart firewalld.service显示一个服务的状态：systemctl status firewalld.service在开机时启用一个服务：systemctl enable firewalld.service在开机时禁用一个服务：systemctl disable firewalld.service查看服务是否开机启动：systemctl is-enabled firewalld.service查看已启动的服务列表：systemctl list-unit-files|grep enabled查看启动失败的服务列表：systemctl –failed 12345firewall-cmd --zone=public --add-port=80/tcp --permanentfirewall-cmd --zone=public --add-port=8080/tcp --permanentfirewall-cmd --zone=public --add-port=6379/tcp --permanent Windows 查看某个端口是否被占用： 1netstat -aon|findstr &quot;8080&quot; RabbitMQ123docker pull registry.docker-cn.com/library/rabbitmq:3.6-managementdocker run -d -p 5672:5672 -p 15672:15672 --name myrabbitmq aa516f32cebc 移除镜像： 12345docker ps -adocker rm containeriddocker rmi imageid Elasticsearch1234567docker search elasticsearchdocker pull elasticsearchdocker pull registry.docker-cn.com/library/elasticsearchdocker run -e ES_JAVA_OPTS=&quot;-Xms256m -Xmx512m&quot; -d -p 9200:9200 -p 9300:9300 --name myelasticsearch 5acf0e8da90b 容器重命名docker rename myelasticsearch1 myelasticsearch spring-data-elasticsearchProject Metadata Version Control spring data elasticsearch elasticsearch 3.1.x 6.2.2 3.0.x 5.5.0 2.1.x 2.4.0 2.0.x 2.2.0 1.3.x 1.5.2 12345docker pull registry.docker-cn.com/library/elasticsearch:2.4docker run -e ES_JAVA_OPTS=&quot;-Xms256m -Xmx256m&quot; -d -p 9201:9200 -p 9301:9300 --name myelasticsearch1 5e9d896dc62cdocker stop myelasticsearch MySQL1234567891011121314docker pull mysqldocker pull registry.docker-cn.com/library/mysql:8.0.12docker pull registry.docker-cn.com/library/mysql:5.7docker images |grep mysqldocker run --name some-mysql -e MYSQL_ROOT_PASSWORD=my-secret-pw -d mysql:tagdocker run --name mymysql -e MYSQL_ROOT_PASSWORD=123456 -d -i -p 3306:3306 6a834f03bd02/*数据卷的挂载*/docker run -i -t --name mymysql -p 3306:3306 -v /var/lib/mysql:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=123456 563a026a1511 error: database is uninitialized and password option is not specified You need to specify one of MYSQL_ROOT_PASSWORD, MYSQL_ALLOW_EMPTY_PASSWORD and MYSQL_RANDOM_ROOT_PASSWORD 进入MySQL终端教程 1234docker exec -it 63ca57bd6dc5 /bin/bashmysql -h 127.0.0.1 -u root -pmysql -h 192.168.1.105 -u root -p Welcome to the MySQL monitor. Commands end with ; or \g. Your MySQL connection id is 12 Server version: 8.0.12 MySQL Community Server - GPL Copyright (c) 2000, 2018, Oracle and/or its affiliates. All rights reserved. Oracle is a registered trademark of Oracle Corporation and/or its affiliates. Other names may be trademarks of their respective owners. Type &apos;help;&apos; or &apos;\h&apos; for help. Type &apos;\c&apos; to clear the current input statement. mysql&gt; 查看已经创建的容器1docker ps -a 查看正在运行的容器1docker ps -s docker stop mymysql docker rm mymysql docker rmi 6a834f03bd02 防火墙开启3306端口1234567firewall-cmd --query-port=3306/tcpfirewall-cmd --add-port=3306/tcpfirewall-cmd --zone=public --add-port=3306/tcp --permanentfirewall-cmd --query-port=3306/tcp 12exitclear MySQL Workbench连接 Gogshttps://blog.upx8.com/1660 https://github.com/gogs/gogs/tree/master/docker # Pull image from Docker Hub. $ docker pull gogs/gogs:0.11.66 # Create local directory for volume. $ mkdir -p /var/gogs # Use `docker run` for the first time. $ docker run --name=mygogs -p 10022:22 -p 10080:3000 -v /var/gogs:/data gogs/gogs:0.11.66 # Use `docker start` if you have stopped it. $ docker start gogs $ mysql -u root -p mysql&gt; # （输入密码） mysql&gt; create user &apos;gogs&apos;@&apos;localhost&apos; identified by &apos;密码&apos;; mysql&gt; grant all privileges on gogs.* to &apos;gogs&apos;@&apos;localhost&apos;; mysql&gt; flush privileges; mysql&gt; exit; 然后访问 http://192.168.1.105:10080/ Bingo：]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Docker</tag>
        <tag>CentOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot整合Swagger2并汉化]]></title>
    <url>%2F2018%2F07%2F06%2Fswagger2-spring%2F</url>
    <content type="text"><![CDATA[本文将介Swagger2，它可以轻松组织出强大RESTful API文档。它既可以减少我们创建文档的工作量，同时说明内容又整合入实现代码中，让维护文档和修改代码整合为一体，可以让我们在修改代码逻辑的同时方便的修改文档说明。另外Swagger2也提供了强大的页面测试功能来调试每个RESTful API，而不再需要Postman。 Swagger2注解说明Swagger通过注解表明该接口会生成文档，包括接口名、请求方法、参数、返回信息的等等。 1234567891011@Api：修饰整个类，描述Controller的作用@ApiOperation：描述一个类的一个方法，或者说一个接口@ApiParam：单个参数描述@ApiModel：用对象来接收参数@ApiProperty：用对象接收参数时，描述对象的一个字段@ApiResponse：HTTP响应其中1个描述@ApiResponses：HTTP响应整体描述@ApiIgnore：使用该注解忽略这个API@ApiError ：发生错误返回的信息@ApiImplicitParam：一个请求参数@ApiImplicitParams：多个请求参数 @Api：用在请求的类上，表示对类的说明 tags=”说明该类的作用，可以在UI界面上看到的注解” value=”该参数没什么意义，在UI界面上也看到，所以不需要配置” @ApiOperation：用在请求的方法上，说明方法的用途、作用 value=”说明方法的用途、作用” notes=”方法的备注说明” @ApiImplicitParams：用在请求的方法上，表示一组参数说明 @ApiImplicitParam：用在@ApiImplicitParams注解中，指定一个请求参数的各个方面 name：参数名 value：参数的汉字说明、解释 required：参数是否必须传 paramType：参数放在哪个地方 header –&gt; 请求参数的获取：@RequestHeader query –&gt; 请求参数的获取：@RequestParam path（用于restful接口）–&gt; 请求参数的获取：@PathVariable body（不常用） form（不常用） dataType：参数类型，默认String，其它值dataType=”Integer” defaultValue：参数的默认值 @ApiResponses：用在请求的方法上，表示一组响应 @ApiResponse：用在@ApiResponses中，一般用于表达一个错误的响应信息 code：数字，例如400 message：信息，例如”请求参数没填好” response：抛出异常的类 @ApiModel：用于响应类上，表示一个返回响应数据的信息，（这种一般用在post创建的时候，使用@RequestBody这样的场景，请求参数无法使用@ApiImplicitParam注解进行描述的时候） @ApiModelProperty：用在属性上，描述响应类的属性 Swagger2注解示例示例1： 1@Api(tags=&quot;APP用户注册Controller&quot;) 示例2： 123456789@ApiOperation(value=&quot;用户注册&quot;,notes=&quot;手机号、密码都是必输项，年龄随边填，但必须是数字&quot;)示列：@ApiImplicitParams(&#123; @ApiImplicitParam(name=&quot;mobile&quot;,value=&quot;手机号&quot;,required=true,paramType=&quot;form&quot;), @ApiImplicitParam(name=&quot;password&quot;,value=&quot;密码&quot;,required=true,paramType=&quot;form&quot;), @ApiImplicitParam(name=&quot;age&quot;,value=&quot;年龄&quot;,required=true,paramType=&quot;form&quot;,dataType=&quot;Integer&quot;)&#125;) 示例3： 12345@ApiOperation(value = &quot;select1请求&quot;,notes = &quot;多个参数，多种的查询参数类型&quot;)@ApiResponses(&#123; @ApiResponse(code=400,message=&quot;请求参数没填好&quot;), @ApiResponse(code=404,message=&quot;请求路径没有或页面跳转路径不对&quot;)&#125;) 示例4: 12345678910111213141516171819import io.swagger.annotations.ApiModel;import io.swagger.annotations.ApiModelProperty;import java.io.Serializable;@ApiModel(description= &quot;返回响应数据&quot;)public class RestMessage implements Serializable&#123; @ApiModelProperty(value = &quot;是否成功&quot;) private boolean success=true; @ApiModelProperty(value = &quot;返回对象&quot;) private Object data; @ApiModelProperty(value = &quot;错误编号&quot;) private Integer errCode; @ApiModelProperty(value = &quot;错误信息&quot;) private String message; /* getter/setter */&#125; Swagger2整合实践首先打开Intellij Idea工具创建Spring Initializr项目。 1.添加依赖1234567891011&lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt; &lt;version&gt;2.6.1&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt; &lt;version&gt;2.6.1&lt;/version&gt;&lt;/dependency&gt; 2.编写Swagger配置类其实这个配置类，只要了解具体能配置哪些东西就好了，毕竟这个东西配置一次之后就不用再动了。 特别要注意的是里面配置了api文件也就是controller包的路径，不然生成的文档扫描不到接口。 1234567891011121314151617181920212223242526272829303132333435363738package com.example.swagger2demo;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import springfox.documentation.builders.ApiInfoBuilder;import springfox.documentation.builders.PathSelectors;import springfox.documentation.builders.RequestHandlerSelectors;import springfox.documentation.service.ApiInfo;import springfox.documentation.spi.DocumentationType;import springfox.documentation.spring.web.plugins.Docket;/** * @author waylanpunch * @ClassName com.example.swagger2demo.Swagger2 * @Description Swagger2 Configuration */@Configurationpublic class Swagger2 &#123; @Bean public Docket createRestApi() &#123; return new Docket(DocumentationType.SWAGGER_2) .apiInfo(apiInfo()) .select() .apis(RequestHandlerSelectors.basePackage(&quot;com.example.swagger2demo.controller&quot;)) .paths(PathSelectors.any()) .build(); &#125; private ApiInfo apiInfo() &#123; return new ApiInfoBuilder() .title(&quot;springboot利用swagger构建api文档&quot;) .description(&quot;简单优雅的REST风格，https://github.com/WaylanPunch/&quot;) .termsOfServiceUrl(&quot;https://github.com/WaylanPunch/&quot;) .version(&quot;1.0&quot;) .build(); &#125;&#125; 用@Configuration注解该类，等价于XML中配置beans；用@Bean标注方法等价于XML中配置bean。 3.创建Restful API 一个UserController类提供访问接口 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146package com.example.swagger2demo.controller;import com.example.swagger2demo.bean.JsonResult;import com.example.swagger2demo.bean.User;import io.swagger.annotations.ApiImplicitParam;import io.swagger.annotations.ApiImplicitParams;import io.swagger.annotations.ApiOperation;import org.springframework.http.ResponseEntity;import org.springframework.web.bind.annotation.*;import springfox.documentation.annotations.ApiIgnore;import java.util.*;/** * @author waylanpunch * @ClassName com.example.swagger2demo.controller.UserController * @Description UserController for User Controller */@RestControllerpublic class UserController &#123; // 创建线程安全的Map static Map&lt;Integer, User&gt; users = Collections.synchronizedMap(new HashMap&lt;Integer, User&gt;()); /** * 根据ID查询用户 * @param id * @return */ @ApiOperation(value=&quot;获取用户详细信息&quot;, notes=&quot;根据url的id来获取用户详细信息&quot;) @ApiImplicitParam(name = &quot;id&quot;, value = &quot;用户ID&quot;, required = true, dataType = &quot;Integer&quot;, paramType = &quot;path&quot;) @RequestMapping(value = &quot;user/&#123;id&#125;&quot;, method = RequestMethod.GET) public ResponseEntity&lt;JsonResult&gt; getUserById (@PathVariable(value = &quot;id&quot;) Integer id)&#123; JsonResult r = new JsonResult(); try &#123; User user = users.get(id); r.setResult(user); r.setStatus(&quot;ok&quot;); &#125; catch (Exception e) &#123; r.setResult(e.getClass().getName() + &quot;:&quot; + e.getMessage()); r.setStatus(&quot;error&quot;); e.printStackTrace(); &#125; return ResponseEntity.ok(r); &#125; /** * 查询用户列表 * @return */ @ApiOperation(value=&quot;获取用户列表&quot;, notes=&quot;获取用户列表&quot;) @RequestMapping(value = &quot;users&quot;, method = RequestMethod.GET) public ResponseEntity&lt;JsonResult&gt; getUserList ()&#123; JsonResult r = new JsonResult(); try &#123; List&lt;User&gt; userList = new ArrayList&lt;User&gt;(users.values()); r.setResult(userList); r.setStatus(&quot;ok&quot;); &#125; catch (Exception e) &#123; r.setResult(e.getClass().getName() + &quot;:&quot; + e.getMessage()); r.setStatus(&quot;error&quot;); e.printStackTrace(); &#125; return ResponseEntity.ok(r); &#125; /** * 添加用户 * @param user * @return */ @ApiOperation(value=&quot;创建用户&quot;, notes=&quot;根据User对象创建用户&quot;) @ApiImplicitParam(name = &quot;user&quot;, value = &quot;用户详细实体user&quot;, required = true, dataType = &quot;User&quot;) @RequestMapping(value = &quot;user&quot;, method = RequestMethod.POST) public ResponseEntity&lt;JsonResult&gt; add (@RequestBody User user)&#123; JsonResult r = new JsonResult(); try &#123; users.put(user.getId(), user); r.setResult(user.getId()); r.setStatus(&quot;ok&quot;); &#125; catch (Exception e) &#123; r.setResult(e.getClass().getName() + &quot;:&quot; + e.getMessage()); r.setStatus(&quot;error&quot;); e.printStackTrace(); &#125; return ResponseEntity.ok(r); &#125; /** * 根据id删除用户 * @param id * @return */ @ApiOperation(value=&quot;删除用户&quot;, notes=&quot;根据url的id来指定删除用户&quot;) @ApiImplicitParam(name = &quot;id&quot;, value = &quot;用户ID&quot;, required = true, dataType = &quot;Long&quot;, paramType = &quot;path&quot;) @RequestMapping(value = &quot;user/&#123;id&#125;&quot;, method = RequestMethod.DELETE) public ResponseEntity&lt;JsonResult&gt; delete (@PathVariable(value = &quot;id&quot;) Integer id)&#123; JsonResult r = new JsonResult(); try &#123; users.remove(id); r.setResult(id); r.setStatus(&quot;ok&quot;); &#125; catch (Exception e) &#123; r.setResult(e.getClass().getName() + &quot;:&quot; + e.getMessage()); r.setStatus(&quot;error&quot;); e.printStackTrace(); &#125; return ResponseEntity.ok(r); &#125; /** * 根据id修改用户信息 * @param user * @return */ @ApiOperation(value=&quot;更新信息&quot;, notes=&quot;根据url的id来指定更新用户信息&quot;) @ApiImplicitParams(&#123; @ApiImplicitParam(name = &quot;id&quot;, value = &quot;用户ID&quot;, required = true, dataType = &quot;Long&quot;,paramType = &quot;path&quot;), @ApiImplicitParam(name = &quot;user&quot;, value = &quot;用户实体user&quot;, required = true, dataType = &quot;User&quot;) &#125;) @RequestMapping(value = &quot;user/&#123;id&#125;&quot;, method = RequestMethod.PUT) public ResponseEntity&lt;JsonResult&gt; update (@PathVariable(&quot;id&quot;) Integer id, @RequestBody User user)&#123; JsonResult r = new JsonResult(); try &#123; User u = users.get(id); u.setUsername(user.getUsername()); u.setAge(user.getAge()); users.put(id, u); r.setResult(u); r.setStatus(&quot;ok&quot;); &#125; catch (Exception e) &#123; r.setResult(e.getClass().getName() + &quot;:&quot; + e.getMessage()); r.setStatus(&quot;error&quot;); e.printStackTrace(); &#125; return ResponseEntity.ok(r); &#125; @ApiIgnore//使用该注解忽略这个API @RequestMapping(value = &quot;/hi&quot;, method = RequestMethod.GET) public String jsonTest() &#123; return &quot; hi you!&quot;; &#125;&#125; Json格式输出类 JsonResult.class 12345678910111213141516171819202122232425262728package com.example.swagger2demo.bean;/** * @author waylanpunch * @ClassName com.example.swagger2demo.bean.JsonResult * @Description JsonResult Bean */public class JsonResult &#123; private String status = null; private Object result = null; public String getStatus() &#123; return status; &#125; public void setStatus(String status) &#123; this.status = status; &#125; public Object getResult() &#123; return result; &#125; public void setResult(Object result) &#123; this.result = result; &#125;&#125; 实体User.class 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748package com.example.swagger2demo.bean;import java.util.Date;/** * @author waylanpunch * @ClassName com.example.swagger2demo.bean.User * @Description User Bean */public class User &#123; private int id; private String username; private int age; private Date ctm; public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; public Date getCtm() &#123; return ctm; &#125; public void setCtm(Date ctm) &#123; this.ctm = ctm; &#125;&#125; 4.启动类添加@EnableSwagger2注解1234567891011121314package com.example.swagger2demo;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import springfox.documentation.swagger2.annotations.EnableSwagger2;@SpringBootApplication@EnableSwagger2public class Swagger2demoApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(Swagger2demoApplication.class, args); &#125;&#125; 5.访问Swagger2文档启动SpringBoot项目，访问 http://localhost:8080/swagger-ui.html Swagger2汉化过程 swagger-ui/dist/lang/translator.js文档中有这样一段描述： To enable translation you should include one of language-files in your index.html after 12&gt; &lt;script src=&apos;lang/translator.js&apos; type=&apos;text/javascript&apos;&gt;&lt;/script&gt;&gt; For example - 12&gt; &lt;script src=&apos;lang/ru.js&apos; type=&apos;text/javascript&apos;&gt;&lt;/script&gt;&gt; 也就是说，只要添加翻译器和对于的译文JS就可以显示中文界面了。 使用IDEA 双击Shift 快速找到swagger-ui.html 入口文件，完全拷贝内容在项目中创建一模一样的文件swagger-ui.html。注意文件路径必须为src\main\resources\META-INF\resources\swagger-ui.html。 针对中文的本地化，在swagger-ui.html文件中添加以下两行标签： 123&lt;!--国际化操作：选择中文版 --&gt;&lt;script src=&apos;webjars/springfox-swagger-ui/lang/translator.js&apos; type=&apos;text/javascript&apos;&gt;&lt;/script&gt;&lt;script src=&apos;webjars/springfox-swagger-ui/lang/zh-cn.js&apos; type=&apos;text/javascript&apos;&gt;&lt;/script&gt; 完整内容为： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Swagger UI&lt;/title&gt; &lt;link rel=&quot;icon&quot; type=&quot;image/png&quot; href=&quot;webjars/springfox-swagger-ui/images/favicon-32x32.png&quot; sizes=&quot;32x32&quot;/&gt; &lt;link rel=&quot;icon&quot; type=&quot;image/png&quot; href=&quot;webjars/springfox-swagger-ui/images/favicon-16x16.png&quot; sizes=&quot;16x16&quot;/&gt; &lt;link href=&apos;webjars/springfox-swagger-ui/css/typography.css&apos; media=&apos;screen&apos; rel=&apos;stylesheet&apos; type=&apos;text/css&apos;/&gt; &lt;link href=&apos;webjars/springfox-swagger-ui/css/reset.css&apos; media=&apos;screen&apos; rel=&apos;stylesheet&apos; type=&apos;text/css&apos;/&gt; &lt;link href=&apos;webjars/springfox-swagger-ui/css/screen.css&apos; media=&apos;screen&apos; rel=&apos;stylesheet&apos; type=&apos;text/css&apos;/&gt; &lt;link href=&apos;webjars/springfox-swagger-ui/css/reset.css&apos; media=&apos;print&apos; rel=&apos;stylesheet&apos; type=&apos;text/css&apos;/&gt; &lt;link href=&apos;webjars/springfox-swagger-ui/css/print.css&apos; media=&apos;print&apos; rel=&apos;stylesheet&apos; type=&apos;text/css&apos;/&gt; &lt;script src=&apos;webjars/springfox-swagger-ui/lib/object-assign-pollyfill.js&apos; type=&apos;text/javascript&apos;&gt;&lt;/script&gt; &lt;script src=&apos;webjars/springfox-swagger-ui/lib/jquery-1.8.0.min.js&apos; type=&apos;text/javascript&apos;&gt;&lt;/script&gt; &lt;script src=&apos;webjars/springfox-swagger-ui/lib/jquery.slideto.min.js&apos; type=&apos;text/javascript&apos;&gt;&lt;/script&gt; &lt;script src=&apos;webjars/springfox-swagger-ui/lib/jquery.wiggle.min.js&apos; type=&apos;text/javascript&apos;&gt;&lt;/script&gt; &lt;script src=&apos;webjars/springfox-swagger-ui/lib/jquery.ba-bbq.min.js&apos; type=&apos;text/javascript&apos;&gt;&lt;/script&gt; &lt;script src=&apos;webjars/springfox-swagger-ui/lib/handlebars-4.0.5.js&apos; type=&apos;text/javascript&apos;&gt;&lt;/script&gt; &lt;script src=&apos;webjars/springfox-swagger-ui/lib/lodash.min.js&apos; type=&apos;text/javascript&apos;&gt;&lt;/script&gt; &lt;script src=&apos;webjars/springfox-swagger-ui/lib/backbone-min.js&apos; type=&apos;text/javascript&apos;&gt;&lt;/script&gt; &lt;script src=&apos;webjars/springfox-swagger-ui/swagger-ui.min.js&apos; type=&apos;text/javascript&apos;&gt;&lt;/script&gt; &lt;script src=&apos;webjars/springfox-swagger-ui/lib/highlight.9.1.0.pack.js&apos; type=&apos;text/javascript&apos;&gt;&lt;/script&gt; &lt;script src=&apos;webjars/springfox-swagger-ui/lib/highlight.9.1.0.pack_extended.js&apos; type=&apos;text/javascript&apos;&gt;&lt;/script&gt; &lt;script src=&apos;webjars/springfox-swagger-ui/lib/jsoneditor.min.js&apos; type=&apos;text/javascript&apos;&gt;&lt;/script&gt; &lt;script src=&apos;webjars/springfox-swagger-ui/lib/marked.js&apos; type=&apos;text/javascript&apos;&gt;&lt;/script&gt; &lt;script src=&apos;webjars/springfox-swagger-ui/lib/swagger-oauth.js&apos; type=&apos;text/javascript&apos;&gt;&lt;/script&gt; &lt;script src=&apos;webjars/springfox-swagger-ui/springfox.js&apos; type=&apos;text/javascript&apos;&gt;&lt;/script&gt; &lt;!--国际化操作：选择中文版 --&gt; &lt;script src=&apos;webjars/springfox-swagger-ui/lang/translator.js&apos; type=&apos;text/javascript&apos;&gt;&lt;/script&gt; &lt;script src=&apos;webjars/springfox-swagger-ui/lang/zh-cn.js&apos; type=&apos;text/javascript&apos;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body class=&quot;swagger-section&quot;&gt;&lt;div id=&apos;header&apos;&gt; &lt;div class=&quot;swagger-ui-wrap&quot;&gt; &lt;a id=&quot;logo&quot; href=&quot;http://swagger.io&quot;&gt;&lt;img class=&quot;logo__img&quot; alt=&quot;swagger&quot; height=&quot;30&quot; width=&quot;30&quot; src=&quot;webjars/springfox-swagger-ui/images/logo_small.png&quot; /&gt;&lt;span class=&quot;logo__title&quot;&gt;swagger&lt;/span&gt;&lt;/a&gt; &lt;form id=&apos;api_selector&apos;&gt; &lt;div class=&apos;input&apos;&gt; &lt;select id=&quot;select_baseUrl&quot; name=&quot;select_baseUrl&quot;/&gt; &lt;/div&gt; &lt;div class=&apos;input&apos;&gt;&lt;input placeholder=&quot;http://example.com/api&quot; id=&quot;input_baseUrl&quot; name=&quot;baseUrl&quot; type=&quot;text&quot;/&gt;&lt;/div&gt; &lt;div id=&apos;auth_container&apos;&gt;&lt;/div&gt; &lt;div class=&apos;input&apos;&gt;&lt;a id=&quot;explore&quot; class=&quot;header__btn&quot; href=&quot;#&quot; data-sw-translate&gt;Explore&lt;/a&gt;&lt;/div&gt; &lt;/form&gt; &lt;/div&gt;&lt;/div&gt;&lt;div id=&quot;message-bar&quot; class=&quot;swagger-ui-wrap&quot; data-sw-translate&gt;&amp;nbsp;&lt;/div&gt;&lt;div id=&quot;swagger-ui-container&quot; class=&quot;swagger-ui-wrap&quot;&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 再次启动项目，访问 http://localhost:8080/swagger-ui.html，看看显示效果： 可将zh-cn.js文件复制到项目中，进一步定制翻译内容，注意zh-cn.js与swagger-ui.html的相对路径。 12\src\main\resources\META-INF\resources\swagger-ui.html\src\main\resources\META-INF\resources\webjars\springfox-swagger-ui\lang\zh-cn.js zh-cn.js文件全部内容： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556&apos;use strict&apos;;/* jshint quotmark: double */window.SwaggerTranslator.learn(&#123; &quot;Warning: Deprecated&quot;:&quot;警告：已过时&quot;, &quot;Implementation Notes&quot;:&quot;实现备注&quot;, &quot;Response Class&quot;:&quot;响应类&quot;, &quot;Status&quot;:&quot;状态&quot;, &quot;Parameters&quot;:&quot;参数&quot;, &quot;Parameter&quot;:&quot;参数&quot;, &quot;Value&quot;:&quot;值&quot;, &quot;Description&quot;:&quot;描述&quot;, &quot;Parameter Type&quot;:&quot;参数类型&quot;, &quot;Data Type&quot;:&quot;数据类型&quot;, &quot;Response Messages&quot;:&quot;响应消息&quot;, &quot;HTTP Status Code&quot;:&quot;HTTP状态码&quot;, &quot;Reason&quot;:&quot;原因&quot;, &quot;Response Model&quot;:&quot;响应模型&quot;, &quot;Request URL&quot;:&quot;请求URL&quot;, &quot;Response Body&quot;:&quot;响应体&quot;, &quot;Response Code&quot;:&quot;响应码&quot;, &quot;Response Headers&quot;:&quot;响应头&quot;, &quot;Hide Response&quot;:&quot;隐藏响应&quot;, &quot;Headers&quot;:&quot;头&quot;, &quot;Try it out!&quot;:&quot;试一下！&quot;, &quot;Show/Hide&quot;:&quot;显示/隐藏&quot;, &quot;List Operations&quot;:&quot;显示操作&quot;, &quot;Expand Operations&quot;:&quot;展开操作&quot;, &quot;Raw&quot;:&quot;原始&quot;, &quot;can&apos;t parse JSON. Raw result&quot;:&quot;无法解析JSON. 原始结果&quot;, &quot;Example Value&quot;:&quot;示例&quot;, &quot;Click to set as parameter value&quot;:&quot;点击设置参数&quot;, &quot;Model Schema&quot;:&quot;模型架构&quot;, &quot;Model&quot;:&quot;模型&quot;, &quot;apply&quot;:&quot;应用&quot;, &quot;Username&quot;:&quot;用户名&quot;, &quot;Password&quot;:&quot;密码&quot;, &quot;Terms of service&quot;:&quot;服务条款&quot;, &quot;Created by&quot;:&quot;创建者&quot;, &quot;See more at&quot;:&quot;查看更多：&quot;, &quot;Contact the developer&quot;:&quot;联系开发者&quot;, &quot;api version&quot;:&quot;api版本&quot;, &quot;Response Content Type&quot;:&quot;响应Content Type&quot;, &quot;Parameter content type:&quot;:&quot;参数类型:&quot;, &quot;fetching resource&quot;:&quot;正在获取资源&quot;, &quot;fetching resource list&quot;:&quot;正在获取资源列表&quot;, &quot;Explore&quot;:&quot;浏览&quot;, &quot;Show Swagger Petstore Example Apis&quot;:&quot;显示 Swagger Petstore 示例 Apis&quot;, &quot;Can&apos;t read from server. It may not have the appropriate access-control-origin settings.&quot;:&quot;无法从服务器读取。可能没有正确设置access-control-origin。&quot;, &quot;Please specify the protocol for&quot;:&quot;请指定协议：&quot;, &quot;Can&apos;t read swagger JSON from&quot;:&quot;无法读取swagger JSON于&quot;, &quot;Finished Loading Resource Information. Rendering Swagger UI&quot;:&quot;已加载资源信息。正在渲染Swagger UI&quot;, &quot;Unable to read api&quot;:&quot;无法读取api&quot;, &quot;from path&quot;:&quot;从路径&quot;, &quot;server returned&quot;:&quot;服务器返回&quot;&#125;);]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Swagger2</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用Redis管理分布式Session]]></title>
    <url>%2F2018%2F05%2F30%2FProcess-Session-With-Redis%2F</url>
    <content type="text"><![CDATA[使用Redis管理分布式SessionRedis 是一个强大而简单的键值型数据库，之前在公司网站改版的过程中大量使用 Redis 来处理一些特殊的需求，我希望能将自己对 Redis 的使用经验都分享出来，而这里算是第一篇吧。 背景项目是一个有着不小访问量的网站，为了达到分流的作用，网站按照不同的业务（个人、企业、后台、营销、搜索、API等）区分成不同的子域名，而子域名下运行的是不同的实例。 对用户登录这块的逻辑，原来的做法是将登录的明文信息（登录ID、用户名、姓名等）在登录过程中直接写入用户 cookie，当需要进行登录校验的时候，后台直接取出 cookie 中保存的ID进行处理。可以想象，这样的模式只要模拟或者盗取了客户端的 cookie 信息，对于客户来说几乎没有任何安全性的保障。 由于用户的操作可能跨越多个实例，如果采用服务器 session 的机制的话，就需要解决 session 的共享问题，从技术的实现角度来说可能碰到的坑就更多了，于是我们利用了 Redis 来模拟服务器的 session。 实际设计 登录流程见图1 用户从浏览器中将登录信息传到 Web Server 中处理 Web Server 首先跟进行用户信息验证，当验证通过的时候，根据用户的客户端信息（IP、浏览器信息等）进行散列，形成一个 token，这个 token 将会是 Redis 中的 Key，同时将经常需要获取的内容（用户ID、姓名等）组装成 Value，根据需要可以是 json 格式或者 HashTable，然后设定一个 expire time 保存进 Redis 将生成的 token 保存在用户的浏览器 cookie 中 验证流程见图2 用户访问需要进行验证登录的内容时，客户端会将 cookie 传到 Web Server 中 Web Server 从 cookie 中获取到 token 的值，判断 token 是否存在于 Redis 中 若存在则将 Redis 中保存的信息返回到 Web Server 中进行处理，判断此次获取是否合法： 客户端的信息是否和生成 token 时的一致（IP、浏览器信息等） Value 中保存的内容是否和当前操作匹配（用户ID是否和当前处理的ID，或者如果将IP等信息放到内容中也可以将上一条的验证在这里处理） 所有验证通过则将正常的结果返回给用户，有需要的话还可以在这个过程中重置或延长原来 Redis key 的生存时间 这样做解决了什么问题？其实这是一个很简单的思路，将客户登录验证和客户信息获取这两部分内容合并到 Redis 中来进行处理了 不利用服务器的 session，这样当多服务器部署的时候就不需要关心 session 的同步问题了 客户端 cookie 中保存的 token 信息是散列后的内容，不涉及任何业务属性，cookie 一旦被抓取到了单纯从 cookie 信息中也不会丢失任何敏感数据 token 即使被盗用了并被有意进行模仿，如果不是完全按照客户登录时的IP、浏览器信息来进行模拟的话，基本无法获取到客户的信息 常用的信息保存在 Redis 中，由于直接读取了内存，比起持久化的数据库查询，读取速度快了很多，减少了负载同时提升了访问效率 Redis 中的内容设定了生存时间，当有效期内执行操作重置时间这样的机制模拟了 session timeout，这样也能进一步保证用户的数据安全性]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Redis</tag>
        <tag>Session</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[开发笔记]]></title>
    <url>%2F2018%2F05%2F24%2FDevelopmentLog%2F</url>
    <content type="text"><![CDATA[1、jQuery countdown插件倒计时插件 2、Spring Boot引用js、css文件https://blog.csdn.net/CureRrzy/article/details/79350356 12345678910111213141516171819202122232425package com.way.spdemo1.config;import org.springframework.context.annotation.Configuration;import org.springframework.web.servlet.config.annotation.ResourceHandlerRegistry;import org.springframework.web.servlet.config.annotation.WebMvcConfigurerAdapter;@Configurationpublic class WebMvcConfigurer extends WebMvcConfigurerAdapter &#123; private static final String[] CLASSPATH_RESOURCE_LOCATIONS = &#123; &quot;classpath:/META-INF/resources/&quot;, &quot;classpath:/resources/&quot;, &quot;classpath:/static/&quot;, &quot;classpath:/public/&quot; &#125;; @Override public void addResourceHandlers(ResourceHandlerRegistry registry) &#123; // TODO Auto-generated method stub super.addResourceHandlers(registry); if (!registry.hasMappingForPattern(&quot;/webjars/**&quot;)) &#123; registry.addResourceHandler(&quot;/webjars/**&quot;).addResourceLocations(&quot;classpath:/META-INF/resources/webjars/&quot;); &#125; if (!registry.hasMappingForPattern(&quot;/**&quot;)) &#123; registry.addResourceHandler(&quot;/**&quot;).addResourceLocations(CLASSPATH_RESOURCE_LOCATIONS); &#125; &#125;&#125; 3、Protostuff序列化和反序列化https://blog.csdn.net/wangfei8348/article/details/60140301https://www.jianshu.com/p/f017d4518b8f 序列化 12345678910111213@SuppressWarnings(&quot;unchecked&quot;)public static &lt;T&gt; byte[] serialize(T obj) &#123; Class&lt;T&gt; cls = (Class&lt;T&gt;) obj.getClass(); LinkedBuffer buffer = LinkedBuffer.allocate(LinkedBuffer.DEFAULT_BUFFER_SIZE); try &#123; Schema&lt;T&gt; schema = getSchema(cls); return ProtostuffIOUtil.toByteArray(obj, schema, buffer); &#125; catch (Exception e) &#123; throw new IllegalStateException(e.getMessage(), e); &#125; finally &#123; buffer.clear(); &#125;&#125; 反序列化 12345678910public static &lt;T&gt; T deserialize(byte[] data, Class&lt;T&gt; cls) &#123; try &#123; T message = objenesis.newInstance(cls); Schema&lt;T&gt; schema = getSchema(cls); ProtostuffIOUtil.mergeFrom(data, message, schema); return message; &#125; catch (Exception e) &#123; throw new IllegalStateException(e.getMessage(), e); &#125;&#125; 构建schema 123456789101112private static Map&lt;Class&lt;?&gt;, Schema&lt;?&gt;&gt; cachedSchema = new ConcurrentHashMap&lt;&gt;();private static &lt;T&gt; Schema&lt;T&gt; getSchema(Class&lt;T&gt; cls) &#123; Schema&lt;T&gt; schema = (Schema&lt;T&gt;) cachedSchema.get(cls); if (schema == null) &#123; schema = RuntimeSchema.createFrom(cls); if (schema != null) &#123; cachedSchema.put(cls, schema); &#125; &#125; return schema;&#125; 4、CommonLang3中的StringUtils方法解析https://blog.csdn.net/xuxiaoxie/article/details/52095930 1public static boolean isEmpty(CharSequence cs) 常用函数之一，判断字符串是否为””或者null 12345StringUtils.isEmpty(null) = true StringUtils.isEmpty(&quot;&quot;) = true StringUtils.isEmpty(&quot; &quot;) = false StringUtils.isEmpty(&quot;bob&quot;) = false StringUtils.isEmpty(&quot; bob &quot;) = false 1public static boolean isNotEmpty(CharSequence cs) 最常用函数之一，跟上面方法相对 12345StringUtils.isNotEmpty(null) = false StringUtils.isNotEmpty(&quot;&quot;) = false StringUtils.isNotEmpty(&quot; &quot;) = true StringUtils.isNotEmpty(&quot;bob&quot;) = true StringUtils.isNotEmpty(&quot; bob &quot;) = true 1public static boolean isAnyEmpty(CharSequence... css) 任意一个参数为空的话，返回true，如果这些参数都不为空的话返回false。 在写一些判断条件的时候，这个方法还是很实用的。 1234567StringUtils.isAnyEmpty(null) = true StringUtils.isAnyEmpty(null, &quot;foo&quot;) = true StringUtils.isAnyEmpty(&quot;&quot;, &quot;bar&quot;) = true StringUtils.isAnyEmpty(&quot;bob&quot;, &quot;&quot;) = true StringUtils.isAnyEmpty(&quot; bob &quot;, null) = true StringUtils.isAnyEmpty(&quot; &quot;, &quot;bar&quot;) = false StringUtils.isAnyEmpty(&quot;foo&quot;, &quot;bar&quot;) = false 1public static boolean isNoneEmpty(CharSequence... css) 任意一个参数是空，返回false所有参数都不为空，返回true 注意这些方法的用法 1234567StringUtils.isNoneEmpty(null) = false StringUtils.isNoneEmpty(null, &quot;foo&quot;) = false StringUtils.isNoneEmpty(&quot;&quot;, &quot;bar&quot;) = false StringUtils.isNoneEmpty(&quot;bob&quot;, &quot;&quot;) = false StringUtils.isNoneEmpty(&quot; bob &quot;, null) = false StringUtils.isNoneEmpty(&quot; &quot;, &quot;bar&quot;) = true StringUtils.isNoneEmpty(&quot;foo&quot;, &quot;bar&quot;) = true 1public static boolean isBlank(CharSequence cs) 判断字符对象是不是空字符串，注意与isEmpty的区别 12345StringUtils.isBlank(null) = true StringUtils.isBlank(&quot;&quot;) = true StringUtils.isBlank(&quot; &quot;) = true StringUtils.isBlank(&quot;bob&quot;) = false StringUtils.isBlank(&quot; bob &quot;) = false 1public static boolean isNotBlank(CharSequence cs) 12345StringUtils.isNotBlank(null) = false StringUtils.isNotBlank(&quot;&quot;) = false StringUtils.isNotBlank(&quot; &quot;) = false StringUtils.isNotBlank(&quot;bob&quot;) = true StringUtils.isNotBlank(&quot; bob &quot;) = true 原理同上 1public static boolean isAnyBlank(CharSequence... css) 12345678StringUtils.isAnyBlank(null) = true StringUtils.isAnyBlank(null, &quot;foo&quot;) = true StringUtils.isAnyBlank(null, null) = true StringUtils.isAnyBlank(&quot;&quot;, &quot;bar&quot;) = true StringUtils.isAnyBlank(&quot;bob&quot;, &quot;&quot;) = true StringUtils.isAnyBlank(&quot; bob &quot;, null) = true StringUtils.isAnyBlank(&quot; &quot;, &quot;bar&quot;) = true StringUtils.isAnyBlank(&quot;foo&quot;, &quot;bar&quot;) = false 1public static boolean isNoneBlank(CharSequence... css) 12345678StringUtils.isNoneBlank(null) = false StringUtils.isNoneBlank(null, &quot;foo&quot;) = false StringUtils.isNoneBlank(null, null) = false StringUtils.isNoneBlank(&quot;&quot;, &quot;bar&quot;) = false StringUtils.isNoneBlank(&quot;bob&quot;, &quot;&quot;) = false StringUtils.isNoneBlank(&quot; bob &quot;, null) = false StringUtils.isNoneBlank(&quot; &quot;, &quot;bar&quot;) = false StringUtils.isNoneBlank(&quot;foo&quot;, &quot;bar&quot;) = true 1public static String trim(String str) 移除字符串两端的空字符串，制表符char &lt;= 32如：\n \t如果为空的话，返回空 如果为”” 12345StringUtils.trim(null) = null StringUtils.trim(&quot;&quot;) = &quot;&quot; StringUtils.trim(&quot; &quot;) = &quot;&quot; StringUtils.trim(&quot;abc&quot;) = &quot;abc&quot; StringUtils.trim(&quot; abc &quot;) = &quot;abc&quot; 变体有 12public static String trimToNull(String str)public static String trimToEmpty(String str) 不常用，跟trim()方法类似 1234public static String strip(String str)public static String strip(String str, String stripChars) str：被处理的字符串，可为空stripChars： 删除的字符串， 1234567StringUtils.strip(null, *) = null StringUtils.strip(&quot;&quot;, *) = &quot;&quot; StringUtils.strip(&quot;abc&quot;, null) = &quot;abc&quot; StringUtils.strip(&quot; abc&quot;, null) = &quot;abc&quot; StringUtils.strip(&quot;abc &quot;, null) = &quot;abc&quot; StringUtils.strip(&quot; abc &quot;, null) = &quot;abc&quot; StringUtils.strip(&quot; abcyx&quot;, &quot;xyz&quot;) = &quot; abc&quot; 12public static boolean equals(CharSequence cs1, CharSequence cs2) 字符串比对方法，是比较实用的方法之一，两个比较的字符串都能为空，不会报空指针异常。 12345StringUtils.equals(null, null) = true StringUtils.equals(null, &quot;abc&quot;) = false StringUtils.equals(&quot;abc&quot;, null) = false StringUtils.equals(&quot;abc&quot;, &quot;abc&quot;) = true StringUtils.equals(&quot;abc&quot;, &quot;ABC&quot;) = false 12public static boolean equalsIgnoreCase(CharSequence str1, CharSequence str2) 上面方法的变体字符串比较（忽略大小写），在验证码……等字符串比较，真是很实用。 12345StringUtils.equalsIgnoreCase(null, null) = true StringUtils.equalsIgnoreCase(null, &quot;abc&quot;) = false StringUtils.equalsIgnoreCase(&quot;abc&quot;, null) = false StringUtils.equalsIgnoreCase(&quot;abc&quot;, &quot;abc&quot;) = true StringUtils.equalsIgnoreCase(&quot;abc&quot;, &quot;ABC&quot;) = true 12public static int indexOf(CharSequence seq, int searchChar) indexOf这个方法不必多说，这个方法主要处理掉了空字符串的问题，不会报空指针，有一定用处 1234StringUtils.indexOf(null, *) = -1 StringUtils.indexOf(&quot;&quot;, *) = -1 StringUtils.indexOf(&quot;aabaabaa&quot;, &apos;a&apos;) = 0 StringUtils.indexOf(&quot;aabaabaa&quot;, &apos;b&apos;) = 2 123public static int ordinalIndexOf(CharSequence str, CharSequence searchStr, int ordinal) 字符串在另外一个字符串里，出现第Ordinal次的位置 1234567891011StringUtils.ordinalIndexOf(null, *, *) = -1 StringUtils.ordinalIndexOf(*, null, *) = -1 StringUtils.ordinalIndexOf(&quot;&quot;, &quot;&quot;, *) = 0 StringUtils.ordinalIndexOf(&quot;aabaabaa&quot;, &quot;a&quot;, 1) = 0 StringUtils.ordinalIndexOf(&quot;aabaabaa&quot;, &quot;a&quot;, 2) = 1 StringUtils.ordinalIndexOf(&quot;aabaabaa&quot;, &quot;b&quot;, 1) = 2 StringUtils.ordinalIndexOf(&quot;aabaabaa&quot;, &quot;b&quot;, 2) = 5 StringUtils.ordinalIndexOf(&quot;aabaabaa&quot;, &quot;ab&quot;, 1) = 1 StringUtils.ordinalIndexOf(&quot;aabaabaa&quot;, &quot;ab&quot;, 2) = 4 StringUtils.ordinalIndexOf(&quot;aabaabaa&quot;, &quot;&quot;, 1) = 0 StringUtils.ordinalIndexOf(&quot;aabaabaa&quot;, &quot;&quot;, 2) = 0 12public static int lastIndexOf(CharSequence seq, int searchChar) 字符串最后一次出现的位置 1234StringUtils.lastIndexOf(null, *) = -1 StringUtils.lastIndexOf(&quot;&quot;, *) = -1 StringUtils.lastIndexOf(&quot;aabaabaa&quot;, &apos;a&apos;) = 7 StringUtils.lastIndexOf(&quot;aabaabaa&quot;, &apos;b&apos;) = 5 123public static int lastOrdinalIndexOf(CharSequence str, CharSequence searchStr, int ordinal) 字符串searchStr在str里面出现倒数第ordinal出现的位置 1234567891011StringUtils.lastOrdinalIndexOf(null, *, *) = -1 StringUtils.lastOrdinalIndexOf(*, null, *) = -1 StringUtils.lastOrdinalIndexOf(&quot;&quot;, &quot;&quot;, *) = 0 StringUtils.lastOrdinalIndexOf(&quot;aabaabaa&quot;, &quot;a&quot;, 1) = 7 StringUtils.lastOrdinalIndexOf(&quot;aabaabaa&quot;, &quot;a&quot;, 2) = 6 StringUtils.lastOrdinalIndexOf(&quot;aabaabaa&quot;, &quot;b&quot;, 1) = 5 StringUtils.lastOrdinalIndexOf(&quot;aabaabaa&quot;, &quot;b&quot;, 2) = 2 StringUtils.lastOrdinalIndexOf(&quot;aabaabaa&quot;, &quot;ab&quot;, 1) = 4 StringUtils.lastOrdinalIndexOf(&quot;aabaabaa&quot;, &quot;ab&quot;, 2) = 1 StringUtils.lastOrdinalIndexOf(&quot;aabaabaa&quot;, &quot;&quot;, 1) = 8 StringUtils.lastOrdinalIndexOf(&quot;aabaabaa&quot;, &quot;&quot;, 2) = 8 12public static boolean contains(CharSequence seq, int searchChar) 字符串seq是否包含searchChar 1234StringUtils.contains(null, *) = false StringUtils.contains(&quot;&quot;, *) = false StringUtils.contains(&quot;abc&quot;, &apos;a&apos;) = true StringUtils.contains(&quot;abc&quot;, &apos;z&apos;) = false 12public static boolean containsAny(CharSequence cs, char... searchChars) 包含后面数组中的任意对象，返回true 1234567StringUtils.containsAny(null, *) = false StringUtils.containsAny(&quot;&quot;, *) = false StringUtils.containsAny(*, null) = false StringUtils.containsAny(*, []) = false StringUtils.containsAny(&quot;zzabyycdxx&quot;,[&apos;z&apos;,&apos;a&apos;]) = true StringUtils.containsAny(&quot;zzabyycdxx&quot;,[&apos;b&apos;,&apos;y&apos;]) = true StringUtils.containsAny(&quot;aba&quot;, [&apos;z&apos;]) = false 12public static String substring(String str, int start) 字符串截取 1234567StringUtils.substring(null, *) = null StringUtils.substring(&quot;&quot;, *) = &quot;&quot; StringUtils.substring(&quot;abc&quot;, 0) = &quot;abc&quot; StringUtils.substring(&quot;abc&quot;, 2) = &quot;c&quot; StringUtils.substring(&quot;abc&quot;, 4) = &quot;&quot; StringUtils.substring(&quot;abc&quot;, -2) = &quot;bc&quot; StringUtils.substring(&quot;abc&quot;, -4) = &quot;abc&quot; 1234567public static String left(String str, int len)public static String right(String str, int len)public static String mid(String str, int pos, int len) 这三个方法类似都是截取字符串 12public static String[] split(String str, String separatorChars) 字符串分割 123456StringUtils.split(null, *) = null StringUtils.split(&quot;&quot;, *) = [] StringUtils.split(&quot;abc def&quot;, null) = [&quot;abc&quot;, &quot;def&quot;] StringUtils.split(&quot;abc def&quot;, &quot; &quot;) = [&quot;abc&quot;, &quot;def&quot;] StringUtils.split(&quot;abc def&quot;, &quot; &quot;) = [&quot;abc&quot;, &quot;def&quot;] StringUtils.split(&quot;ab:cd:ef&quot;, &quot;:&quot;) = [&quot;ab&quot;, &quot;cd&quot;, &quot;ef&quot;] 1public static &lt;T&gt; String join(T... elements) 字符串连接 12345StringUtils.join(null) = null StringUtils.join([]) = &quot;&quot; StringUtils.join([null]) = &quot;&quot; StringUtils.join([&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]) = &quot;abc&quot; StringUtils.join([null, &quot;&quot;, &quot;a&quot;]) = &quot;a&quot; 12public static String join(Object[] array, char separator) 特定字符串连接数组，很多情况下还是蛮实用，不用自己取拼字符串 123456789101112StringUtils.join(null, *) = null StringUtils.join([], *) = &quot;&quot; StringUtils.join([null], *) = &quot;&quot; StringUtils.join([&quot;a&quot;, &quot;b&quot;, &quot;c&quot;], &apos;;&apos;) = &quot;a;b;c&quot; StringUtils.join([&quot;a&quot;, &quot;b&quot;, &quot;c&quot;], null) = &quot;abc&quot; StringUtils.join([null, &quot;&quot;, &quot;a&quot;], &apos;;&apos;) = &quot;;;a&quot;public static String deleteWhitespace(String str)删除空格 StringUtils.deleteWhitespace(null) = null StringUtils.deleteWhitespace(&quot;&quot;) = &quot;&quot; StringUtils.deleteWhitespace(&quot;abc&quot;) = &quot;abc&quot; StringUtils.deleteWhitespace(&quot; ab c &quot;) = &quot;abc&quot; 12public static String removeStart(String str, String remove) 删除以特定字符串开头的字符串，如果没有的话，就不删除。 1234567StringUtils.removeStart(null, *) = null StringUtils.removeStart(&quot;&quot;, *) = &quot;&quot; StringUtils.removeStart(*, null) = * StringUtils.removeStart(&quot;www.domain.com&quot;, &quot;www.&quot;) = &quot;domain.com&quot; StringUtils.removeStart(&quot;domain.com&quot;, &quot;www.&quot;) = &quot;domain.com&quot; StringUtils.removeStart(&quot;www.domain.com&quot;, &quot;domain&quot;) = &quot;www.domain.com&quot; StringUtils.removeStart(&quot;abc&quot;, &quot;&quot;) = &quot;abc&quot; 123public static String rightPad(String str, int size, char padChar) 生成订单号，的时候还是很实用的。右边自动补齐。 123456StringUtils.rightPad(null, *, *) = null StringUtils.rightPad(&quot;&quot;, 3, &apos;z&apos;) = &quot;zzz&quot; StringUtils.rightPad(&quot;bat&quot;, 3, &apos;z&apos;) = &quot;bat&quot; StringUtils.rightPad(&quot;bat&quot;, 5, &apos;z&apos;) = &quot;batzz&quot; StringUtils.rightPad(&quot;bat&quot;, 1, &apos;z&apos;) = &quot;bat&quot; StringUtils.rightPad(&quot;bat&quot;, -1, &apos;z&apos;) = &quot;bat&quot; 123public static String leftPad(String str, int size, char padChar) 左边自动补齐 123456StringUtils.leftPad(null, *, *) = null StringUtils.leftPad(&quot;&quot;, 3, &apos;z&apos;) = &quot;zzz&quot; StringUtils.leftPad(&quot;bat&quot;, 3, &apos;z&apos;) = &quot;bat&quot; StringUtils.leftPad(&quot;bat&quot;, 5, &apos;z&apos;) = &quot;zzbat&quot; StringUtils.leftPad(&quot;bat&quot;, 1, &apos;z&apos;) = &quot;bat&quot; StringUtils.leftPad(&quot;bat&quot;, -1, &apos;z&apos;) = &quot;bat&quot; 12public static String center(String str, int size) 将字符在某特定长度下，句子 123456StringUtils.center(null, *) = null StringUtils.center(&quot;&quot;, 4) = &quot; &quot; StringUtils.center(&quot;ab&quot;, -1) = &quot;ab&quot; StringUtils.center(&quot;ab&quot;, 4) = &quot; ab &quot; StringUtils.center(&quot;abcd&quot;, 2) = &quot;abcd&quot; StringUtils.center(&quot;a&quot;, 4) = &quot; a &quot; 1public static String capitalize(String str) 首字母大写 12345StringUtils.capitalize(null) = null StringUtils.capitalize(&quot;&quot;) = &quot;&quot; StringUtils.capitalize(&quot;cat&quot;) = &quot;Cat&quot; StringUtils.capitalize(&quot;cAt&quot;) = &quot;CAt&quot;public static String swapCase(String str) 反向大小写 123StringUtils.swapCase(null) = null StringUtils.swapCase(&quot;&quot;) = &quot;&quot; StringUtils.swapCase(&quot;The dog has a BONE&quot;) = &quot;tHE DOG HAS A bone&quot; 1public static boolean isAlpha(CharSequence cs) 判断字符串是否由字母组成 123456StringUtils.isAlpha(null) = false StringUtils.isAlpha(&quot;&quot;) = false StringUtils.isAlpha(&quot; &quot;) = false StringUtils.isAlpha(&quot;abc&quot;) = true StringUtils.isAlpha(&quot;ab2c&quot;) = false StringUtils.isAlpha(&quot;ab-c&quot;) = false 12public static String defaultString(String str, String defaultStr) 默认字符串，相当于三目运算，前面弱为空，则返回后面一个参数 123StringUtils.defaultString(null, &quot;NULL&quot;) = &quot;NULL&quot; StringUtils.defaultString(&quot;&quot;, &quot;NULL&quot;) = &quot;&quot; StringUtils.defaultString(&quot;bat&quot;, &quot;NULL&quot;) = &quot;bat&quot; 1public static String reverse(String str) 字符串翻转 123StringUtils.reverse(null) = null StringUtils.reverse(&quot;&quot;) = &quot;&quot; StringUtils.reverse(&quot;bat&quot;) = &quot;tab&quot; 12public static String abbreviate(String str, int maxWidth) 缩略字符串，省略号要占三位。maxWith小于3位会报错。 1234567StringUtils.abbreviate(null, *) = null StringUtils.abbreviate(&quot;&quot;, 4) = &quot;&quot; StringUtils.abbreviate(&quot;abcdefg&quot;, 6) = &quot;abc...&quot; StringUtils.abbreviate(&quot;abcdefg&quot;, 7) = &quot;abcdefg&quot; StringUtils.abbreviate(&quot;abcdefg&quot;, 8) = &quot;abcdefg&quot; StringUtils.abbreviate(&quot;abcdefg&quot;, 4) = &quot;a...&quot; StringUtils.abbreviate(&quot;abcdefg&quot;, 3) = IllegalArgumentException 123public static String abbreviate(String str, int offset, int maxWidth) 缩略字符串的一些高级用法 12345678910111213StringUtils.abbreviate(null, *, *) = null StringUtils.abbreviate(&quot;&quot;, 0, 4) = &quot;&quot; StringUtils.abbreviate(&quot;abcdefghijklmno&quot;, -1, 10) = &quot;abcdefg...&quot; StringUtils.abbreviate(&quot;abcdefghijklmno&quot;, 0, 10) = &quot;abcdefg...&quot; StringUtils.abbreviate(&quot;abcdefghijklmno&quot;, 1, 10) = &quot;abcdefg...&quot; StringUtils.abbreviate(&quot;abcdefghijklmno&quot;, 4, 10) = &quot;abcdefg...&quot; StringUtils.abbreviate(&quot;abcdefghijklmno&quot;, 5, 10) = &quot;...fghi...&quot; StringUtils.abbreviate(&quot;abcdefghijklmno&quot;, 6, 10) = &quot;...ghij...&quot; StringUtils.abbreviate(&quot;abcdefghijklmno&quot;, 8, 10) = &quot;...ijklmno&quot; StringUtils.abbreviate(&quot;abcdefghijklmno&quot;, 10, 10) = &quot;...ijklmno&quot; StringUtils.abbreviate(&quot;abcdefghijklmno&quot;, 12, 10) = &quot;...ijklmno&quot; StringUtils.abbreviate(&quot;abcdefghij&quot;, 0, 3) = IllegalArgumentException StringUtils.abbreviate(&quot;abcdefghij&quot;, 5, 6) = IllegalArgumentException 12public static String wrap(String str, char wrapWith) 包装，用后面的字符串对前面的字符串进行包装 123456StringUtils.wrap(null, *) = null StringUtils.wrap(&quot;&quot;, *) = &quot;&quot; StringUtils.wrap(&quot;ab&quot;, &apos;\0&apos;) = &quot;ab&quot; StringUtils.wrap(&quot;ab&quot;, &apos;x&apos;) = &quot;xabx&quot; StringUtils.wrap(&quot;ab&quot;, &apos;\&apos;&apos;) = &quot;&apos;ab&apos;&quot; StringUtils.wrap(&quot;\&quot;ab\&quot;&quot;, &apos;\&quot;&apos;) = &quot;\&quot;\&quot;ab\&quot;\&quot;&quot; 5、Redis客户端Jedis使用Jedis操作Redis 123456&lt;!-- https://mvnrepository.com/artifact/redis.clients/jedis --&gt; &lt;dependency&gt; &lt;groupId&gt;redis.clients&lt;/groupId&gt; &lt;artifactId&gt;jedis&lt;/artifactId&gt; &lt;version&gt;2.7.3&lt;/version&gt; &lt;/dependency&gt; 测试案例 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137package com.test;import java.util.HashMap;import java.util.Iterator;import java.util.List;import java.util.Map;import org.junit.Before;import org.junit.Test;import redis.clients.jedis.Jedis;public class TestRedis &#123; private Jedis jedis; @Before public void setup() &#123; //连接redis服务器，192.168.0.100:6379 jedis = new Jedis(&quot;192.168.0.100&quot;, 6379); //权限认证 jedis.auth(&quot;admin&quot;); &#125; /** * redis存储字符串 */ @Test public void testString() &#123; //-----添加数据---------- jedis.set(&quot;name&quot;,&quot;xinxin&quot;);//向key--&gt;name中放入了value--&gt;xinxin System.out.println(jedis.get(&quot;name&quot;));//执行结果：xinxin jedis.append(&quot;name&quot;, &quot; is my lover&quot;); //拼接 System.out.println(jedis.get(&quot;name&quot;)); jedis.del(&quot;name&quot;); //删除某个键 System.out.println(jedis.get(&quot;name&quot;)); //设置多个键值对 jedis.mset(&quot;name&quot;,&quot;liuling&quot;,&quot;age&quot;,&quot;23&quot;,&quot;qq&quot;,&quot;476777XXX&quot;); jedis.incr(&quot;age&quot;); //进行加1操作 System.out.println(jedis.get(&quot;name&quot;) + &quot;-&quot; + jedis.get(&quot;age&quot;) + &quot;-&quot; + jedis.get(&quot;qq&quot;)); &#125; /** * redis操作Map */ @Test public void testMap() &#123; //-----添加数据---------- Map&lt;String, String&gt; map = new HashMap&lt;String, String&gt;(); map.put(&quot;name&quot;, &quot;xinxin&quot;); map.put(&quot;age&quot;, &quot;22&quot;); map.put(&quot;qq&quot;, &quot;123456&quot;); jedis.hmset(&quot;user&quot;,map); //取出user中的name，执行结果:[minxr]--&gt;注意结果是一个泛型的List //第一个参数是存入redis中map对象的key，后面跟的是放入map中的对象的key，后面的key可以跟多个，是可变参数 List&lt;String&gt; rsmap = jedis.hmget(&quot;user&quot;, &quot;name&quot;, &quot;age&quot;, &quot;qq&quot;); System.out.println(rsmap); //删除map中的某个键值 jedis.hdel(&quot;user&quot;,&quot;age&quot;); System.out.println(jedis.hmget(&quot;user&quot;, &quot;age&quot;)); //因为删除了，所以返回的是null System.out.println(jedis.hlen(&quot;user&quot;)); //返回key为user的键中存放的值的个数2 System.out.println(jedis.exists(&quot;user&quot;));//是否存在key为user的记录 返回true System.out.println(jedis.hkeys(&quot;user&quot;));//返回map对象中的所有key System.out.println(jedis.hvals(&quot;user&quot;));//返回map对象中的所有value Iterator&lt;String&gt; iter=jedis.hkeys(&quot;user&quot;).iterator(); while (iter.hasNext())&#123; String key = iter.next(); System.out.println(key+&quot;:&quot;+jedis.hmget(&quot;user&quot;,key)); &#125; &#125; /** * jedis操作List */ @Test public void testList()&#123; //开始前，先移除所有的内容 jedis.del(&quot;java framework&quot;); System.out.println(jedis.lrange(&quot;java framework&quot;,0,-1)); //先向key java framework中存放三条数据 jedis.lpush(&quot;java framework&quot;,&quot;spring&quot;); jedis.lpush(&quot;java framework&quot;,&quot;struts&quot;); jedis.lpush(&quot;java framework&quot;,&quot;hibernate&quot;); //再取出所有数据jedis.lrange是按范围取出， // 第一个是key，第二个是起始位置，第三个是结束位置，jedis.llen获取长度 -1表示取得所有 System.out.println(jedis.lrange(&quot;java framework&quot;,0,-1)); jedis.del(&quot;java framework&quot;); jedis.rpush(&quot;java framework&quot;,&quot;spring&quot;); jedis.rpush(&quot;java framework&quot;,&quot;struts&quot;); jedis.rpush(&quot;java framework&quot;,&quot;hibernate&quot;); System.out.println(jedis.lrange(&quot;java framework&quot;,0,-1)); &#125; /** * jedis操作Set */ @Test public void testSet()&#123; //添加 jedis.sadd(&quot;user&quot;,&quot;liuling&quot;); jedis.sadd(&quot;user&quot;,&quot;xinxin&quot;); jedis.sadd(&quot;user&quot;,&quot;ling&quot;); jedis.sadd(&quot;user&quot;,&quot;zhangxinxin&quot;); jedis.sadd(&quot;user&quot;,&quot;who&quot;); //移除noname jedis.srem(&quot;user&quot;,&quot;who&quot;); System.out.println(jedis.smembers(&quot;user&quot;));//获取所有加入的value System.out.println(jedis.sismember(&quot;user&quot;, &quot;who&quot;));//判断 who 是否是user集合的元素 System.out.println(jedis.srandmember(&quot;user&quot;)); System.out.println(jedis.scard(&quot;user&quot;));//返回集合的元素个数 &#125; @Test public void test() throws InterruptedException &#123; //jedis 排序 //注意，此处的rpush和lpush是List的操作。是一个双向链表（但从表现来看的） jedis.del(&quot;a&quot;);//先清除数据，再加入数据进行测试 jedis.rpush(&quot;a&quot;, &quot;1&quot;); jedis.lpush(&quot;a&quot;,&quot;6&quot;); jedis.lpush(&quot;a&quot;,&quot;3&quot;); jedis.lpush(&quot;a&quot;,&quot;9&quot;); System.out.println(jedis.lrange(&quot;a&quot;,0,-1));// [9, 3, 6, 1] System.out.println(jedis.sort(&quot;a&quot;)); //[1, 3, 6, 9] //输入排序后结果 System.out.println(jedis.lrange(&quot;a&quot;,0,-1)); &#125; @Test public void testRedisPool() &#123; RedisUtil.getJedis().set(&quot;newname&quot;, &quot;中文测试&quot;); System.out.println(RedisUtil.getJedis().get(&quot;newname&quot;)); &#125;&#125; Redis连接池 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778package com.test;import redis.clients.jedis.Jedis;import redis.clients.jedis.JedisPool;import redis.clients.jedis.JedisPoolConfig;public final class RedisUtil &#123; //Redis服务器IP private static String ADDR = &quot;192.168.0.100&quot;; //Redis的端口号 private static int PORT = 6379; //访问密码 private static String AUTH = &quot;admin&quot;; //可用连接实例的最大数目，默认值为8； //如果赋值为-1，则表示不限制；如果pool已经分配了maxActive个jedis实例，则此时pool的状态为exhausted(耗尽)。 private static int MAX_ACTIVE = 1024; //控制一个pool最多有多少个状态为idle(空闲的)的jedis实例，默认值也是8。 private static int MAX_IDLE = 200; //等待可用连接的最大时间，单位毫秒，默认值为-1，表示永不超时。如果超过等待时间，则直接抛出JedisConnectionException； private static int MAX_WAIT = 10000; private static int TIMEOUT = 10000; //在borrow一个jedis实例时，是否提前进行validate操作；如果为true，则得到的jedis实例均是可用的； private static boolean TEST_ON_BORROW = true; private static JedisPool jedisPool = null; /** * 初始化Redis连接池 */ static &#123; try &#123; JedisPoolConfig config = new JedisPoolConfig(); config.setMaxActive(MAX_ACTIVE); config.setMaxIdle(MAX_IDLE); config.setMaxWait(MAX_WAIT); config.setTestOnBorrow(TEST_ON_BORROW); jedisPool = new JedisPool(config, ADDR, PORT, TIMEOUT, AUTH); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; /** * 获取Jedis实例 * @return */ public synchronized static Jedis getJedis() &#123; try &#123; if (jedisPool != null) &#123; Jedis resource = jedisPool.getResource(); return resource; &#125; else &#123; return null; &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); return null; &#125; &#125; /** * 释放jedis资源 * @param jedis */ public static void returnResource(final Jedis jedis) &#123; if (jedis != null) &#123; jedisPool.returnResource(jedis); &#125; &#125;&#125; 6、IE8下js不执行，在开发者模式下 点击“启动调试”按钮后才执行，怎么解决？删除测试代码。ie8非开发模式下无法用console对象。 7、腾讯云CDN使用https://blog.csdn.net/Lunaqi/article/details/78987936]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F03%2F31%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
  <entry>
    <title><![CDATA[已加入Electron中文简体翻译计划]]></title>
    <url>%2F2017%2F12%2F12%2F2017-12-12-Electron-Translation%2F</url>
    <content type="text"><![CDATA[Waylan Punch已加入Electron中文简体翻译计划。]]></content>
      <tags>
        <tag>Electron</tag>
        <tag>Translation</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MathJax在网页中的使用]]></title>
    <url>%2F2017%2F12%2F11%2F2017-12-11-MathJax-Usage%2F</url>
    <content type="text"><![CDATA[MathJax允许你在网页中使用LaTeX，MathML或AsciiMath注解来包含数学公式，这些数学公式将使用JavaScript处理HTML，SVG或MathML方程式来产生，以显示在任何浏览器中。 有两种方法可以访问MathJax：最简单的方法是使用分布式网络服务（如cdnjs.com）提供的MathJax副本，但是也可以在本地机器上下载并安装MathJax的副本，或者在你的硬盘上使用（不需要网络访问）。 本文给出了在您的Web站点上运行MathJax的最快和最简单的方法，但是您可能需要去官网查阅更详细得信息以进行自定义页面的设置。 #使用CDN 使用MathJax最简单的方法是直接接入内容分发网络（CDN）提供的公共链接。有许多免费的CDN提供商提供MathJax的副本。 一些提供“滚动版本”，即在发布时更新到最新可用版本的链接： cdnjs.com（推荐）(https://cdnjs.com/) jsdelivr.com 滚动 unpkg.com 滚动 rawgit.com(https://rawgit.com/) gitcdn.xyz(http://gitcdn.xyz/) raw.githack.com(http://docs.mathjax.org/en/latest/raw.githack.com) 如何接入？ 123&lt;script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-MML-AM_CHTML"&gt;&lt;/script&gt; 打开html网页文件，将上面的代码复制到到&lt;head&gt;块中。 （如果需要的话，它也可以进入&lt;body&gt;，但&lt;head&gt;是首选）。这将从分布式服务器加载最新版本的MathJax，并将其配置为使用TeX，MathML和AsciiMath注解来识别数学 ，并要求它使用HTML与CSS生成其输出来显示数学。 TeX-MML-AM_CHTML配置是最一般的（也是最大的）组合配置文件之一，也有其他组合配置文件可用。 还可以提供额外的配置参数来根据需要定制其中一种组合配置，或使用MathJax的开发工具来生成您自己的组合配置文件。 有关配置过程的更多细节可以在加载和配置MathJax中找到。 #TeX和LaTeX输入 为了显示数学公式，默认的数学分隔符是$$ ... $$和\ [... \]，对于内连数学公式，默认的数学分隔符是\（... \）。 特别要注意$ ... $内连分隔符不是默认的。 因为美元符号经常出现在非数学公式的情况下，可能会导致误读。 例如一句话，“…第一个为$ 2.50，而另外一个为$ 2.00 …”将导致“…第一个为 2.50”被视为数学公式，因为这句话出现在美元符号之间。 出于这个原因，如果你想使用单数美元符号编写内连公式，就必须在你的配置中明确地启用： 12345678&lt;script type="text/x-mathjax-config"&gt;MathJax.Hub.Config(&#123; tex2jax: &#123;inlineMath: [['$','$'], ['\\(','\\)']]&#125;&#125;);&lt;/script&gt;&lt;script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-MML-AM_CHTML"&gt;&lt;/script&gt; 参阅config / default.js文件或tex2jax配置选项页面，可以为tex2jax预处理器指定其他配置参数，tex2jax是MathJax的组件，用于标识页面内的TeX符号。 有关MathJax对TeX的支持的更多信息，请参见TeX和LaTeX页面，特别是启用单一美元符号分隔符时，如何处理文本中的单个美元符号。 下面是一个包含TeX数学公式的完整示例页面（也可以在test / sample-tex.html文件中找到）： 12345678910111213141516&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;title&gt;MathJax TeX Test Page&lt;/title&gt;&lt;script type="text/x-mathjax-config"&gt; MathJax.Hub.Config(&#123;tex2jax: &#123;inlineMath: [['$','$'], ['\\(','\\)']]&#125;&#125;);&lt;/script&gt;&lt;script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-MML-AM_CHTML"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;如果 $a \ne 0$, 则 \(ax^2 + bx + c = 0\) 方程会有两个解，分别为$$x = &#123;-b \pm \sqrt&#123;b^2-4ac&#125; \over 2a&#125;.$$&lt;/body&gt;&lt;/html&gt; 由于TeX符号是页面文本的一部分，因此在输入公式时，有一些注意事项。 尤其是需要小心&lt;的使用，因为它是浏览器用来指示HTML标签的开始。 在&lt;符号的两侧放置一个空格就行了，但请参阅TeX和LaTeX的支持细节。 TeX输入处理器有多个扩展名，由组合的配置文件加载，这些文件的文件名中包含TeX（例如TeX-AMS_CHTML）。 包括： TeX / AMSmath.js，定义了AMS数学环境和宏， TeX / AMSsymbols.js，它定义msam10和msbm10字体中的符号的宏， TeX / noErrors.js，当处理TeX出现问题时，它显示原始的TeX代码而不是错误信息， TeX / noUndefined.js，防止未定义的宏产生错误信息，而以红色显示宏名。 其他扩展可能会在需要时自动加载。其他可用的其他TeX扩展的详细信息，请参阅TeX和LaTeX支持。 #MathML输入 以MathML注解编写的数学公式，可以使用标准标记来标记数学，其中&lt;math display =&quot;block&quot;&gt;表示显示的数学公式，&lt;math display =&quot;inline&quot;&gt;或&lt;math&gt;表示内联数学公式。 在旧的浏览器上，也可以在HTML文件中使用，而不仅仅是XHTML文件（MathJax都能起作用），而且网页不需指定任何特殊的MIME类型。但是请注意，在HTML（不是XHTML）中，不应该在标签包含一个名称空间前缀。例如，除非在XHTML文件，已经通过添加xmlns:m =&quot;http://www.w3.org/1998/Math/ MathML&quot;属性到文件的标签，将m命名空间和MathML DTD绑定在一起，否则不能给标签添加命名空间前缀。最好在文档的所有标签中包含xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;属性（推荐使用像m：以上这样的名称空间前缀，因为这些在HTML5中已被弃用），以便在最广泛的使MathML工作。这是一个包含MathML数学公式的完整示例页面（也可在test / sample-mml.html文件中获得）： 123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;title&gt;MathJax MathML Test Page&lt;/title&gt;&lt;script type="text/javascript" async src="https://example.com/MathJax.js?config=MML_CHTML"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;如果&lt;math xmlns="http://www.w3.org/1998/Math/MathML"&gt; &lt;mi&gt;a&lt;/mi&gt;&lt;mo&gt;&amp;#x2260;&lt;/mo&gt;&lt;mn&gt;0&lt;/mn&gt;&lt;/math&gt;,则&lt;math xmlns="http://www.w3.org/1998/Math/MathML"&gt; &lt;mi&gt;a&lt;/mi&gt;&lt;msup&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;/msup&gt; &lt;mo&gt;+&lt;/mo&gt; &lt;mi&gt;b&lt;/mi&gt;&lt;mi&gt;x&lt;/mi&gt; &lt;mo&gt;+&lt;/mo&gt; &lt;mi&gt;c&lt;/mi&gt; &lt;mo&gt;=&lt;/mo&gt; &lt;mn&gt;0&lt;/mn&gt;&lt;/math&gt;方程会有两个解，分别为&lt;math xmlns="http://www.w3.org/1998/Math/MathML" display="block"&gt; &lt;mi&gt;x&lt;/mi&gt; &lt;mo&gt;=&lt;/mo&gt; &lt;mrow&gt; &lt;mfrac&gt; &lt;mrow&gt; &lt;mo&gt;&amp;#x2212;&lt;/mo&gt; &lt;mi&gt;b&lt;/mi&gt; &lt;mo&gt;&amp;#x00B1;&lt;/mo&gt; &lt;msqrt&gt; &lt;msup&gt;&lt;mi&gt;b&lt;/mi&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;/msup&gt; &lt;mo&gt;&amp;#x2212;&lt;/mo&gt; &lt;mn&gt;4&lt;/mn&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mi&gt;c&lt;/mi&gt; &lt;/msqrt&gt; &lt;/mrow&gt; &lt;mrow&gt; &lt;mn&gt;2&lt;/mn&gt;&lt;mi&gt;a&lt;/mi&gt; &lt;/mrow&gt; &lt;/mfrac&gt; &lt;/mrow&gt; &lt;mtext&gt;.&lt;/mtext&gt;&lt;/math&gt;&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 在HTML页面（不是XHTML页面）中输入MathML注释时，不应使用自闭标记，而应对所有数学元素使用明确的打开和关闭标记。 例如应该使用&lt;mspace width =“5pt”&gt; &lt;/ mspace&gt;而不是&lt;mspace width=&quot;5pt&quot; /&gt; 如果使用自闭形式，一些浏览器将不会正确构建数学公式，MathJax将收到损坏的数学结构。有关MathJax的MathML支持的更多信息，请参见MathML页面。 #AsciiMath输入 MathJax v2.0通过合并ASCIIMathML引入了一种新的输入格式：AsciiMath注解。 默认情况下，用反单引号（即’…’）来标记数学表达式。下面是一个包含AsciiMath表示法的完整示例页面（也可以在test / sample-asciimath.html文件中找到）： 12345678910111213141516&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;title&gt;MathJax AsciiMath Test Page&lt;/title&gt;&lt;script type="text/javascript" async src="https://example.com/MathJax.js?config=AM_CHTML"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;如果 `a != 0`, 则 `ax^2 + bx + c = 0` 方程式会有两个解，分别为&lt;/p&gt;&lt;p style="text-align:center"&gt; `x = (-b +- sqrt(b^2-4ac))/(2a) .`&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 在页面中识别asciimath符号的MathJax的组件称为asciimath2jax扩展，它只有一些配置选项; 有关更多详细信息，请参阅config / default.js文件或asciimath2jax配置选项页面。有关MathJax的AsciiMath支持的更多信息，请参阅AsciiMath支持页面。]]></content>
      <tags>
        <tag>MathJax</tag>
        <tag>TeX</tag>
        <tag>LaTeX</tag>
        <tag>MathML</tag>
        <tag>AsciiMath</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于LeanCloud Restful API的Retrofit编程]]></title>
    <url>%2F2017%2F03%2F12%2F2017-03-12-leancloud-restfulapi-retrofit%2F</url>
    <content type="text"><![CDATA[基于LeanCloud Restful API的Retrofit编程 BaaS提供商LeanCloud提供了Restful API，没有提供Retrofit使用教程。 注册用户 注册API设计： 123456curl -X POST \ -H &quot;X-LC-Id: y0crQpaNCKUq9WFaSMLByoKo-gzGzoHsz&quot; \ -H &quot;X-LC-Key: ihdOweBmtk9yrDbuPEbJfyBb&quot; \ -H &quot;Content-Type: application/json&quot; \ -d &apos;&#123;&quot;username&quot;:&quot;hjiang&quot;,&quot;password&quot;:&quot;f32@ds*@&amp;dsa&quot;,&quot;phone&quot;:&quot;18612340000&quot;&#125;&apos; \ https://api.leancloud.cn/1.1/users 登录API设计： 123456curl -X POST \-H &quot;Content-Type: application/json&quot; \-H &quot;X-LC-Id: y0crQpaNCKUq9WFaSMLByoKo-gzGzoHsz&quot; \-H &quot;X-LC-Key: ihdOweBmtk9yrDbuPEbJfyBb&quot; \-d &apos;&#123;&quot;username&quot;:&quot;hjiang&quot;,&quot;password&quot;:&quot;f32@ds*@&amp;dsa&quot;&#125;&apos; \https://api.leancloud.cn/1.1/login Retrofit接口： 1234567891011121314public interface LeanCloudRetrofitService &#123; @POST(&quot;users&quot;) Call&lt;Object&gt; signUp(@Header(&quot;X-LC-Id&quot;) String appId, @Header(&quot;X-LC-Key&quot;) String appKey, @Header(&quot;Content-Type&quot;) String contentType, @Body RequestBody userinfo); @POST(&quot;login&quot;) Call&lt;Object&gt; signIn(@Header(&quot;X-LC-Id&quot;) String appId, @Header(&quot;X-LC-Key&quot;) String appKey, @Header(&quot;Content-Type&quot;) String contentType, @Body RequestBody userinfo);&#125; 注册代码： 12345678910111213141516171819202122232425String username = &quot;&quot;;String password = &quot;&quot;;Retrofit retrofit = new Retrofit.Builder() .addConverterFactory(GsonConverterFactory.create()) .baseUrl(baseurl) .build();LeanCloudRetrofitService service = retrofit.create(LeanCloudRetrofitService.class);String json = &quot;&#123;\&quot;username\&quot;:\&quot;&quot; + username + &quot;\&quot;,\&quot;password\&quot;:\&quot;&quot; + password + &quot;\&quot;&#125;&quot;;RequestBody body = RequestBody.create(MediaType.parse(contenttype), json);Call&lt;Object&gt; call = service.signUp(appid, appkey, contenttype, body); call.enqueue(new Callback&lt;Object&gt;() &#123; @Override public void onResponse(Call&lt;Object&gt; call, Response&lt;Object&gt; response) &#123; tvResult.setText(response.body() + &quot;&quot;); &#125; @Override public void onFailure(Call&lt;Object&gt; call, Throwable t) &#123; tvResult.setText(t.getMessage() + &quot;&quot;); &#125;&#125;); 登录代码： 123456789101112131415161718192021222324String username = &quot;&quot;;String password = &quot;&quot;;Retrofit retrofit = new Retrofit.Builder() .addConverterFactory(GsonConverterFactory.create()) .baseUrl(baseurl) .build();LeanCloudRetrofitService service = retrofit.create(LeanCloudRetrofitService.class);String json = &quot;&#123;\&quot;username\&quot;:\&quot;&quot; + username + &quot;\&quot;,\&quot;password\&quot;:\&quot;&quot; + password + &quot;\&quot;&#125;&quot;;RequestBody body = RequestBody.create(MediaType.parse(contenttype), json);Call&lt;Object&gt; call = service.signIn(appid, appkey, contenttype, body);call.enqueue(new Callback&lt;Object&gt;() &#123; @Override public void onResponse(Call&lt;Object&gt; call, Response&lt;Object&gt; response) &#123; tvResult.setText(response.body() + &quot;&quot;); &#125; @Override public void onFailure(Call&lt;Object&gt; call, Throwable t) &#123; tvResult.setText(t.getMessage() + &quot;&quot;); &#125;&#125;);]]></content>
      <tags>
        <tag>Retrofit</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ButterKnife vs RoboGuice]]></title>
    <url>%2F2017%2F03%2F12%2F2017-03-21-butterknife-vs-roboguice%2F</url>
    <content type="text"><![CDATA[ButterKnife vs RoboGuice 当涉及到Android上的依赖注入（DI）类库的时候，存在不少的选择，我在公司项目中用了RoboGuice，现在非常后悔。最开始认为RoboGuice节约了大量的时间。较少的代码意味着较少的错误，较少的样板代码意味着可以把更多的时间放到应用的核心逻辑上。 比较 RoboGuice ButterKnife 所需的最少jar包 3 (roboguice-2.0.jar, javax.inject-1.jar and guice-3.0-no_aop.jar) 1 (butterknife-4.0.1.jar) 是否需要替代Activity 需要，RoboActivity替代Activity 不需要 与ActionBarSherlock的兼容性 兼容，需添加roboguice-sherlock-1.5.jar包到应用并且用RoboSherlockActivity替换SherlockActivity 兼容，不需要额外jars包 单击监听器的注入 不支持 支持 性能 运行时采取反射机制有性能影响 没有采取反射而使用了预编译技术，因为基于反射的DI非常占用资源和耗时 POJO注入 支持 不支持 Fragments注入 支持 支持 适配器注入 不支持 支持 代码协议 Apache License 2.0 Apache License 2.0 链接 Rroboguice Link Butterknife Link]]></content>
      <tags>
        <tag>ButterKnife</tag>
        <tag>RoboGuice</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Fragment操作宿主Activity]]></title>
    <url>%2F2016%2F12%2F17%2F2016-12-17-Fragment-to-Activity%2F</url>
    <content type="text"><![CDATA[宿主 Activity 实现 Fragment 定义的对外接口 IOneFragmentClickListener，便可以实现 Fragment 调用 Activity 的功能。 public class OneFragment extends Fragment implements View.OnClickListener{ private IOneFragmentClickListener clickListener; public interface IOneFragmentClickListener{ void onOneFragmentClick(); } public void setClickListener(IOneFragmentClickListener clickListener) { this.clickListener = clickListener; } @Nullable @Override public View onCreateView(LayoutInflater inflater, @Nullable ViewGroup container, @Nullable Bundle savedInstanceState) { View contentView = inflater.inflate(R.layout.fragment_one, null); contentView.findViewById(R.id.edt_one).setOnClickListener(this); return contentView; } @Override public void onClick(View v) { clickListener.onOneFragmentClick(); } } 需要在宿主 Activity 中额外添加一步监听设置。 public class MainActivity extends Activty implements IOneFragmentClickListener { @Overide public void onOneFragmentClick(){ //TODO } }]]></content>
      <tags>
        <tag>Activity</tag>
        <tag>Fragment</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何反编译apk文件]]></title>
    <url>%2F2016%2F12%2F15%2F2016-12-15-how-to-decompile-apk-file%2F</url>
    <content type="text"><![CDATA[准备三个工具：Apktool、dex2jar、jd-gui Apktool 下载：downloads 安装：install **Windows:** 1.Download Windows wrapper script (Right click, Save Link As apktool.bat) 2.Download apktool-2 (find newest here) 3.Rename downloaded jar to apktool.jar 4.Move both files (apktool.jar &amp; apktool.bat) to your Windows directory (Usually C://Windows) 5.If you do not have access to C://Windows, you may place the two files anywhere then add that directory to your Environment Variables System PATH variable. 6.Try running apktool via command prompt 使用：documentation 示例： C:\Users\Decompile&gt;apktool d FARead.apk I: Using Apktool 2.2.1 on FARead.apk I: Loading resource table... I: Decoding AndroidManifest.xml with resources... I: Loading resource table from file: C:\Users\pc\AppData\Local\apktool\framework\1.apk I: Regular manifest package... I: Decoding file-resources... I: Decoding values */* XMLs... I: Baksmaling classes.dex... I: Copying assets and libs... I: Copying unknown files... I: Copying original files... dex2jar 下载：sourceforge bitbucket 安装：install **Windows:** 1.解压apk安装包，获取classes.dex文件 2.解压dex2jar压缩包 3.将classes.dex文件拷贝到dex2jar目录 4.cmd进入dex2jar目录下，执行“d2j-dex2jar.bat classes.dex”命令 5.当前目录下生成classes-dex2jar.jar文件 使用：documentation 示例： C:\Users\Decompile\dex2jar-2.0&gt;d2j-dex2jar classes.dex dex2jar classes.dex -&gt; .\classes-dex2jar.jar jd-gui 下载：downloads 安装：install **Windows:** 1.下载jd-gui-1.4.0.jar文件或者jd-gui-windows-1.4.0.zip压缩包 2.Windows下双击jar文件即可打开Java Decompiler程序 3.用Java Decompiler程序打开classes-dex2jar.jar文件 使用：documentation 示例：]]></content>
      <tags>
        <tag>Decompile</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Visual Studio Code进行Python编程输出中文乱码问题]]></title>
    <url>%2F2016%2F12%2F12%2F2016-12-12-VSCode-encode%2F</url>
    <content type="text"><![CDATA[代码： print(b&apos;ABC&apos;.decode(&apos;ascii&apos;)) print( b&apos;\xe4\xb8\xad\xe6\x96\x87&apos;.decode(&apos;utf-8&apos;)) 输出： 解决方法： import io import sys #改变标准输出的默认编码 sys.stdout=io.TextIOWrapper(sys.stdout.buffer,encoding=&apos;utf8&apos;) 输出： 即可。]]></content>
      <tags>
        <tag>VisualStudioCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[WeakRefrence Demo]]></title>
    <url>%2F2016%2F12%2F10%2F2016-12-10-WeakRefrence-Demo%2F</url>
    <content type="text"><![CDATA[Strong reference（强引用）在Java中，非静态内部类会在其整个生命周期中持有对它外部类的强引用。 public class MainActivity extends Activity { @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); new MyAsyncTask(this).execute(); } private class MyAsyncTask extends AsyncTask { @Override protected Object doInBackground(Object[] params) { // 模拟耗时任务 try { Thread.sleep(60000); } catch (InterruptedException e) { e.printStackTrace(); } return doSomeStuff(); } private Object doSomeStuff() { return new Object(); } @Override protected void onPostExecute(Object object) { super.onPostExecute(object); // 更新UI } } } 这段代码里，MyAsyncTask会跟随Activity的onCreate去创建并开始执行一个长时间的耗时任务，并在耗时任务完成后去更新MainActivity中的UI。这是一个很常见的使用场景，却会导致内存泄露问题。 MainActivity被销毁时，MyAsyncTask中的耗时任务可能仍没有执行完成，所以MyAsyncTask会一直存活。此时，由于MyAsyncTask持有着其外部类，即MainActivity的引用，将导致MainActivity不能被垃圾回收。如果MainActivity中还持有着Bitmap等大对象，反复进出这个页面几次可能就会出现OOM Crash了。 WeakReference（弱引用）弱引用通过类WeakReference来表示。弱引用并不能阻止垃圾回收。如果使用一个强引用的话，只要该引用存在，那么被引用的对象是不能被回收的。弱引用则没有这个问题。在垃圾回收器运行的时候，如果对一个对象的所有引用都是弱引用的话，该对象会被回收。 我们调整一下上面例子中的代码，使用弱引用去避免内存泄露： public class MainActivity extends Activity { @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); new MyAsyncTask(this).execute(); } private static class MyAsyncTask extends AsyncTask { private WeakReference&lt;MainActivity&gt; mainActivity; public MyAsyncTask(MainActivity mainActivity) { this.mainActivity = new WeakReference&lt;&gt;(mainActivity); } @Override protected Object doInBackground(Object[] params) { // 模拟耗时任务 try { Thread.sleep(30000); } catch (InterruptedException e) { e.printStackTrace(); } return doSomeStuff(); } private Object doSomeStuff() { //do something to get result return new Object(); } @Override protected void onPostExecute(Object object) { super.onPostExecute(object); if (mainActivity.get() != null){ // 更新UI } } } } 大家可以注意到，主要的不同点在于，我们把MyAsyncTask改为了静态内部类，并且其对外部类MainActivity的引用换成了： private WeakReference&lt;MainActivity&gt; mainActivity; 当MainActivity destroy的时候，由于MyAsyncTask是通过弱引用的方式持有MainActivity，所以并不会阻止MainActivity被垃圾回收器回收，也就不会有内存泄露产生了。]]></content>
      <tags>
        <tag>WeakReference</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android提供的下载类DownloadManager]]></title>
    <url>%2F2016%2F10%2F18%2F2016-10-19-DownloadManager-Usage%2F</url>
    <content type="text"><![CDATA[Android提供的下载类DownloadManager Usage String downUrl = &quot;http://downloads.jianshu.io/apps/haruki/JianShu-1.11.2.apk&quot;; /**获得系统下载器*/ DownloadManager dm = (DownloadManager) getSystemService(DOWNLOAD_SERVICE); /**设置下载地址*/ DownloadManager.Request request = new DownloadManager.Request(Uri.parse(downUrl)); /**设置下载文件的类型*/ request.setMimeType(&quot;application/vnd.android.package-archive&quot;); /**设置下载存放的文件夹和文件名字*/ request.setDestinationInExternalPublicDir(Environment.DIRECTORY_DOWNLOADS, &quot;JianShu-1.11.2.apk&quot;); /**设置下载时或者下载完成时，通知栏是否显示*/ request.setNotificationVisibility(DownloadManager.Request.VISIBILITY_VISIBLE_NOTIFY_COMPLETED); request.setTitle(&quot;Download&quot;); /**执行下载，并返回任务唯一id*/ long enqueue = dm.enqueue(request);]]></content>
  </entry>
  <entry>
    <title><![CDATA[透明的系统状态栏SystemBar]]></title>
    <url>%2F2016%2F10%2F18%2F2016-10-18-system-bar-transparent%2F</url>
    <content type="text"><![CDATA[透明的系统状态栏SystemBar values/styles.xml &lt;resources&gt; &lt;!-- Base application theme. --&gt; &lt;style name=&quot;AppTheme&quot; parent=&quot;Theme.AppCompat.Light.DarkActionBar&quot;&gt; &lt;item name=&quot;colorPrimary&quot;&gt;@color/colorPrimary&lt;/item&gt; &lt;item name=&quot;colorPrimaryDark&quot;&gt;@color/colorPrimaryDark&lt;/item&gt; &lt;item name=&quot;colorAccent&quot;&gt;@color/colorAccent&lt;/item&gt; &lt;!-- Customize your theme here. --&gt; &lt;/style&gt; &lt;style name=&quot;AppTheme.NoActionBar&quot;&gt; &lt;item name=&quot;windowActionBar&quot;&gt;false&lt;/item&gt; &lt;item name=&quot;windowNoTitle&quot;&gt;true&lt;/item&gt; &lt;/style&gt; &lt;/resources&gt; values-v19/styles.xml &lt;resources&gt; &lt;style name=&quot;AppTheme.NoActionBar&quot;&gt; &lt;item name=&quot;windowActionBar&quot;&gt;false&lt;/item&gt; &lt;item name=&quot;windowNoTitle&quot;&gt;true&lt;/item&gt; &lt;item name=&quot;android:windowTranslucentStatus&quot;&gt;true&lt;/item&gt; &lt;/style&gt; &lt;/resources&gt; values-v21/styles.xml &lt;resources&gt; &lt;style name=&quot;AppTheme.NoActionBar&quot;&gt; &lt;item name=&quot;windowActionBar&quot;&gt;false&lt;/item&gt; &lt;item name=&quot;windowNoTitle&quot;&gt;true&lt;/item&gt; &lt;item name=&quot;android:windowDrawsSystemBarBackgrounds&quot;&gt;true&lt;/item&gt; &lt;item name=&quot;android:statusBarColor&quot;&gt;@color/colorPrimaryDark&lt;/item&gt; &lt;/style&gt; &lt;/resources&gt; layout/activity_main.xml &lt;RelativeLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:background=&quot;@drawable/color_bg&quot; tools:context=&quot;.MainActivity&quot;&gt; &lt;android.support.v7.widget.Toolbar android:id=&quot;@+id/toolbar&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:fitsSystemWindows=&quot;true&quot; android:background=&quot;@android:color/transparent&quot; android:minHeight=&quot;?attr/actionBarSize&quot;&gt; &lt;TextView android:id=&quot;@+id/title&quot; style=&quot;@style/TextAppearance.AppCompat.Subhead&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_gravity=&quot;left&quot; android:text=&quot;1111&quot; android:textColor=&quot;@color/colorPrimaryDark&quot; android:textSize=&quot;20sp&quot; /&gt; &lt;/android.support.v7.widget.Toolbar&gt; &lt;!--&lt;ImageView--&gt; &lt;!--android:id=&quot;@+id/img&quot;--&gt; &lt;!--android:layout_width=&quot;match_parent&quot;--&gt; &lt;!--android:layout_height=&quot;match_parent&quot;--&gt; &lt;!--android:scaleType=&quot;centerCrop&quot;--&gt; &lt;!--android:src=&quot;@drawable/color_bg&quot; /&gt;--&gt; &lt;/RelativeLayout&gt; systembardemo/MainActivity.java @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.KITKAT) { // Translucent status bar getWindow().setFlags(WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS, WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS); } setContentView(R.layout.activity_main); }]]></content>
  </entry>
  <entry>
    <title><![CDATA[使用AppCompat-21适配Material Design]]></title>
    <url>%2F2016%2F09%2F30%2F2016-09-30-AppCompat-21-Material-Design%2F</url>
    <content type="text"><![CDATA[使用AppCompat-21适配Material Design 设置compileSdkVersion为21android { compileSdkVersion 21 buildToolsVersion &quot;21.0.0&quot; defaultConfig { applicationId &quot;com.way.material&quot; minSdkVersion 14 targetSdkVersion 21 versionCode 1 versionName &quot;1.0&quot; } ... } dependencies { compile fileTree(dir: &apos;libs&apos;, include: [&apos;*.jar&apos;]) compile &apos;com.android.support:appcompat-v7:21.+&apos; } 自定义主题自定义主题继承自Theme.AppCompat。创建values-v21文件夹，在style.xml中用Base theme作为父类然后覆写新主题theme。 values/style.xml &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;resources&gt; &lt;style name=&quot;AppTheme&quot; parent=&quot;AppTheme.Base&quot;/&gt; &lt;style name=&quot;AppTheme.Base&quot; parent=&quot;Theme.AppCompat&quot;&gt; &lt;item name=&quot;colorPrimary&quot;&gt;@color/colorPrimary&lt;/item&gt; &lt;item name=&quot;colorPrimaryDark&quot;&gt;@color/colorPrimary&lt;/item&gt; &lt;item name=&quot;android:windowNoTitle&quot;&gt;true&lt;/item&gt; &lt;item name=&quot;windowActionBar&quot;&gt;false&lt;/item&gt; &lt;/style&gt; &lt;/resources&gt; values-v21/style.xml &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;resources&gt; &lt;style name=&quot;AppTheme&quot; parent=&quot;AppTheme.Base&quot;&gt; &lt;item name=&quot;android:windowContentTransitions&quot;&gt;true&lt;/item&gt; &lt;item name=&quot;android:windowAllowEnterTransitionOverlap&quot;&gt;true&lt;/item&gt; &lt;item name=&quot;android:windowAllowReturnTransitionOverlap&quot;&gt;true&lt;/item&gt; &lt;item name=&quot;android:windowSharedElementEnterTransition&quot;&gt;@android:transition/move&lt;/item&gt; &lt;item name=&quot;android:windowSharedElementExitTransition&quot;&gt;@android:transition/move&lt;/item&gt; &lt;/style&gt; &lt;/resources&gt; 在AndroidManifest.xml中适用新主题&lt;application ... android:theme=&quot;@style/AppTheme&quot;&gt; ... &lt;/application&gt; 为ToolBar适配主题 设置Toolbar背景色 &lt;android.support.v7.widget.Toolbar xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:id=&quot;@+id/toolbar&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:background=&quot;?attr/colorPrimaryDark&quot;/&gt; Activitiy必须继承自ActionBarActivity @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(getLayoutResource()); Toolbar toolbar = (Toolbar) findViewById(R.id.toolbar); if (toolbar != null) { setSupportActionBar(toolbar); } } 5.0系统Activity转场动画 Lollipop提供了一系列兼容类支持这些新特性 ActivityOptionsCompat options = ActivityOptionsCompat.makeSceneTransitionAnimation(activity, transitionView, DetailActivity.EXTRA_IMAGE); ActivityCompat.startActivity(activity, new Intent(activity, DetailActivity.class), options.toBundle()); 我说完了]]></content>
  </entry>
  <entry>
    <title><![CDATA[TextInput使用知识]]></title>
    <url>%2F2016%2F09%2F26%2F2016-09-26-TextInput-Usage%2F</url>
    <content type="text"><![CDATA[TextInput使用知识 TextInput XML属性&amp;常用方法 counterEnabled：false or true，用于设置字符计数器的开启或关闭。 对应方法：setCounterEnabled(boolean) counterMaxLength：设置字符计数器的最大长度。（仅用于设置计数器最大值，并不影响文本实际能输入的最大长度） 对应方法：setCounterMaxLength(int) errorEnabled：false or true，用于设置错误提示是否开启。 对应方法：setErrorEnabled(boolean) hint：设置输入框的提示语。 对应方法：setHint(CharSequence) hintAnimationEnabled：true or false，开启或关闭hint浮动成标签的动画效果。 对应方法：setHintAnimationEnabled(boolean) hintEnabled：true or false，开启或关闭hint浮动的功能，设为false的话就和之前的EditText一样，在输入文字后，提示语就消失了。 对应方法：setHintEnabled(boolean) hintTextAppearance：设置hint的style，字体颜色，字体大小等，可引用系统自带的也可以自定义。若要使用请统一使用，以保证APP体验的统一性。 对应方法：setHintTextAppearance(int) 当文本输入类型为密码时，系统提供了一个开关来控制密码是否可见（默认为眼睛）。此为design包24.0.2新提供的功能。 passwordToggleEnabled：控制密码可见开关是否启用。设为false则该功能不启用，密码输入框右侧也没有控制密码可见与否的开关。 对应方法：setPasswordVisibilityToggleEnabled(boolean) passwordToggleDrawable：设置密码可见开关的图标。通常我们会在不同的情况下设定不同的图标，可通过自定义一个selector，根据“state_checked”属性来控制图标的切换。后面代码实践里会有示范。 对应方法：setPasswordVisibilityToggleDrawable(Drawable) passwordToggleTint：控制密码可见开关图标的颜色。在开启或关闭的状态下我们可以设定不同的颜色，可通过自定义一个color的selector，根据“state_checked”和“state_selected”属性来控制颜色的切换。后面代码实践里会有示范。 对应方法：setPasswordVisibilityToggleTintList(ColorStateList) passwordToggleTintMode：控制密码可见开关图标的背景颜色混合模式。这个地方我不是很能理解，暂作标记，希望有人可以指教。不过可以肯定的是正常需求都用不到这个属性。分别是： multiply, screen, src_atop, src_in, src_over 对应方法：setPasswordVisibilityToggleTintMode(PorterDuff.Mode) passwordToggleContentDescription：该功能是为Talkback或其他无障碍功能提供的。TalkBack会去读contentDescription的值，告诉用户这个操作是什么。 对应方法：setPasswordVisibilityToggleContentDescription(int)]]></content>
  </entry>
  <entry>
    <title><![CDATA[A MarginLayoutParams Error]]></title>
    <url>%2F2016%2F09%2F25%2F2016-09-25-MarginLayoutParams-Error%2F</url>
    <content type="text"><![CDATA[A MarginLayoutParams Error Code: ViewGroup.MarginLayoutParams lp = new ViewGroup.MarginLayoutParams(LayoutParams.WRAP_CONTENT, LayoutParams.WRAP_CONTENT); Error: should pass resolved pixel dimension instead of resource id here:getResource().getDimession*(ViewGroup.LayoutParams.WRAP_CONTENT) MATCH_PARENT 和 WRAP_CONTENT 其实是 MarginLayoutParams 构造函数的合法参数. 按Alt + Enter忽略代码检测即可。]]></content>
  </entry>
  <entry>
    <title><![CDATA[RenderScript框架实现图片模糊效果]]></title>
    <url>%2F2016%2F09%2F16%2F2016-09-16-renderscript-fuzy-image%2F</url>
    <content type="text"><![CDATA[RenderScript框架实现图片模糊效果 1.使用RenderScript Support Library APIs为了使用Support Library RenderScript的API，你必须确保你的开发环境能够访问到它们。下面的Android SDK工具是使用这些API所需要的： Android SDK Tools revision 22.2 or higher Android SDK Build-tools revision 18.1.0 or higher 更新Android构建过程的配置，加入RenderScript的配置： 打开build.gradle文件，添加RenderScript的配置。 android { compileSdkVersion 23 buildToolsVersion &quot;23.0.3&quot; defaultConfig { minSdkVersion 8 targetSdkVersion 19 renderscriptTargetApi 18 renderscriptSupportModeEnabled true } } renderscriptTargetApi - 指定生成的字节码版本。我们建议你设置这个值为能够提供你正在使用的所有功能的最低API级别，同时设置renderscriptSupportModeEnabled为true。这个设置的有效值为11到最近发布的API级别值。如果你的应用程序配置文件里面指定的最小SDK版本设置为不同的值，那这个值将会被忽略，构建文件中的目标版本值用来设置最低SDK版本。 renderscriptSupportModeEnabled - 如果运行的设备不支持该目标版本，那么可以指定生成的字节码回落到一个兼容的版本。 buildToolsVersion - Android 构建工具所使用的版本。这个值应该被设置为18.1.0或者更高。如果这个可选的配置没有被指定，那么将会默认使用安装的最高版本的构建工具。你应该总是设置这个值，以确保不同开发设备不同配置之间的一致性。 在你使用RenderScript的类文件里面，导入Support Library的类： import android.support.v8.renderscript.*; 2.通过Java代码使用RenderScript通过Java代码来使用RenderScript依赖于位于android.renderscript或android.support.v8.renderscript包中的API类。大多数应用都遵循基本的使用模式： 1).初始化一个RenderScript上下文。RenderScript上下文，通过create(Context)方法进行创建，确保RenderScript能过被使用，同时提供一个对象来控制所有后续的RenderScript对象的生存期。你应该考虑创建一个长期运行的context，因为它可以创建不同的硬件资源。通常，一个应用程序只能持有一个RenderScript单例。 2).创建至少一个Allocation传递到脚本中。一个Allocation是一个RenderScript对象，提供固定数据的存储。脚本中的内核，采取Allocation对象作为它们的输入和输出，同时Allocation对象可以在绑定全局脚本变量的时候，通过调用rsGetElementAt_type()和rsSetElementAt_type()方法在内核中进行访问。Allocation对象运行数组从Java代码中传递到RenderScript代码，反之亦然。Allocation对象创建最典型的方式是使用createTyped(RenderScript, Type)或者createFromBitmap(RenderScript, Bitmap)。 3).创建脚本是必要的。在使用RenderScript时，提供两种类型的脚本： ScriptC：这些是写在上述RenderScript内核中的用户自定义脚本。为了使Java代码能够更容易访问到脚本代码，每个脚本都会通过RenderScript编译器反射为一个具体的Java类。这些类的名字为ScriptC_filename。例如，你的内核位于invert.rs，并且一个RenderScript上下文已经位于mRS,Java代码实例化脚本为： ScriptC_invert invert = new ScriptC_invert(mRenderScript); ScriptIntrinsic：这些是内置在RenderScript内核的共同操作，比如高斯模糊，图像混合等等。想了解更多信息，请参阅ScriptIntrinsic的子类。 4).用数据填充Allocation对象。除了通过android.renderscript创建Allocation对象，一个Allocation对象会在第一次创建的时候被填充空数据。为了填充一个Allocation对象，使用Allocation方法中的copy方法。 详细代码的使用逻辑//图片缩放比例 private static final float BITMAP_SCALE = 0.4f; /** * 模糊图片的具体方法 * * @param context 上下文对象 * @param image 需要模糊的图片 * @return 模糊处理后的图片 */ public static Bitmap blurBitmap(Context context, Bitmap image, float blurRadius) { Log.d(TAG, &quot;blurBitmap debug&quot;); // 计算图片缩小后的长宽 int width = Math.round(image.getWidth() * BITMAP_SCALE); int height = Math.round(image.getHeight() * BITMAP_SCALE); // 将缩小后的图片做为预渲染的图片 Bitmap inputBitmap = Bitmap.createScaledBitmap(image, width, height, false); // 创建一张渲染后的输出图片 Bitmap outputBitmap = Bitmap.createBitmap(inputBitmap); // 创建RenderScript内核对象 RenderScript rs = RenderScript.create(context); // 创建一个模糊效果的RenderScript的工具对象 ScriptIntrinsicBlur blurScript = ScriptIntrinsicBlur.create(rs, Element.U8_4(rs)); // 由于RenderScript并没有使用VM来分配内存,所以需要使用Allocation类来创建和分配内存空间 // 创建Allocation对象的时候其实内存是空的,需要使用copyTo()将数据填充进去 Allocation tmpIn = Allocation.createFromBitmap(rs, inputBitmap); Allocation tmpOut = Allocation.createFromBitmap(rs, outputBitmap); // 设置渲染的模糊程度, 25f是最大模糊度 blurScript.setRadius(blurRadius); // 设置blurScript对象的输入内存 blurScript.setInput(tmpIn); // 将输出数据保存到输出内存中 blurScript.forEach(tmpOut); // 将数据填充到Allocation中 tmpOut.copyTo(outputBitmap); return outputBitmap; } 最后Android官网提供了一个使用示例：Source]]></content>
      <tags>
        <tag>RenderScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 6.0之后的权限适配处理]]></title>
    <url>%2F2016%2F09%2F13%2F2016-09-13-android-6-permissions%2F</url>
    <content type="text"><![CDATA[Android 6.0之后的权限适配处理 一个基本的android程序是没有任何权限的。也就是说，无论是从用户体验上和设备数据上都没有什么危害。 在产品需求下，为了能够使用设备的受保护特性，你必须在AndroidManifest.xml 里声明至少一种所需要的权限。 例如，一个程序需要管理收到的短信，需要指定: &lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; package=&quot;com.android.app.myapp&quot; &gt; &lt;uses-permission android:name=&quot;android.permission.RECEIVE_SMS&quot; /&gt; ... &lt;/manifest&gt; 在安装应用程序时，安装者要基于应用程序的签名在交互时对应用程序所需的权限进行授权。应用程序运行时不会进行权限检查：它要么在安装后被给予一个特殊的权限，并且可以使用它期望的权限，要么就不被授予权限，任何使用这些权限的操作都会在没有用户提示的情况下自动失败。 通常如果请求权限失败应用程序会抛出一个SecurityException异常，但是也有特例。例如，sendBroadcast(Intent)函数在所有数据被投递到接收者时检查权限，当函数返回后，不会对数据的权限进行检查，也不能接收到任何权限异常。约大多数情况下，权限异常会记录在日志中。 在Android6.0（M）之后，对权限进行了分类，大致有这三种： 普通权限 危险权限 特殊权限 普通权限也就是正常权限，是对手机的一些正常操作，对用户的隐私没有太大影响的权限，比如手机的震动，网络访问，蓝牙等权限，这些权限会在应用被安装的时候默认授予，用户不能拒绝，也不能取消。 普通权限列表： ACCESS_LOCATION_EXTRA_COMMANDS ACCESS_NETWORK_STATE ACCESS_NOTIFICATION_POLICY ACCESS_WIFI_STATE BLUETOOTH BLUETOOTH_ADMIN BROADCAST_STICKY CHANGE_NETWORK_STATE CHANGE_WIFI_MULTICAST_STATE CHANGE_WIFI_STATE DISABLE_KEYGUARD EXPAND_STATUS_BAR GET_PACKAGE_SIZE INTERNET KILL_BACKGROUND_PROCESSES MODIFY_AUDIO_SETTINGS NFC READ_SYNC_SETTINGS READ_SYNC_STATS RECEIVE_BOOT_COMPLETED REORDER_TASKS REQUEST_INSTALL_PACKAGES SET_TIME_ZONE SET_WALLPAPER SET_WALLPAPER_HINTS TRANSMIT_IR USE_FINGERPRINT VIBRATE WAKE_LOCK WRITE_SYNC_SETTINGS SET_ALARM INSTALL_SHORTCUT UNINSTALL_SHORTCUT 对于上面这些权限，需要和Android6.0（M）之前的系统，在AndroidManifest.xml声明即可。 危险权限其实就是运行中需要处理的权限，也是我们最需要注意的权限，这些权限会关系到用户的隐私或影响到其他应用的运行，这些危险权限，谷歌还做了一个权限组，以分组的形式来呈现： Source 例如手机淘宝的权限适配： 在代码中进行权限适配只需要记住下面几个API方法就可以：（API23之后提供） int checkSelfPermission(String permission) 用来检测应用是否已经具有权限 void requestPermissions(String[] permissions, int requestCode) 进行请求单个或多个权限 void onRequestPermissionsResult(int requestCode, String[] permissions, int[] grantResults) 请求权限结果回调 下面来段代码示例（为了向下兼容，这里我采用了v4包下的ContextCompat和ActivityCompat）： btnGetPermissions.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { //判断当前系统是否高于或等于6.0 if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.M) { //当前系统大于等于6.0 if (ContextCompat.checkSelfPermission(MineInforActivity.this,Manifest.permission.CAMERA) == PackageManager.PERMISSION_GRANTED) { //具有拍照权限，直接调用相机 //具体调用代码 } else { //不具有拍照权限，需要进行权限申请 ActivityCompat.requestPermissions(MineInforActivity.this,new String[]{Manifest.permission.CAMERA}, REQUEST_PERMISSION_CAMERA_CODE); } } else { //当前系统小于6.0，直接调用拍照 } } }); 1.这里PERMISSION_GRANTED表示具有权限，PERMISSION_DENIED表示无权限 2.在判断应用没有相关权限的后，我们通过requestPermissions进行权限申请，这里的 String[] permissions是个字符串数组，可以对多个权限进行申请 3.REQUEST_PERMISSION_CAMERA_CODE是个标识码，类似Intent跳转的REQUEST_CODE的，然后我们就可以在onRequestPermissionsResult进行 权限申请的回调处理： @Override public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) { super.onRequestPermissionsResult(requestCode, permissions, grantResults); if (requestCode == REQUEST_PERMISSION_CAMERA_CODE) { if (grantResults.length &gt;= 1) { int cameraResult = grantResults[0];//相机权限 boolean cameraGranted = cameraResult == PackageManager.PERMISSION_GRANTED;//拍照权限 if (cameraGranted) { //具有拍照权限，调用相机 } else { //不具有相关权限，给予用户提醒，比如Toast或者对话框，让用户去系统设置-应用管理里把相关权限开启 } } } } 上面的那张图，有的朋友应该已经留意到了有个不再提醒的勾选框，如果用户勾选了不再提醒，然后把你拒绝了，那你的应用就GG了，其实这里还有一个API方法： if(!shouldShowRequestPermissionRationale(Manifest.permission.CAMERA)){ //如果用户勾选了不再提醒，则返回false //给予用户提醒，比如Toast或者对话框，让用户去系统设置-应用管理里把相关权限打开 } 当用户勾选了不再提醒的框并把你拒之门外了，这个方法的返回值是true，它可以帮助你再一次的提醒用户需要这个权限。 但是在实际开发中，不得不说的一个坑，由于国内第三方ROM对系统改造的太严重，比如小米，亲测有些机型的这个方法是不起作用的，永远的是返回false，这个时候该怎么办，就要另外想解决方案了。 还有需要注意的一点是上面的权限分组，比如读写文件权限： WRITE_EXTERNAL_STORAGE READ_EXTERNAL_STORAGE 它们是属于同一个权限组的，你如果拿到了他们其中的一个权限，那么也同时会有另一个权限，同理，如果你拿到读取通讯录的权限，那么你同事也会拥有写入通讯录的权限，这样就避免了我们在申请相关权限的时候需要些老长老长的权限代码了。 特殊权限特殊权限，比如： 系统级别对话框： SYSTEM_ALERT_WINDOW 修改系统设置： WRITE_SETTINGS 这2个特殊权限，我们需要在startActivityForResult里调用即可，这2个权限一般是不会用到，会用到的地方要么是黑科技或者是反用户体验的场景，这里就不再做过多描述，有兴趣的朋友自己探索吧。 这里需要另外提到的一个权限： READ_PHONE_STATE 我们可以通过这个权限来获取机器的唯一标识码，很多第三方统计是基于这个标识码来完成统计的，但是在我们应用一开始运行的时候，这个运行权限我们是没有的，在Application里我们也不能对权限进行获取，所以这点也需要我们去注意。 最后对于一些比较特别的权限，比如文件的读写权限，一般在我们第一次开启APP的时候就要去获取了，假设我们一开始没有获取到这个权限，那么如果我的首页有轮播广告图，这个广告图是网络获取的，做了三级缓存，这样就会到导致磁盘缓存无法写入。这边提供一个解决方法，就是在你引导APP启动的时候，就引导用户去获取权限，当用户拒绝的时候，应该给出弹出框并跳转对应的应用权限管理界面（需要对不同机型进行设置）。 可以参考微信的做法： 启动app，在闪屏页的时候向用户提出权限的申请: 1.存储空间权限，关闭微信 2.电话权限，关闭微信 3.位置权限，关闭微信 进入app: 1.发照片时，申请照片权限 2.发语音时，申请麦克风权限 3.用户每次点击拒绝，都弹出自定义对话框，提示用户设置权限 关于在AndroidManifest.xml中声明强制权限Source 进入系统或应用程序的组件的高级别权限可以在AndroidManifest.xml中实现。所有这些都可以通过在相应的组件中包含 android:permission 属性，以使其被用以控制进入的权限。 Activity权限（应用于activity标签）用于限制谁才可以启动相关的Activity。该权限在运行Context.startActivity()和Activity.startActivityForResult()期间被检查；如果调用方不具有相应必需的权限，那么将会从此次调用中抛出SecurityException 异常。 Service权限（应用于service标签）用于限制谁才可以启动或绑定该service。在运行Context.startService() , Context.stopService()和Context.bindService()调用的时候会进行权限检查。如果调用方没有所需的权限，则会抛出一个SecurityException异常。 BroadcastReceiver许可（应用于receiver标签）用于限制谁可以向相关的接收器发送广播。权限检查会在Context.sendBroadcast()返回后当系统去发送已经提交的广播给相应的Receiver时进行。最终，一个permission failure不会再返回给调用方一个异常，只是不会去实现该Intent而已。同样地，Context.registerReceiver()也可以通过自己的permission用于限制谁可以向一个在程序中注册的receiver发送广播。另一种方式是，一个permission也可以提供给Context.sendBroadcast() 用以限制哪一个BroadcastReceiver才可以接收该广播。（见下文） ContentProvider许可（应用于provider标签）用于限制谁才可以访问ContentProvider提供的数据。（Content providers有一套额外的安全机制叫做URI permissions，这些在稍后讨论。）不像其他组件，它有两个单独的权限属性，你可以设置： android:readPermission用于限制谁能够读，android:writePermission用于限制谁能够写。需要注意的是如果provider同时需要读写许可，只有写许可的情况下并不能读取provider中的数据。当你第一次检索内容提供者和当完成相关操作时会进行权限检查。（假如没有任何权限则会抛出SecurityException异常。）使用ContentResolver.query()需要持有读权限；使用ContentResolver.insert()，ContentResolver.update()，ContentResolver.delete()需要写权限。在所有这些情况下，没有所需的权限将会导致抛出SecurityException异常。]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ButterKnife Problem]]></title>
    <url>%2F2016%2F08%2F28%2F2017-03-10-butterknife-problem%2F</url>
    <content type="text"><![CDATA[注入式框架共有的问题 使用ButterKnife初始化控件，程序需要花时间遍历文件中的@BindView标签。]]></content>
      <tags>
        <tag>ButterKnife</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[An Simple HandlerThread Example]]></title>
    <url>%2F2016%2F08%2F10%2F2016-08-10-handlerthreadexample%2F</url>
    <content type="text"><![CDATA[HandlerThread实例 import android.os.Bundle; import android.os.Handler; import android.os.HandlerThread; import android.os.Message; import android.support.v7.app.AppCompatActivity; import android.text.Html; import android.widget.TextView; public class HandlerThreadActivity extends AppCompatActivity{ private TextView mTvServiceInfo; private HandlerThread mCheckMsgThread; private Handler mCheckMsgHandler; private boolean isUpdateInfo; private static final int MSG_UPDATE_INFO = 0x110; //与UI线程管理的handler private Handler mHandler = new Handler(); @Override protected void onCreate(Bundle savedInstanceState){ super.onCreate(savedInstanceState); setContentView(R.layout.activity_thread_handler); //创建后台线程 initBackThread(); mTvServiceInfo = (TextView) findViewById(R.id.id_textview); } @Override protected void onResume(){ super.onResume(); //开始查询 isUpdateInfo = true; mCheckMsgHandler.sendEmptyMessage(MSG_UPDATE_INFO); } @Override protected void onPause(){ super.onPause(); //停止查询 isUpdateInfo = false; mCheckMsgHandler.removeMessages(MSG_UPDATE_INFO); } @Override protected void onDestroy(){ super.onDestroy(); //释放资源 mCheckMsgThread.quit(); } private void initBackThread(){ mCheckMsgThread = new HandlerThread(&quot;check-message-coming&quot;); mCheckMsgThread.start(); mCheckMsgHandler = new Handler(mCheckMsgThread.getLooper()){ @Override public void handleMessage(Message msg){ checkForUpdate(); if (isUpdateInfo){ mCheckMsgHandler.sendEmptyMessageDelayed(MSG_UPDATE_INFO, 1000); } } }; } /** * 模拟从服务器解析数据 */ private void checkForUpdate(){ try{ //模拟耗时 Thread.sleep(1000); mHandler.post(new Runnable(){ @Override public void run(){ String result = &quot;实时更新中，当前大盘指数：&lt;font color=&apos;red&apos;&gt;%d&lt;/font&gt;&quot;; result = String.format(result, (int) (Math.random() * 3000 + 1000)); mTvServiceInfo.setText(Html.fromHtml(result)); } }); } catch (InterruptedException e){ e.printStackTrace(); } } } 在onCreate中，去创建和启动了HandlerThread，并且关联了一个mCheckMsgHandler。然后我们分别在onResume和onPause中去开启和暂停我们的查询，最后在onDestory中去释放资源。 这样就实现了我们每隔5s去服务端查询最新的数据，然后更新我们的UI，当然我们这里通过Thread.sleep()模拟耗时，返回了一个随机数，大家可以很轻易的换成真正的数据接口。 HandlerThread 源码分析 我们是通过 mCheckMsgThread = new HandlerThread(&quot;check-message-coming&quot;); mCheckMsgThread.start(); 创建和启动的对象，那么查看HandlerThread的源码: package android.os; public class HandlerThread extends Thread { int mPriority; int mTid = -1; Looper mLooper; public HandlerThread(String name) { super(name); mPriority = Process.THREAD_PRIORITY_DEFAULT; } protected void onLooperPrepared() { } @Override public void run() { mTid = Process.myTid(); Looper.prepare(); synchronized (this) { mLooper = Looper.myLooper(); notifyAll(); } Process.setThreadPriority(mPriority); onLooperPrepared(); Looper.loop(); mTid = -1; } } 看到了什么，其实我们就是初始化和启动了一个线程；然后我们看 run() 方法，可以看到该方法中调用了 Looper.prepare() ， Loop.loop() 。 prepare() 中创建了一个Looper对象，并且把该对象放到了该线程范围内的变量中（ sThreadLocal ），在 Looper 对象的构造过程中，初始化了一个 MessageQueue ，作为该 Looper 对象成员变量。 loop() 就开启了，不断的循环从 MessageQueue 中取消息处理了，当没有消息的时候会阻塞，有消息的到来的时候会唤醒。 接下来，我们创建了一个mCheckMsgHandler，是这么创建的： mCheckMsgHandler = new Handler(mCheckMsgThread.getLooper()) 对应源码: public Looper getLooper() { if (!isAlive()) { return null; } // If the thread has been started, wait until the looper has been created. synchronized (this) { while (isAlive() &amp;&amp; mLooper == null) { try { wait(); } catch (InterruptedException e) { } } } return mLooper; } mCheckMsgThread.getLooper() 返回的就是我们在 run 方法中创建的 mLooper 。 那么 Handler 的构造呢，其实就是在 Handler 中持有一个指向该 Looper.mQueue 对象，当 handler 调用 sendMessage 方法时，其实就是往该 mQueue 中去插入一个 message ，然后 Looper.loop() 就会取出执行。 如果你够细心你会发现， run 方法里面当mLooper创建完成后有个 notifyAll() ， getLooper() 中有个 wait() ，这是为什么呢？因为的 mLooper 在一个线程中执行，而我们的 handler 是在 UI 线程初始化的，也就是说，我们必须等到 mLooper 创建完成，才能正确的返回 getLooper() 。 wait() , notify() 就是为了解决这两个线程的同步问题。]]></content>
      <tags>
        <tag>HandlerThread</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Toolbar里的文本或者控件不能左对齐]]></title>
    <url>%2F2016%2F07%2F21%2F2016-08-09-toolbar-style-custom%2F</url>
    <content type="text"><![CDATA[原因: Wiget.AppCompat.Toolbar的默认style指定了contentInsetStart属性，即内容插入只能在16dp处开始。 &lt;style name=&quot;Base.Widget.AppCompat.Toolbar&quot; parent=&quot;android:Widget&quot;&gt; &lt;item name=&quot;titleTextAppearance&quot;&gt;@style/TextAppearance.Widget.AppCompat.Toolbar.Title&lt;/item&gt; &lt;item name=&quot;subtitleTextAppearance&quot;&gt;@style/TextAppearance.Widget.AppCompat.Toolbar.Subtitle&lt;/item&gt; &lt;item name=&quot;android:minHeight&quot;&gt;?attr/actionBarSize&lt;/item&gt; &lt;item name=&quot;titleMargins&quot;&gt;4dp&lt;/item&gt; &lt;item name=&quot;maxButtonHeight&quot;&gt;56dp&lt;/item&gt; &lt;item name=&quot;collapseIcon&quot;&gt;?attr/homeAsUpIndicator&lt;/item&gt; &lt;item name=&quot;collapseContentDescription&quot;&gt;@string/abc_toolbar_collapse_description&lt;/item&gt; &lt;item name=&quot;contentInsetStart&quot;&gt;16dp&lt;/item&gt; &lt;/style&gt; 解决方法： 在styles.xml中定义新的style继承自Wiget.AppCompat.Toolbar如下： &lt;style name=&quot;CustomToolbarStyle&quot; parent=&quot;Widget.AppCompat.Toolbar&quot;&gt; &lt;item name=&quot;contentInsetStart&quot;&gt;0dp&lt;/item&gt;&lt;!-- 设置该属性解决空白部分--&gt; &lt;/style&gt; 然后在你的style.xml中AppTheme里重写toolbarStyle属性. &lt;!-- Base application theme. “NoActionBar”隐藏原有的Actionbar 设置Toolbar --&gt; &lt;style name=&quot;AppTheme&quot; parent=&quot;Theme.AppCompat.Light.NoActionBar&quot;&gt; //..... &lt;item name=&quot;toolbarStyle&quot;&gt;@style/CustomToolbarStyle&lt;/item&gt; &lt;/style&gt;]]></content>
      <tags>
        <tag>Toolbar</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学习ConstraintLayout布局]]></title>
    <url>%2F2016%2F07%2F20%2F2016-07-21-about-constraint-layout%2F</url>
    <content type="text"><![CDATA[下载了Android Studio 2.2 Preview 5版本，发现新建项目build.gradle文件新增了一个layout插件ConstraintLayout compile &apos;com.android.support.constraint:constraint-layout:1.0.0-alpha4&apos; content_main.xml文件默认采用android.support.constraint.ConstraintLayout布局： &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;android.support.constraint.ConstraintLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; android:id=&quot;@+id/content_main&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; tools:context=&quot;com.way.once.MainActivity&quot; tools:showIn=&quot;@layout/activity_main&quot;&gt; &lt;TextView android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;Hello World!&quot; app:layout_constraintBottom_toBottomOf=&quot;@+id/content_main&quot; app:layout_constraintLeft_toLeftOf=&quot;@+id/content_main&quot; app:layout_constraintRight_toRightOf=&quot;@+id/content_main&quot; app:layout_constraintTop_toTopOf=&quot;@+id/content_main&quot; /&gt; &lt;/android.support.constraint.ConstraintLayout&gt; TextView的4个layout属性： app:layout_constraintBottom_toBottomOf=&quot;@+id/content_main&quot; app:layout_constraintLeft_toLeftOf=&quot;@+id/content_main&quot; app:layout_constraintRight_toRightOf=&quot;@+id/content_main&quot; app:layout_constraintTop_toTopOf=&quot;@+id/content_main&quot; 都是相对于父布局的位置限制，使TextView始终处于居中显示。 然后通过layout_constraintHorizonal_bias、layout_constraintVertical_bias属性可以横向和纵向的位置偏移： app:layout_constraintVertical_bias=&quot;0.8&quot; app:layout_constraintHorizontal_bias=&quot;0.6&quot; 注意app:layout_constraintVertical_bias=”0.5”相当于没有偏移。 Google Codelabs提供了知识介绍，Demo程序地址为GitHub.]]></content>
      <tags>
        <tag>ConstraintLayout</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[recreate()方法重新创建Activity]]></title>
    <url>%2F2016%2F07%2F18%2F2016-08-22-activity-recreate%2F</url>
    <content type="text"><![CDATA[在内存不足时，Activity被回收，recreate()是Activity再次恢复的过程。 recreate()的方法内容为： /** * Cause this Activity to be recreated with a new instance. This results * in essentially the same flow as when the Activity is created due to * a configuration change -- the current instance will go through its * lifecycle to {@link #onDestroy} and a new instance then created after it. */ public void recreate() { if (mParent != null) { throw new IllegalStateException(&quot;Can only be called on top-level activity&quot;); } if (Looper.myLooper() != mMainThread.getLooper()) { throw new IllegalStateException(&quot;Must be called from main thread&quot;); } mMainThread.requestRelaunchActivity(mToken, null, null, 0, false, null, false); } 可以看到这个方法有两个IllegalStateException处理。一是，当前需要重建的Activity就处在顶层结构，没有父容器包裹它；二是，必须在主线程里调用。requestRelaunchActivity方法将重新启动Activity。 在ONCE项目中是为了无需重启更新主题所做的处理，即在SettingActivity更换主题之后，通知MainActivity调用recreate方法重新构建MainActivity。 另外可以下面两个方法进行数据的保存和恢复： @Override protected void onSaveInstanceState(Bundle savedInstanceState) { super.onSaveInstanceState(savedInstanceState); savedInstanceState.putInt(&quot;DATA&quot;, 1); } @Override protected void onRestoreInstanceState(Bundle savedInstanceState) { super.onRestoreInstanceState(savedInstanceState); int data = savedInstanceState.getInt(&quot;DATA&quot;); }]]></content>
      <tags>
        <tag>Activity</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Toolbar Back Icon]]></title>
    <url>%2F2016%2F07%2F17%2F2016-07-23-toolbar-back-icon%2F</url>
    <content type="text"><![CDATA[#1.问题 setSupportActionBar(toolbar); if (activity.getSupportActionBar() != null){ getSupportActionBar().setHomeAsUpIndicator(R.drawable.abc_ic_ab_back_mtrl_am_alpha); getSupportActionBar().setDisplayHomeAsUpEnabled(true); } Error : Cannot resolve symbol abc_ic_ab_back_mtrl_am_alpha #2.原因 com.android.support:appcompat-v7:24.0.0里的资源文件 abc_ic_ab_back_mtrl_am_alpha 名称被修改为 abc_ic_ab_back_material 的VectorDrawable文件。 #3.解决方案 使用23.1.1修改 R.drawable.abc_ic_ab_back_mtrl_am_alpha 使用24.0.0修改 R.drawable.abc_ic_ab_back_material R.drawable.abc_ic_ab_back_material的内容为： &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;!-- Copyright (C) 2015 The Android Open Source Project Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License. --&gt; &lt;vector xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:width=&quot;24dp&quot; android:height=&quot;24dp&quot; android:viewportWidth=&quot;24.0&quot; android:viewportHeight=&quot;24.0&quot; android:autoMirrored=&quot;true&quot; android:tint=&quot;?attr/colorControlNormal&quot;&gt; &lt;path android:pathData=&quot;M20,11L7.8,11l5.6,-5.6L12,4l-8,8l8,8l1.4,-1.4L7.8,13L20,13L20,11z&quot; android:fillColor=&quot;@android:color/white&quot;/&gt; &lt;/vector&gt; API小于21需要在gradle文件中添加以下配置: Gradle Plugin 2.0+ android { defaultConfig { vectorDrawables.useSupportLibrary = true } } Gradle Plugin 1.5 android { defaultConfig { generatedDensities = [] } // This is handled for you by the 2.0+ Gradle Plugin aaptOptions { additionalParameters &quot;--no-version-vectors&quot; } }]]></content>
      <tags>
        <tag>Toolbar</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[屏幕触摸OnFling(),OnScroll(),OnDrag()]]></title>
    <url>%2F2016%2F07%2F14%2F2016-07-08-screen-touch-event%2F</url>
    <content type="text"><![CDATA[对于一个view, 常用的操作有点击（click）和长按（long press）二种。实际上，这些操作类型是Android内部在onTouchEvent(MotionEvent event)里对用户的动作做了一定的分析，从而通知应用程序是发生了点击还是长按等事件。 借助GestureDetector来分析出更细致的操作类型。基本的过程就是创建一个myGestureDetector对象，传入自己定义的myOnGestureListener对象，在自己的onTouchEvent回调函数中将接收到的event传给myGestureDetector进行分析，myOnGestureListener会回调我们定义的动作。 从 GestureDetector.SimpleOnGestureListener派生出myListener 会更简单，因为这个类已经实现了全部接口，只是没有什么实际有用的功能。 public MainActivity extends Activity{ private GestureDetector mGestureDetector; @Override public void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); mGestureDetector = new GestureDetector(this, new MyGestureListener()); } @Override public boolean onTouchEvent(MotionEvent event) { return mGestureDetector.onTouchEvent(event); } class MyGestureListener extends GestureDetector.OnGestureListener{ //共有6个方法： // 用户轻触触屏：Touch down(仅一次)时触发, e为down时的MotionEvent: public boolean onDown(MotionEvent e){ return true; } // 用户轻触触屏，且尚未松开或拖动： // 在Touch down(仅一次)之后一定时间（115ms）触发，e为down时的MotionEvent: public boolean onShowPress(MotionEvent e){ return true; } // 用户（轻触触屏后）松开：Touch up(仅一次)时触发，e为up时的MotionEvent: public boolean onSingleTapUp(MotionEvent e){ return true; } // 用户轻触触屏，并拖动： // 按下并滑动时触发，e1为down(仅一次)时的MotionEvent，e2为move(多个)时的MotionEvent: public boolean onScroll(MotionEvent e1, MotionEvent e2, float distanceX, float distanceY){ return true; } // 用户长按触屏(此View必须是可长按的： myView-&gt;setLongClickable(true);)： // 在Touch down之后一定时间（500ms）后，由多个down事件触发，e为down时的MotionEvent: public boolean onLongPress(MotionEvent e){ return true; } // 用户按下触屏、快速移动后松开： // 按下并快速滑动一小段距离（多个move），up时触发，e1为down(仅一次)时的MotionEvent， // e2为up(仅一次)时的MotionEvent: public boolean onFling(MotionEvent e1, MotionEvent e2, float velocityX, float velocityY){ return true; } } } 至于doubletap的检测，可以通过设置mGestureDetector的OnDoubleTapListener来实现: GestureDetector.OnDoubleTapListener doubleTapListener = new GestureDetector.OnDoubleTapListener() { // 完成一次单击，并确定（300ms内）没有发生第二次单击事件后触发，e为down时的MotionEvent: public boolean onSingleTapConfirmed(MotionEvent e){ return true; } // 第二次单击down时触发，e为第一次down时的MotionEvent: public boolean onDoubleTap(MotionEvent e){ return true; } // 第二次单击down、move和up时都触发，e为不同时机下的MotionEvent: public boolean onDoubleTapEvent(MotionEvent e){ return true; } } mGestureDetector.setDoubleTapListener(doubleTapListener); 具体地说，典型的触屏事件及其listener执行的流程见下： 1.单击事件的执行流程： 有两种情况，一种是时间很短，一种时间稍长。 时间很短：onDown —-&gt; onSingleTapUp —-&gt; onSingleTapConfirmed 时间稍长：onDown —-&gt; onShowPress —-&gt; onSingleTapUp —-&gt; onSingleTapConfirmed 2.长按事件 onDown —-&gt; onShowPress —-&gt; onLongPress 3.抛(fling)：手指触动屏幕后，稍微滑动后立即松开: onDown —-&gt; onScroll —-&gt; onScroll —-&gt; onScroll —-&gt; ……… —-&gt; onFling 4.拖动(drag) onDown —-&gt; onScroll —-&gt; onScroll —-&gt; onFiling 注意：有的时候会触发onFiling，但是有的时候不会触发，z这是因为人的动作不标准所致。]]></content>
  </entry>
  <entry>
    <title><![CDATA[Drag and Swipe with RecyclerView Part Two]]></title>
    <url>%2F2016%2F07%2F11%2F2016-08-29-drag-and-swipe-with-recyclerview-part-two%2F</url>
    <content type="text"><![CDATA[原文 RecyclerView的拖放和滑动特效 第二部分：手柄、网格与自定义动画 2015年7月22日 在第一部分中，我们研究了ItemTouchHelper，并通过实现ItemTouchHelper.Callback接口，为RecyclerView线性列表添加了基本的“拖放”和“滑动消失”效果。本文就这个例子扩展，增加了对网格布局，触摸“手柄”拖拽，显示所选择的视图和自定义滑动动画的支持。 拖拽手柄当设计一个支持拖放的列表，一般要有一个启动触摸拖动的提示。这有助于用户发现和使用功能，材料教程也推荐列表在“编辑模式”下采用这种设计。接下来我们为前面的例子做一些微小的改动，以生成“手柄”控件，或者“可重新排序的列表控件”。 资料来源：google.com/design 首先，修改List子项布局文件(item_main.xml) &lt;?xml ersion=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;FrameLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:id=&quot;@+id/item&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;?listPreferredItemHeight&quot; android:clickable=&quot;true&quot; android:focusable=&quot;true&quot; android:foreground=&quot;?selectableItemBackground&quot;&gt; &lt;TextView android:id=&quot;@+id/text&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_gravity=&quot;center_vertical&quot; android:layout_marginLeft=&quot;16dp&quot; android:textAppearance=&quot;?android:attr/textAppearanceMedium&quot; /&gt; &lt;ImageView android:id=&quot;@+id/handle&quot; android:layout_width=&quot;?listPreferredItemHeight&quot; android:layout_height=&quot;match_parent&quot; android:layout_gravity=&quot;center_vertical|right&quot; android:scaleType=&quot;center&quot; android:src=&quot;@drawable/ic_reorder_grey_500_24dp&quot; /&gt; &lt;/FrameLayout&gt; view rawitem_main.xml hosted with ❤ by GitHub 拖拽手柄的图标可以在Github项目“Material Design Icons”里找到，并通过“Android Material Design Icon Generator Plugin”插件添加到项目中。 Part One曾简单提到，可通过编程方式使用ItemTouchHelper.startDrag(ViewHolder)启动一个拖拽事件。所以，我们所要做的就是修改ViewHolder以包含新的手柄图标，并设置一个触发startDrag()调用的简单的触摸事件侦听器。 我们需要一个接口来传递事件链： public interface OnStartDragListener { /** * Called when a view is requesting a start of a drag. * * @param viewHolder The holder of the view to drag. */ void onStartDrag(RecyclerView.ViewHolder viewHolder); } 然后，实例化ItemViewHolder中的手柄视图： public final ImageView handleView; public ItemViewHolder(View itemView) { super(itemView); // ... handleView = (ImageView) itemView.findViewById(R.id.handle); } 然后修改RecyclerListAdapter： private final OnStartDragListener mDragStartListener; public RecyclerListAdapter(OnStartDragListener dragStartListener) { mDragStartListener = dragStartListener; // ... } @Override public void onBindViewHolder(final ItemViewHolder holder, int position) { // ... holder.handleView.setOnTouchListener(new OnTouchListener() { @Override public boolean onTouch(View v, MotionEvent event) { if (MotionEventCompat.getActionMasked(event) == MotionEvent.ACTION_DOWN) { mDragStartListener.onStartDrag(holder); } return false; } }); } 完整的RecyclerListAdapter类现在应该是这个样子。 接下来要做的就是在Fragment中添加OnStartDragListener的实现了： public class RecyclerListFragment extends Fragment implements OnStartDragListener { // ... @Override public void onViewCreated(View view, Bundle icicle) { super.onViewCreated(view, icicle); RecyclerListAdapter a = new RecyclerListAdapter(this); // ... } @Override public void onStartDrag(RecyclerView.ViewHolder viewHolder) { mItemTouchHelper.startDrag(viewHolder); } } 整个RecyclerListFragment类现在应该是这样的。运行项目，你现在应该能够通过触摸手柄进行拖拽。 指示所选视图在我们的基本实例中，还没有视觉效果指示被拖拽的视图就是实际被选中的List子Item。显而易见，这还达不到我们的目的，但是也很容易修复。事实上，通过ItemTouchHelper的帮助类，你可以很方便的设置ViewHolder Item子项的背景来达到这种效果。对于Android 5.0版本，以至于更高的版本，可以为Item视图在被拖拽和滑动时设置更大的elevation属性值；在早期版本中，你可以为滑动设置一个基本的淡出效果。 通过使用我们现有的例子也可以实现这一效果，只需为item_main.xml文件的FrameLayout根布局添加一个背景，或在RecyclerListAdapter.ItemViewHolder的构造函数中通过代码来设置。实际效果如下图： 看起来很不错，但你可能希望有更多的控制。要做到这一点的方法就是让ViewHolder可以处理“选中”或“清除”手势的转变。对于这一点，ItemTouchHelper.Callback提供两个回调。 onSelectedChanged(ViewHolder, int)，每次ViewHolder的状态变为拖拽(ACTION_STATE_DRAG)或滑动(ACTION_STATE_SWIPE)时被调用。这是改变Item视图状态到“激活”状态的理想位置。 clearView(RecyclerView, ViewHolder)，拖拽的视图被放下，以及滑动手势被取消或完成(ACTION_STATE_IDLE)时调用。在这里，通常会恢复Item视图的“空闲”状态。 接下来我们将上述方法融合到一起。 首先，创建一个接口供ViewHolder视图实现： /** * Notifies a View Holder of relevant callbacks from * {@link ItemTouchHelper.Callback}. */ public interface ItemTouchHelperViewHolder { /** * Called when the {@link ItemTouchHelper} first registers an * item as being moved or swiped. * Implementations should update the item view to indicate * it&apos;s active state. */ void onItemSelected(); /** * Called when the {@link ItemTouchHelper} has completed the * move or swipe, and the active item state should be cleared. */ void onItemClear(); } 然后，让SimpleItemTouchHelperCallback触发相应的回调： @Override public void onSelectedChanged(RecyclerView.ViewHolder viewHolder, int actionState) { // We only want the active item if (actionState != ItemTouchHelper.ACTION_STATE_IDLE) { if (viewHolder instanceof ItemTouchHelperViewHolder) { ItemTouchHelperViewHolder itemViewHolder = (ItemTouchHelperViewHolder) viewHolder; itemViewHolder.onItemSelected(); } } super.onSelectedChanged(viewHolder, actionState); } @Override public void clearView(RecyclerView recyclerView, RecyclerView.ViewHolder viewHolder) { super.clearView(recyclerView, viewHolder); if (viewHolder instanceof ItemTouchHelperViewHolder) { ItemTouchHelperViewHolder itemViewHolder = (ItemTouchHelperViewHolder) viewHolder; itemViewHolder.onItemClear(); } } 最后，唯一要做的就是使RecyclerListAdapter.ItemViewHolder实现ItemTouchHelperViewHolder接口： public class ItemViewHolder extends RecyclerView.ViewHolder implements ItemTouchHelperViewHolder { // ... @Override public void onItemSelected() { itemView.setBackgroundColor(Color.LTGRAY); } @Override public void onItemClear() { itemView.setBackgroundColor(0); } } 在这个例子中，当视图处于活动状态时我们只是简单地增加一个灰色的背景时，并在视图清除时移除这个背景。如果你的ItemTouchHelper和适配器是紧耦合的，你可以很容易跳过这一步，并直接在ItemTouchHelper.Callback切换视图状态。 网格布局如果你试图改变这个项目以使用GridLayout管理器，你很快就会发现，项目没有正常工作。究其原因和修复方法都很简单：我们需要ItemTouchHelper支持左右拖拽。在SimpleItemTouchHelperCallback，我们已经指定： @Override public int getMovementFlags(RecyclerView recyclerView, RecyclerView.ViewHolder viewHolder) { int dragFlags = ItemTouchHelper.UP | ItemTouchHelper.DOWN; int swipeFlags = ItemTouchHelper.START | ItemTouchHelper.END; return makeMovementFlags(dragFlags, swipeFlags); } 支持网格布局所需的唯一改变是为dragFlags标识添加左右方向： int dragFlags = ItemTouchHelper.UP | ItemTouchHelper.DOWN | ItemTouchHelper.LEFT | ItemTouchHelper.RIGHT; 然而，对于网格布局来说滑动消失不能算是一个合理的动画模式，所以最终的结果可能会是这样： @Override public int getMovementFlags(RecyclerView recyclerView, RecyclerView.ViewHolder viewHolder) { int dragFlags = ItemTouchHelper.UP | ItemTouchHelper.DOWN | ItemTouchHelper.LEFT | ItemTouchHelper.RIGHT; int swipeFlags = 0; return makeMovementFlags(dragFlags, swipeFlags); } 要查看一个能工作的GridLayoutManager示例，请参见RecyclerGridFragment。运行时效果如下图： 自定义滑动动画ItemTouchHelper.Callback为我们提供了一个非常方便的方式去完全控制拖拽和滑动时的视图动画效果。因为ItemTouchHelper辅助类是RecyclerView.ItemDecoration的子类，我们完全可以对有类似情况的视图进行同样的处理。在接下来的部分，我们将在此基础上进一步扩展范围，但这里我们仅提供一个简单实例，通过重写默认滑动特效来显示线性淡出效果。 @Override public void onChildDraw(Canvas c, RecyclerView recyclerView, ViewHolder viewHolder, float dX, float dY, int actionState, boolean isCurrentlyActive) { if (actionState == ItemTouchHelper.ACTION_STATE_SWIPE) { float width = (float) viewHolder.itemView.getWidth(); float alpha = 1.0f - Math.abs(dX) / width; viewHolder.itemView.setAlpha(alpha); viewHolder.itemView.setTranslationX(dX); } else { super.onChildDraw(c, recyclerView, viewHolder, dX, dY, actionState, isCurrentlyActive); } } 参数dX和dY表示所选视图的位置变化： -1.0f，表示从ItemTouchHelper.END到ItemTouchHelper.START的滑动 1.0f，表示从ItemTouchHelper.START到ItemTouchHelper.END的滑动 对于不需要处理的任何actionState，调用super方法尤为重要，这样其他的默认动画效果才能运行。 下一部分将包括一个可以控制拖拽绘图的例子。 结论我们刚刚了解了如何定制ItemTouchHelper类的核心部分。我原本希望在本文提供更多内容，但考虑到文章长度的限制，我决定将其分割成。第二部分和第三部分之间的时间将大大缩短。 文章发表之前GitHub的项目可能要提前更新，所以，如果您无需本文指导，可以直接参看项目仓库查看更新。 源码本系列文章有相应的GitHub项目，Android-ItemTouchHelper-Demo。这一部分的引用代码请参考cimmit提交ef8f149到d164fba。 Follow me on Google+ and Twitter © 2015 Paul BurkeAll code appearing in this article is licensed under Apache 2.0 Some rights reserved by the author. Android App Development Android]]></content>
      <tags>
        <tag>RecyclerView</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Drag and Swipe with RecyclerView Part One]]></title>
    <url>%2F2016%2F07%2F11%2F2016-08-17-Drag-and-Swipe-withRecyclerView-Part-One%2F</url>
    <content type="text"><![CDATA[原文 RecyclerView的拖放和滑动特效 第一部分：基础ItemTouchHelper实例 2015年6月23日 有很多教程，库和实例通过RecyclerView实现Android的“拖放”和“滑动消失”功能。即使有新的，更好的，可用的方法，大多数人仍在使用旧的View.OnDragListener接口和Roman Nurik的SwipeToDismiss做法。极少数人会使用较新的API，但往往采用GestureDetectors和onInterceptTouchEvent接口，或者实现过程较为复杂。实际上，有一个非常简单的途径将这些功能添加到RecyclerView。它只需要一个类，这个类已经存在于Android支持库了： ItemTouchHelper ItemTouchHelper是一个强大的工具，在实现RecyclerView的“拖放”和“滑动消失”功能时能兼顾到任何细节。它是RecyclerView.ItemDecoration的子类，这意味着它很容易地添加到几乎任何现有的布局管理和适配器中（！）。它还可以适配现有的Item动画，还可以提供类型限制的拖拽，降沉动画，等等。本文我将演示一个基于ItemTouchHelper的简单实现。然后，在这个系列中，我们将范围扩大，去研究更多的特性。 前瞻如果只是对完整源码感兴趣，您可以跳转到Github上：Android-ItemTouchHelper-Demo.本文即是基于第一次commit提交的代码。从这里下载演示APK。 配置我们需要的第一件事是配置基本的RecyclerView选项。如果你还没有准备好，更新您的build.gradle文件，包含RecyclerView依赖。 compile “com.android.support:recyclerview-v7:22.2.0” ItemTouchHelper可以和几乎所有RecyclerView.Adapter适配器和LayoutManager布局管理器交互，但文章将会基于下面的Gist创建基本文件： https://gist.github.com/iPaulPro/2216ea5e14818056cfcc 使用ItemTouchHelper和ItemTouchHelper.Callback为了使用ItemTouchHelper，需要先创建一个ItemTouchHelper.Callback接口。这个接口可以监听“移动”和“滑动”事件。您也可以通过它控制选择视图的状态，或者重写默认动画。作为一个辅助类，SimpleCallback回调方法可以为您提供一个基本的实现，但是如果要深入理解它的工作机制，我们需要创建一个自定义的辅助类。为了实现基本的“拖放”和“滑动消失”功能，以下的方法必须重写： getMovementFlags（RecyclerView，ViewHolder） onMove（RecyclerView，ViewHolder，ViewHolder） onSwiped（ViewHolder，int） 我们还会用到另外几个辅助方法： isLongPressDragEnabled() isItemViewSwipeEnabled() 下面我们将一个一个的来实现这些方法。 @Override public int getMovementFlags(RecyclerView recyclerView, RecyclerView.ViewHolder viewHolder) { int dragFlags = ItemTouchHelper.UP | ItemTouchHelper.DOWN; int swipeFlags = ItemTouchHelper.START | ItemTouchHelper.END; return makeMovementFlags(dragFlags, swipeFlags); } ItemTouchHelper可以让您轻松判断一个事件的方向。你必须重写getMovementFlags()方法来指定哪些拖放和滑动方向是RecyclerView支持的。使用辅助方法ItemTouchHelper.makeMovementFlags(int, int)生成返回标记。在这里我们允许双向的拖放和滑动。 @Override public boolean isLongPressDragEnabled() { return true; } ItemTouchHelper可用于无滑动的拖拽（反之亦然），所以你必须指定你想要支持哪种方式。要实现长按RecyclerView Item子项激活starting drag(开始拖拽)事件必须从isLongPressDragEnabled()返回true值。 另外，ItemTouchHelper.startDrag(RecyclerView.ViewHolder)方法可以被“handler”调用以开始一个拖拽事件。我们在后文会进一步探讨。 @Override public boolean isItemViewSwipeEnabled() { return true; } 为了在视图中任何位置的触摸事件中启用滑动功能，只需从isItemViewSwipeEnabled()方法返回true。另外，通过调用ItemTouchHelper.startSwipe(RecyclerView.ViewHolder)方法可以手动启动一个拖拽事件。 接下来的两个方法，onMove()和onSwiped()需要在方法里通知负责更新基础数据的任何组件。所以首先我们要创建一个接口，使我们能够将这些事件回调传导至事件链。 public interface ItemTouchHelperAdapter { void onItemMove(int fromPosition, int toPosition); void onItemDismiss(int position); } ItemTouchHelperAdapter.java Gist 对于本例来说，最简单的方法就是让RecyclerListAdapter类实现监听接口。 public class RecyclerListAdapter extends RecyclerView.Adapter&lt;ItemViewHolder implements ItemTouchHelperAdapter { // ... code from [gist](https://gist.github.com/iPaulPro/2216ea5e14818056cfcc#file-recyclerlistadapter-java) @Override public void onItemDismiss(int position) { mItems.remove(position); notifyItemRemoved(position); } @Override public boolean onItemMove(int fromPosition, int toPosition) { if (fromPosition &lt; toPosition) { for (int i = fromPosition; i &lt; toPosition; i++) { Collections.swap(mItems, i, i + 1); } } else { for (int i = fromPosition; i toPosition; i--) { Collections.swap(mItems, i, i - 1); } } notifyItemMoved(fromPosition, toPosition); return true; } 调用notifyItemRemoved()和notifyItemMoved()方法非常重要，这样适配器就能知道Item的变化。同样重要的是要注意，每次改变Item的位置，视图都会形成新的索引，而不是在“拖拽”事件结束时才修改索引。 现在，我们可以创建SimpleItemTouchHelperCallback类，因为我们仍然必须重写onMove()和onSwiped()方法。首先为适配器添加一个构造函数和适一个字段： private final ItemTouchHelperAdapter mAdapter; public SimpleItemTouchHelperCallback( ItemTouchHelperAdapter adapter) { mAdapter = adapter; } 然后重写剩下的方法以及通知适配器Item的改变。 @Override public boolean onMove(RecyclerView recyclerView, RecyclerView.ViewHolder viewHolder, RecyclerView.ViewHolder target) { mAdapter.onItemMove(viewHolder.getAdapterPosition(), target.getAdapterPosition()); return true; } @Override public void onSwiped(RecyclerView.ViewHolder viewHolder, int direction) { mAdapter.onItemDismiss(viewHolder.getAdapterPosition()); } 下面为生成的Callback类： public class SimpleItemTouchHelperCallback extends ItemTouchHelper.Callback { private final ItemTouchHelperAdapter mAdapter; public SimpleItemTouchHelperCallback(ItemTouchHelperAdapter adapter) { mAdapter = adapter; } @Override public boolean isLongPressDragEnabled() { return true; } @Override public boolean isItemViewSwipeEnabled() { return true; } @Override public int getMovementFlags(RecyclerView recyclerView, ViewHolder viewHolder) { int dragFlags = ItemTouchHelper.UP | ItemTouchHelper.DOWN; int swipeFlags = ItemTouchHelper.START | ItemTouchHelper.END; return makeMovementFlags(dragFlags, swipeFlags); } @Override public boolean onMove(RecyclerView recyclerView, ViewHolder viewHolder, ViewHolder target) { mAdapter.onItemMove(viewHolder.getAdapterPosition(), target.getAdapterPosition()); return true; } @Override public void onSwiped(ViewHolder viewHolder, int direction) { mAdapter.onItemDismiss(viewHolder.getAdapterPosition()); } } SimpleItemTouchHelperCallback.java hosted with ❤ by GitHub view raw CallBack类准备好了之后，我们就可以创建ItemTouchHelper类对象以及调用attachToRecyclerView(RecyclerView)方法了（详细请看MainFragment.java）: ItemTouchHelper.Callback callback = new SimpleItemTouchHelperCallback(adapter); ItemTouchHelper touchHelper = new ItemTouchHelper(callback); touchHelper.attachToRecyclerView(recyclerView); 运行程序，效果如下图： 结论这是ItemTouchHelper辅助类的一个最基础的实现。但是，应该清楚的是，要实现RecylerView基本的“拖放”和“滑动消失”效果是没有必要使用第三方库的。在接下来的部分，我们将研究如何在Item被拖拽或滑动时更好地控制Item的外观。 源码我在Github上创建了一个项目来展示本系列文章所讲的内容：Android-ItemTouchHelper-Demo。第一次commit的代码对应于以上部分，另外也有一点会在本文第2部分论述。 接下来第二部分：Handles, Grids, and Custom Animations Follow me on Google+ and Twitter © 2015 Paul Burke All code appearing in this article is licensed under Apache 2.0 Some rights reserved by the author. TAG : Android App DevelopmentAndroid]]></content>
      <tags>
        <tag>RecyclerView</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SHRINK APPS WITH GRADLE FOR-ANDROID]]></title>
    <url>%2F2016%2F07%2F11%2F2016-08-11-SHRINK-APPS-WITH-GRADLE-FOR-ANDROID%2F</url>
    <content type="text"><![CDATA[原文 SHRINK APPS WITH GRADLE FOR ANDROID通过Gradle构建工具压缩Android应用作者：David Tiago Conceição 译者：Waylan Punch It is almost impossible to write a good Android App without using many libraries. Several features like networking, image loading, caching, database operations, social networking and many others can be very easily incorporated with libraries from different sources. That makes development much easier and faster, but also bring some consequences. 要编写出好的Android应用程序，需要使用许多库文件。有些功能，如网络连接，图像加载，缓存，数据库操作，社交网络等等，可以与不同源的库文件很轻易地结合使用。这使得开发更加容易和快捷，同时也带来了一些后果。 The problemEvery library added to a project brings many possibilities and features. To achieve that, the libraries usually contain a lot of code files and resources. Almost every library I use contain more features than what I need. That creates a sort of waste: my applications have a lot of stuff that are never actually used. More than that, the size of the packages is growing in a fast pace. One of the apps I have been working reached 6.5MB recently. That’s a lot, I can do better. 问题每一个加载到项目中的库文件会带来了许多可能性和功能。为了实现这些功能，库文件通常包含大量的代码文件和资源。几乎每一个我使用的库文件都包含了更多我用不到的特性。这就造成了一种浪费：我的应用程序有很多的东西都没有在程序中使用到。不止如此，包文件的大小其实增长的很快。我最近开发的一个APP达到6.5MB。这就有点大了，我可以压缩一些。 That’s a big apk.(太大) Enters GradleThe Android plugin for Gradle has some nice features to improve the applications. One of those is the option to minify the source code. With this option enabled, the source code will be decreased by the reduction of the identifiers and deletion of unused parts. The source will also be obfuscated, making harder do read if it gets decompiled. Let’s enable it on the build.gradle. 进入Gradle构建工具Gradle的Android插件有一些不错的功能，可以改善应用程序。其中之一就是缩小的源代码的大小。启用该选项后，源代码将通过减少不必要的标识符和删除未使用的部分减小尺寸。也可以通过这个插件混淆代码，使得源代码在被反编译后更难阅读。接下来我们在build.gradle文件中启用此功能。 //... buildTypes { release { minifyEnabled true proguardFiles getDefaultProguardFile(&apos;proguard-android.txt&apos;), &apos;proguard-rules.pro&apos; signingConfig signingConfigs.release } //... The result is a 6.0MB apk. That’s a good start. build之后大小变成6.0MB。效果还不错。 A bit better.(稍微小了点) Resource ShrinkAnother cool option from Android Gradle is the resource shrink. When this option is enabled, unused resources are removed from the final apk, reducing it’s size. Let’s enable it: 资源压缩Android的Gradle插件另一个很酷的功能是资源文件的压缩。当启用该功能之后，未使用的资源文件将从最终的apk文件中删除，以减小apk的大小。接下来我们实际运用一下： release { minifyEnabled true shrinkResources true proguardFiles getDefaultProguardFile(&apos;proguard-android.txt&apos;), &apos;proguard-rules.pro&apos; signingConfig signingConfigs.release } The result is, well, disappointing. 结果有点令人失望。 No changes in file size.(大小没有改变) Reading a little further in the resource shrink technical doc, there are some options to make the shrink more aggressive. In the case of the application I am working, the option resConfigs did a very good job. By creating a list of the resources configuration used by the application, the tool can eliminate more things. 我们再来深读一下Android官网上关于资源压缩的技术文档，还有一些选项可以进一步压缩。以我开发的这个App为例， resConfigs选项产生了很好的效果。通过创建应用程序所使用的资源配置的列表，该工具可以削减更多的东西。 resConfigs &quot;en&quot;, &quot;pt&quot; resConfigs &quot;nodpi&quot;, &quot;hdpi&quot;, &quot;xhdpi&quot;, &quot;xxhdpi&quot;, &quot;xxxhdpi&quot; Better now.(稍小了一些) By decreasing source code size and removing unused resources, the apk was reduced from 6.5MB to about 5MB. That’s a good improvement. 通过减小源代码的尺寸和删除未使用的资源，我将APK从6.5MB减少到大约5MB。这是一个极大的提升。 But not that fastOne of the reasons that make some people disable the minify option and, by consequence, the shrink option is that it can create runtime issues. In the case of my application, gson wasn’t enable to convert the JSON data returned by the server. To make that work, I had to add a big set of the instructions to my proguard-rules.pro file. The initial set can be found at the gson repository. To complete the set, I had to make the tools ignore (or keep) the classes used with gson: 先别急着乐从某种意义上来讲，压缩功能会导致运行时异常，这就是禁止开发者启用压缩选项的原因之一。以我的App为例，GSON没法转换从服务器返回的JSON数据。为了使GSON工作，我不得不在proguard-rules.pro文件中添加一系列的指令集。初始设置可以在GSON库中找到。为了完成设置，我不得不让这些工具忽略（或保留）使用到的GSON类： -keep class com.package.model.** { *; } The libraries also have it’s own configurations. Glide has the instructions detailed in their page. Okio, that is used in a indirect way, works ignoring the warnings: 库文件也有自己的配置。Glide在他们的主页有详细说明。Okio，以一种间接的方式，忽略警告来工作： -dontwarn okio.** SnappyDB is more tricky: SnappyDB更棘手： -dontwarn sun.reflect.** -dontwarn java.beans.** -keep,allowshrinking class com.esotericsoftware.** { &lt;fields&gt;; &lt;methods&gt;; } -keep,allowshrinking class java.beans.** { *; } -keep,allowshrinking class sun.reflect.** { *; } -keep,allowshrinking class com.esotericsoftware.kryo.** { *; } -keep,allowshrinking class com.esotericsoftware.kryo.io.** { *; } -keep,allowshrinking class sun.nio.ch.** { *; } -dontwarn sun.nio.ch.** -dontwarn sun.misc.** -keep,allowshrinking class com.snappydb.** { *; } -dontwarn com.snappydb.** In the end, there is no choice besides searching for the specific configurations to each library. The point here is to pay attention to each of those configurations. One of the suggestions to make SnappyDB work recommended to disable the resource shrink. That’s is something that won’t happen :) Every time you change one of those options, check the final size again and look for potential runtime errors. 最后，除了为每个库文件搜索特定的配置，别无其他捷径。其中的关键是要注意每个配置。为了使SnappyDB工作，我的建议是，禁用资源收缩功能。这是不可能的事情:) 每次你更改某些配置之后，要检查一下apk文件的最终大小，然后再寻找潜在的运行时错误。 Going furtherThe apk size probably can be more compressed. At some moment I will go deeper, following the instructions presented by Cyril Mottier in his blog. That will certainly takes more time than adjusting some build files as I did. The result from the adjusts in build files, in the other hand, was very good. Removing 1.5MB of unused stuff from your final APK is certainly a good thing. From now on, minify and shrink configurations are my default choices and will certainly be very savy. 未来展望APK大小应该能进一步压缩。有时我会按照Cyril Mottier在他的博客里的指导作更深的研究。这肯定会花费多一些时间来调整一些构建文件。调整构建文件的结果从某方面来讲，还是非常不错的。从最终的apk文件中删除了1.5MB的资源文件肯定是一件好事。从现在开始，压缩配置会是我的默认操作，肯定会很牛逼。 Some rights reserved by the author. 作者拥有本文部分版权 TAGs ： Android, Gradle, Android Development]]></content>
      <tags>
        <tag>Gradle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[颜色转换工具类]]></title>
    <url>%2F2016%2F07%2F03%2F2016-07-19-aColorUtil%2F</url>
    <content type="text"><![CDATA[颜色转换工具类 import java.util.regex.Pattern; import android.graphics.Color; public class ColorUtil { /** * 获取资源中的颜色转换成16进制 * @param color * @return */ public static int getResourcesColor(int colorid) { int ret = 0x00ffffff; try { ret = MyApp.getContext().getResources().getColor(colorid); } catch (Exception e) { } return ret; } /** * 将十六进制 颜色代码 转换为 int * * @return */ public static int HextoColor(String color) { // #ff00CCFF String reg = &quot;#[a-f0-9A-F]{8}&quot;; if (!Pattern.matches(reg, color)) { color = &quot;#00ffffff&quot;; } return Color.parseColor(color); } /** * 修改颜色透明度 * @param color * @param alpha * @return */ public static int changeAlpha(int color, int alpha) { int red = Color.red(color); int green = Color.green(color); int blue = Color.blue(color); return Color.argb(alpha, red, green, blue); } }]]></content>
  </entry>
  <entry>
    <title><![CDATA[RecyclerView滑动显示/隐藏控件]]></title>
    <url>%2F2016%2F07%2F03%2F2016-07-17-RecyclerViewScrollToHide%2F</url>
    <content type="text"><![CDATA[复写RecyclerView.OnScrollListener监听事件，使RecyclerView具有滑动显示/隐藏功能import android.support.v7.widget.LinearLayoutManager; import android.support.v7.widget.RecyclerView; /** * Created by pc on 2016/7/1. */ public abstract class HidingScrollBottomListener extends RecyclerView.OnScrollListener { private static final int HIDE_THRESHOLD = 20;//滑动隐藏的阈值 private int mScrolledDistance = 0;//滑动距离 private boolean mControlsVisible = true;//控件的显示状态 /** * 向下滑动隐藏控件, 向上滑动显示控件 * dy, 向下滑动为正值, 向上滑动为负值 */ @Override public void onScrolled(RecyclerView recyclerView, int dx, int dy) { super.onScrolled(recyclerView, dx, dy); int firstVisibleItem = ((LinearLayoutManager) recyclerView.getLayoutManager()).findFirstVisibleItemPosition(); if (firstVisibleItem == 0) {//如果已经滑动到最顶端 if(!mControlsVisible) { onShow(); mControlsVisible = true; } } else {//当前Item不是第一条 if (mScrolledDistance &gt; HIDE_THRESHOLD &amp;&amp; mControlsVisible) {//向下滑动 onHide(); mControlsVisible = false; mScrolledDistance = 0; } else if (mScrolledDistance &lt; -HIDE_THRESHOLD &amp;&amp; !mControlsVisible) {//向上滑动 onShow(); mControlsVisible = true; mScrolledDistance = 0; } } if((mControlsVisible &amp;&amp; dy&gt;0) || (!mControlsVisible &amp;&amp; dy&lt;0)) { mScrolledDistance += dy; } } public abstract void onHide();//在onHide()方法里面实现控件隐藏功能 public abstract void onShow();//在onShow()方法里面实现控件显示功能 } 使用自定义滑动监听事件HidingScrollBottomListenerrecyclerView.addOnScrollListener(new HidingScrollBottomListener() { @Override public void onHide() { hideViews(); } @Override public void onShow() { showViews(); } }); private void hideViews() { FrameLayout.LayoutParams lp = (FrameLayout.LayoutParams) fab.getLayoutParams();//获取控件的布局参数 int fabBottomMargin = lp.bottomMargin;//与父控件的底部间隔 fab.animate()//动画 .translationY(fab.getHeight() + fabBottomMargin)//Y轴上的变换高度 .setInterpolator(new AccelerateInterpolator(2))//播放速度 .start(); } private void showViews() { fab.animate() .translationY(0) .setInterpolator(new DecelerateInterpolator(2)) .start(); }]]></content>
      <tags>
        <tag>RecyclerView</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android Code Standard]]></title>
    <url>%2F2016%2F07%2F03%2F2016-07-25-AndroidCodeStandard%2F</url>
    <content type="text"><![CDATA[An Android Code Standard Document, It’s A Public Resource, You Might Find It On My Company’s Home Site Or Not. 1.避免坏习惯1.1 代码重复几乎是最常见的坏习惯 代码重复往往来自于copy-and-paste的编程风格。 1.2 代码很长的方法 一个方法应当具有自我独立的意图，不要把几个意图放在一起。 1.3 大类 就是把太多的责任交给一个类，应该是一个类一个责任，这个和长方法相似。 1.4 一起出现在很多类的成员变量中，一起出现在许多方法的参数中… 这些数据或许应该自己独立形成对象。 1.5 一个干活不多的类 类的维护需要额外的开销，如果一个类承担了太少的责任，应当消除它。 1.6 一个类实现了从未用到的功能和通用性 通常这样的类或方法唯一的用户是testcase。不要犹豫，删除它。 1.7 一个对象的属性可能只在某些情况下才有意义 这样的代码将难以理解。专门建立一个对象来持有这样的孤儿属性，把只和他相关的行为移到该类。最常见的是一个特定的算法需要某些只有该算法才有用的变量。 1.8 做相同事情的方法有不同的函数 一致把它们往类层次上移，直至协议一致。 1.9 对象包括状态和行为 如果一个类只有状态没有行为，那么肯定有什么地方出问题了。 1.10 经常觉得要写很多注释才能解释你的代码 如果这种感觉太多，表示你需要重构。 2.命名规范2.1 包命名 范围： 适用于包（package）的命名 命名规范： 一个唯一包名的前缀总是全部小写的 ASCII 字母并且是一个顶级域名，通常是 com，edu，gov，mil，net，org。 Ø 例如： 顶级域名.公司名.项目名.*（模块） com.hengtiansoft.mobiledemo. 2.2 类和接口命名 范围： 适用于类（class）和接口（interface）的命名 命名规范： 类名是个一名词，采用大小写混合的方式，每个单词的首字母大写。类名应简洁而富于描述。使用完整单词，避免缩写词（除非该缩写词被更广泛使用，像 URL，HTML），接口一般要使用able、ible、er等后缀。 Ø 例如： classUserHomeActivity classIOUtils interfaceUserClickListener 规约：类名必须使用驼峰规则，即首字母必须大写，如果为词组，则每个单词的首字母也必须要大写，类名必须使用名字，或名词词组。要求类名简单，不允许出现无意义的单词(如classXXXActivity)。 2.3 异常命名 范围： 适用于自定义异常（Exception）的命名 命名规范： 自定义异常的命名必须以Exception为结尾。 Ø 例如： NetworkException AppException 2.4 方法命名 范围： 适用于方法（method）的命名 命名规范： 方法名是一个动词，采用大小写混合的方式，第一个单词的首字母小写，其后单词的首字母大写。 类的获取方法（一般具有返回值）一般要求在被访问的字段名前加上get，如getFirstName ()，getLastName()。 类的设置方法（一般返回类型为void）：被访问字段名的前面加上前缀 set，如setFirstName()，setLastName()。 类的布尔型的判断方法一般要求方法名使用单词is做前缀，如isNetWorkConnected()，isString()。 类的普通方法一般采用完整的英文描述说明成员方法功能，第一个单词尽可能采用动词，首字母小写，如openFile()，addCount()。 构造方法应该用递增的方式写。（参数多的写在后面） Ø 例如： publicintgetId() private void doBack() 2.5 变量命名 范围： 适用于Java代码中。在模型（model）或者bean对象中，成员变量命名可不遵循下述规范，直接使用小写字母开头。 命名规范： 第一个单词的首字母小写，其后单词的首字母大写。 非公有，非静态的变量以 m开头。 静态变量以s开头。 其他变量以小写字母开头。 公有静态最终（public static final）变量全大写并用下划线“_”分隔。 Ø 例如： public class MyClass { public static final int SOME_CONSTANT = 42; publicintpublicField; private static MyClasssSingleton; intmPackagePrivate; privateintmPrivate; protectedintmProtected; } 2.6 Android控件变量命名 范围： 适用于Java代码的Android控件命名。 命名规范： [控件缩写_描述] //首先应满足上述的变量命名规范。 Ø 例如： private Button mBtnLogin privateLinearLayoutmLlytMainContainer publicAlertDialogalertConfirm; 2.7 Layout命名2.7.1 Layout文件命名 范围： 应用于在res/layout目录下的文件。 命名规范： [类型_描述] 类型：使用该文件的对象的类型，如果需要多个单词则直接合并，不使用“_”分隔 描述：描述该文件的功能，使用“-”分隔每个单词 layout xml的命名必须以 全部单词小写，单词间以”_”分割，并且使用名词或名词词组，即使用 模块名功能名称 来命名。 Ø 例如: activity\_main.xml fragment\_title.xml dialog\_cancel\_confirm.xml listitem\_game.xml popup\_user\_info.xml 2.7.2 Layout文件中的id命名 范围： 应用于在res/layout目录下的文件中的id命名。 命名规范： [控件缩写_描述] 控件缩写：该id所表示的控件的缩写 描述：描述该文件的功能，使用“_”分隔每个单词 layout中所使用的id必须以全部单词小写，单词间以下划线分割，并且使用名词或名词词组，并且要求能够通过id直接理解当前组件要实现的功能。 Ø 例如: @+id/tv\_name @+id/et\_first\_name @+id/llyt\_user\_info 资源命名 规约：layout中所使用的所有资源（如drawable,style等）命名必须以全部单词小写，单词间以下划线分割，并且尽可能的使用名词或名词组，即使用[模块名_用途] 来命名。如果为公共资源，如分割线等，则直接用用途来命名. 只能使用a-z,0-9,和“_”组成，并且不能单独使用数字作为资源名称。 2.8 图片命名 应用于res/drawable目录下的文件。该目录下可能存在静态图片文件，动态图片文件和选择器（selector），静态图片是指只有一种状态的图片，动态图片是指由多种状态的图片，例如按钮按下和放开时的不同状态图片，选择器是指包含动态图片组合的xml文件。 2.8.1 静态图片 范围： res/drawable目录下的静态图片，静态图片是指只有一种状态的图片，如背景图片、图标。 命名规范： [前缀模块]、[前缀模块_描述]、[描述] 前缀：类别的缩写（参照表 1 - 前缀） 模块：使用该文件的模块 描述：描述该文件的功能 Ø 例如： bg\_main.png ic\_feedback\_send.png menuitem\_save.png 2.8.2 动态图片 范围： res/drawable目录下的动态图片，静态图片是指只有多种状态的图片，如按钮（button）、状态图片、选择按钮（radio button）状态图片。 命名规范： [前缀_描述状态]、[前缀模块_描述_状态] 前缀：文件类别的缩写（参照表 1 - 前缀） 模块：使用该文件的模块 描述：描述该文件的功能 状态：该图片的所表示的状态（参照表 2 –后缀） Ø 例如： btn\_film\_buy\_nor.png btn\_film\_buy\_press.png btn\_back\_nor.png btn\_back\_press.png 2.8.3 选择器（selector） 范围： res/drawable目录下的选择器，选择器是指包含动态图片组合的xml文件。 命名规范： [前缀描述]、[前缀模块_描述] 前缀：类别的缩写（参照表 1 - 前缀） 模块：使用该文件的模块 描述：描述该文件的功能 Ø 例如： btn\_film\_buy.xml btn\_back.xml rbtn\_film.xml 2.8.9 动画文件命名 范围： res/anim文件夹下面，为一些动态效果文件 命名规范： [前缀描述]、[前缀模块_描述] 全部小写，采用下划线命名法，加前缀区分。（参照表4–动画） 前缀: 动画的类型 模块：使用该文件的模块 描述：动画的方向 Ø 例如： fade\_in.xml push\_down\_out.xml 表1 - 前缀 ic – icon：主要用于布局和子布局的图标bg – background：主要用于布局和子布局的背景div – divider：主要用于分隔线，不仅包括Listview中的还包括普通布局中的线btn – button：主要用于按钮的表示 表2 - 后缀 unit：在使用xml的tilemode来配图片时，element图片使用此后缀nor：图片的状态，代表普通状态hl：图片的状态，代表高亮状态press：图片的状态，代表按下状态select：图片的状态，代表其所占的view被选中unselect：图片的状态，代表其所占的view没有被选中 表3 - 组件缩写 Button：Btn(btn)RadioButton：Rbtn(rbtn)ImageButton：Ibtn(ibtn)TextView：Tv(tv)ImageView：Iv (iv)ListView：Lv(lv)ProgressBar：Pbar(pbar)EditText：Edtv(et)ScrollView：Sclv(scly)CheckBox：Chk(chk)RelativeLayout：Rlyt(rlyt)LinearLayout：Llyt(llyt)TableLayout：Tlyt(tlyt)AbsoluteLayout：ALyt(alyt)FrameLayout：Flyt(flyt)DigtalClock：DgtClk(dgtclk)analogClock：AnaClk(anaclk)DatePicker：DtPk(dtpk)TimePicker：TmPk(tmpk)ToggleButton：TgBtn(tgbtn)SeekBar：SkBar(skbar)AutoCompleteTextView：AutoTv(autotv)ZoomControls：ZmCtl(zmctl)VideoView：Vidv(vidv)WebView：Wv(wv)RantingBar：RtBr(rtbr)MapView：Mapv(mapv)Spinner：Spn(spn)Chronometer：Cmt(cmt)TextSwitch：TeSw(tesw)ImageSwitch：ImgSw(imgsw)ExpandableList：EpdLt(epdlt) 表4–常见动画文件命名 fade_in:淡入slide_in_from_top:从头部滑动进入fade_out:淡出zoom_enter:变形进入push_down_in:从下方推入slide_in:滑动进入push_down_out:从下方推出shrink_to_middle:中间缩小push_left:推向左方 2.9 Value命名2.9.1 color命名 如果是android系统有原生的，就用原生的颜色，譬如白色，黑色，透明，深灰，浅灰等 一般控件和背景色中都会用到的颜色，命名规则：颜色。例如 blue，dark_blue,sky_blue, sapphire_blue 多个界面某种控件会用到的颜色，命名规则：控件缩写_颜色。例如btn_blue 某个界面中专有控件会用到的颜色，命名规则：[控件缩写_模块_颜色]。例如txt_menu_light_blue, btn_title_blue 2.9.2 dimens命名 一些常量的常规定义,例如： &lt;dimen name=&quot;default\_padding\_0.5x&quot;&gt;5dp&lt;/dimen&gt; &lt;dimen name=&quot;default\_padding\_0.2x&quot;&gt;2dp&lt;/dimen&gt; &lt;dimen name=&quot;default\_padding\_1x&quot;&gt;10dp&lt;/dimen&gt; &lt;dimen name=&quot;default\_text\_size\_big&quot;&gt;18sp&lt;/dimen&gt; &lt;dimen name=&quot;default\_text\_size\_normal&quot;&gt;16sp&lt;/dimen&gt; 2.9.3 Strings命名 在多个界面中需要用到的字符串可放在各分类的normal下，例如normal分类可包括： &lt;!-- normal text --&gt; &lt;stringname=&quot;text\_null&quot;&gt;null&lt;/string&gt; &lt;stringname=&quot;text\_login&quot;&gt;登录&lt;/string&gt; &lt;!--nornal dialog --&gt; &lt;stringname=&quot;dialog\_loading&quot;&gt;数据加载中&amp;#8230;&lt;/string&gt; &lt;stringname=&quot;dialog\_tips&quot;&gt;提示&lt;/string&gt; &lt;!--nornmal toast --&gt; &lt;stringname=&quot;toast\_error\_404&quot;&gt;找不到服务器&lt;/string&gt; &lt;stringname=&quot;toast\_server\_error&quot;&gt;系统繁忙，请稍后再试&lt;/string&gt; 若只在一个界面中用到，可放在各自activity或者fragment注释下，命名规则仍旧遵循normal的格式，该显示在dialog中，name就以dialog开头，是显示hint的，用hint开头，后面加上模块描述：例如： &lt;!-- title --&gt; &lt;stringname=&quot;hint\_title\_search\_key&quot;&gt;搜索关键字&lt;/string&gt; &lt;stringname=&quot;text\_title\_notification&quot;&gt;通知&lt;/string&gt; &lt;!-- login activity --&gt; &lt;stringname=&quot;hint\_login\_email&quot;&gt;邮箱地址&lt;/string&gt; &lt;!-- change pwd activity --&gt; &lt;stringname=&quot;text\_change\_pwd\_old\_pwd&quot;&gt;旧密码&lt;/string&gt; 3.代码规范3.1 通用规范3.1.1 变量赋值 避免在一个语句中给多个变量赋相同的值。它很难读懂。如下面例子。 不推荐： fooBar.fChar = barFoo.lchar = &apos;c&apos; 推荐: fooBar.fChar = &apos;c&apos; barFoo.lchar = &apos;c&apos; 不要将赋值运算符用在容易与相等关系运算符混淆的地方。 不推荐： if (c++ = d++) { // (Java disallows) ... } 推荐: if ((c++ = d++) != 0) { ... } 不要使用内嵌(embedded)赋值运算符试图提高运行时的效率，这是编译器的工作。 不推荐： d = (a = b + c) + r; 推荐: a = b + c; d = a + r; 3.1.2 圆括号 一般而言，在含有多种运算符的表达式中使用圆括号来避免运算符优先级问题。 不推荐： if (a == b &amp;&amp; c == d) x &gt;= 0 ?x : -x 推荐: if ((a == b) &amp;&amp; (c == d)) (x &gt;= 0) ?x : -x 3.1.3 返回值 设法让你的程序结构符合目的。 不推荐： if (booleanExpression) { return true; } else { return false; } if (condition) { return x; } return y; 推荐: returnbooleanExpression; return (condition ? x : y); 3.2 注释 Java 程序有两类注释：实现注释（implementation comments）和文档注释（document，comments）。实现注释是使用/…/和//界定的注释。文档注释（被称为”doc comments”），由/*…/界定。 3.2.1 文件注释 所有的源文件都应该在开头有一个注释，其中列出类名、版本信息、日期和版权声明。如下： /* * 文件名 * 包含类名列表 * 版本信息，版本号 * 创建日期 * 版权声明 / 3.2.2 类注释 每一个类都要包含如下格式的注释，以说明当前类的功能等。 /* * 类名 * @author 作者 * 实现的主要功能。 * 创建日期 * 修改者，修改日期，修改内容。 */ 3.2.3 方法注释 每一个方法都要包含如下格式的注释包括当前方法的用途，当前方法参数的含义，当前方法返回值的内容和抛出异常的列表。 /* * 方法的一句话概述 * 方法详述（简单方法可不必详述） * @params说明参数含义 * @return 说明返回值含义 * @throws IOException说明发生此异常的条件 * @throws NullPointerException说明发生此异常的条件 / 3.2.4 类成员变量和常量注释 成员变量和常量需要使用java doc形式的注释，以说明当前变量或常量的含义。 /* * XXXX含义 / 3.2.5 其他注释 方法内部的注释如果为多行，使用/„„ /形式，如果为单行，使用//„„形式的注释。不要再方法内部使用 java doc 形式的注释“/*„„**/”。 3.3 Log规范 Log所打印出来的信息应具有可读性，不要打印只有自己能看懂的log，例如“1”、“Finish”等。 不推荐： Log.d(&quot;MainActivity&quot;, &quot;success&quot;); Log.d(TAG, &quot;1&quot;); 推荐: Log.d(&quot;MainActivity&quot;, &quot;Get user info successfully&quot;); Log.d(TAG, &quot;Search finished. Get user id: 1&quot;); 使用规范的log分类，例如调试的信息使用DEBUG，错误的信息使用ERROR。 注意发布版本的log中不能打印敏感信息，防止隐私泄漏。 临时的用来调试的log应尽量使用DEBUG 和VERBOSE。 4.代码格式化4.1在Eclipse中导入Formatter和Importor4.1.1 注释模板 preferences 中，选择 java → code style → formatter 中选择 Import，选择formatter.xml。 4.1.2 添加文件创建日志模板 preferences 中，选择 java → code style → code Template 中选择 &gt;Import，选择codetemplates.xml。但是注意修改类注释和文件注释的作者名称为自己的。 4.1.3 XML格式化： preferences中，选择xml → xml files→ xml editor中做如下设置。 4.2 在Android studio中导入Formatter和Importor4.2.1 注释模板： 在Android studio的File中，选择Settings，点击Editor → File and Code Templates → Includes→ File Header。 4.2.2 Android Studio设置代码风格 在Android studio的File中，选择Settings，然后搜索CodeStyle选择Java进入如下界面搜索java，进入Code Style 中的java设置如下编码风格。 5.推荐规范5.1 一个方法尽量不要超过15行。 如果方法太长，说明当前方法业务逻辑已经非常复杂，那么就需要进行方法拆分，保证每个方法只作一件事。 5.2 代码中不允许出现单独的数字，字符！ 如果需要使用数字或字符，则将它们按照含义封装为静态常量！（for语句中除外） 5.3 所有if 语句最好用{}包括起来,即便是只有一句： 推荐: if (true){ //do something...... } 不推荐: if (true) i = 0; 5.4 对于循环 推荐: //将操作结构保存在临时变量里，减少方法调用次数 final int count = products.getCount(); while(index &lt; count){ } 不推荐: while(index &lt;products.getCount()){ //每此都会执行一次getCount()方法， //若此方法耗时则会影响执行效率 //而且可能带来同步问题，若有同步需求，请使用同步块或同步方法 } 5.5 控制访问 若没有足够理由，不要把实例或类变量声明为公有。通常，实例变量无需显式的设置(set)和获取(gotten)，通常这作为方法调用的边缘效应 (side effect)而产生。 一个具有公有实例变量的恰当例子，是类仅作为数据结构，没有行为。亦即，若你要使用一个结构(struct)而非一个类(如果java 支持结构的话)，那么把类的实例变量声明为公有是合适的。]]></content>
      <tags>
        <tag>Standard</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Collection接口与Collections类]]></title>
    <url>%2F2016%2F07%2F03%2F2016-07-03-collectionandcollections%2F</url>
    <content type="text"><![CDATA[Collection接口与Collections类 [1]java.util.Collection 是一个集合接口。它提供了对集合对象进行基本操作的通用接口方法。Collection接口在Java 类库中有很多具体的实现。Collection接口的意义是为各种具体的集合提供了最大化的统一操作方式。 [2]java.util.Collections 是一个包装类。它包含有各种有关集合操作的静态多态方法。此类不能实例化，就像一个工具类，服务于Java的Collection框架。 //注意List是实现Collection接口的 List list = new ArrayList(); double array[] = { 112, 111, 23, 456, 231 }; for (int i = 0; i &lt; array.length; i++) { list.add(new Double(array[i])); } Collections.sort(list); for (int i = 0; i &lt; array.length; i++) { System.out.println(list.get(i)); }]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ArrayList通过ensureCapacity方法提高效率]]></title>
    <url>%2F2016%2F07%2F03%2F2016-07-03-ensureCapacity%2F</url>
    <content type="text"><![CDATA[每个 ArrayList 实例都有一个容量。该容量是指用来存储列表元素的数组的大小。它总是至少等于列表的大小。随着向 ArrayList 中不断添加元素，其容量也自动增长。并未指定增长策略的细节，因为这不只是添加元素会带来分摊固定时间开销那样简单。 在添加大量元素前，应用程序可以使用 ensureCapacity 操作来增加 ArrayList 实例的容量。这可以减少递增式再分配的数量。 public static void main(String[] args){ final int N = 1000000; Object obj = new Object(); //没用调用ensureCapacity()方法初始化ArrayList对象 ArrayList list = new ArrayList(); long startTime = System.currentTimeMillis(); for(int i=0;i&lt;=N;i++){ list.add(obj); } long endTime = System.currentTimeMillis(); System.out.println(&quot;没有调用ensureCapacity()方法所用时间：&quot; + (endTime - startTime) + &quot;ms&quot;); //调用ensureCapacity()方法初始化ArrayList对象 list = new ArrayList(); startTime = System.currentTimeMillis(); list.ensureCapacity(N);//预先设置list的大小 for(int i=0;i&lt;=N;i++){ list.add(obj); } endTime = System.currentTimeMillis(); System.out.println(&quot;调用ensureCapacity()方法所用时间：&quot; + (endTime - startTime) + &quot;ms&quot;); }]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[安装AndroidStudioSuperPlugin插件]]></title>
    <url>%2F2016%2F06%2F07%2F2016-06-17-AndroidStudioSuperPlugin%2F</url>
    <content type="text"><![CDATA[AndroidStudioSuperPlugin是一个集成插件，包含若干子插件： 使用Lifecycle Sorter子插件：]]></content>
      <tags>
        <tag>Plugin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeanCloud Learning Course]]></title>
    <url>%2F2016%2F06%2F05%2F2016-06-05-leanCloud-learning%2F</url>
    <content type="text"><![CDATA[获取第一行 AVQuery&lt;Studentq = AVObject.getQuery(Student.class); Student student = q.getFirst(); 根据已有ObjectID获取数据 Student student = AVObject.createWithoutData(Student.class, &quot;objectId&quot;); AVObject fetched = student.fetch(); 保存文件 AVFile avatar = new AVFile(&quot;avatar&quot;, getAvatarBytes()); Student student = new Student(); student.setName(&quot;name&quot;); student.setAvatar(avatar); student.save(); 序列化 //将对象序列化成字符串 Student student = getFirstStudent(); String s = student.toString(); //从字符串中解析对象 AVObject parseObject = AVObject.parseAVObject(s); AVObject已经实现了Parcelable接口 public class AVObject implements Parcelable { ...... } ...... Intent intent = new Intent(); intent.putExtra(&quot;student&quot;, student); Student intentStudent = intent.getParcelableExtra(&quot;student&quot;); 离线保存对象 public void saveEventually(SaveCallback callback) { ...... } ...... Student student = new Student(); student.setName(&quot;testOfflineSave&quot;); student.saveEventually(); 适用于用户并不关心具体保存到服务器的具体时间，或者数据并不需要时常与服务器发生交互时，可以使用本方法 在网络请求遇到异常时，AVOS Cloud会将此类请求保存到本地，等到网络回复正常或者排除故障以后再发送请求 被保存下来的请求会按照初始的发送顺序进行发送由于保存的时间无法确定，回调发生时可能已经超出了原来的运行环境，即便发生也没有意义，所以不鼓励用户saveEventually中传入callback 整形字段的自增方法 student.increment(&quot;age&quot;, 1); student.save(); any字段可以存储任意类型 //Any 字段保存为了数字 student.setAny(1); student.save(); //Any 字段保存为了字符串 student.setAny(&quot;hello&quot;); student.save(); //Any 字段保存为了Map HashMap&lt;String, Object&gt; map = new HashMap&lt;&gt;(); map.put(&quot;like&quot;, &quot;swimming&quot;); student.setAny(map); student.save(); student.getAny() 讲某个字段所有数据置空 student.remove(&quot;age&quot;); student.save(); ARRAY类型字段添加或移除数据 List&lt;String&gt; hobbies = new ArrayList&lt;&gt;(); hobbies.add(&quot;running&quot;); hobbies.add(&quot;fly&quot;); student.addAll(&quot;hobbies&quot;, hobbies); student.save(); ...... student.add(&quot;hobbies&quot;, &quot;swimming&quot;); student.save(); ...... List&lt;String&gt; removeHobbies = new ArrayList&lt;&gt;(); removeHobbies.add(&quot;swimming&quot;); student.removeAll(&quot;hobbies&quot;, removeHobbies); student.save(); ...... //添加唯一数据，存在就覆盖，保证唯一性 student.addUnique(&quot;hobbies&quot;, &quot;swimming&quot;); student.save(); 添加多条数据，批量保存 List&lt;Student&gt; students = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; 5; i++) { Student student = new Student(); student.setName(i + &quot;&quot;); student.setAge(i + 10); students.add(student); } AVObject.saveAll(students); ...... List&lt;Student&gt; students = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; 5; i++) { Student student = new Student(); student.setName(i + &quot;&quot;); AVFile avatar = new AVFile(&quot;avatar&quot; + i, getAvatarBytes()); student.setAvatar(avatar); students.add(student); } AVObject.saveAll(students); 修改多条数据，批量修改 for (Student student : students) { student.setName(&quot;testBatchUpdate&quot;); } AVObject.saveAll(students); 删除多条数据，批量删除 AVObject.deleteAll(students); 从ARRAY类型字段获取数据 AVObject myObject = new AVObject(&quot;Student&quot;);//新建AVObject对象会自动生成ObjectID for (int i = 0; i &lt; 5; ++i) { myObject.add(&quot;array&quot;, i); } myObject.save(); AVQuery&lt;AVObject&gt; query = AVQuery.getQuery(&quot;Student&quot;); AVObject result = query.get(myObject.getObjectId()); List&lt;Number&gt; array = result.getList(&quot;array&quot;); 查询全部数据 AVQuery&lt;Student&gt; query = AVQuery.getQuery(Student.class); List&lt;Student&gt; students = query.find(); 获取第一条记录 Student student = query.getFirst(); 限制记录行数 query.limit(2); List&lt;Student&gt; students = query.find(); 递减，降序 query.orderByDescending(&quot;createdAt&quot;); query.skip(3); Student first = query.getFirst(); 递增，升序 query.orderByAscending(&quot;createdAt&quot;).limit(5); 条件查询，AND查询 query.whereNotEqualTo(Student.NAME, &quot;Mike&quot;); // 默认就是 And query.whereStartsWith(Student.NAME, &quot;M&quot;); 条件查询，OR查询 query1.whereEqualTo(Student.NAME, &quot;Mike&quot;); query2.whereStartsWith(Student.NAME, &quot;J&quot;); List&lt;AVQuery&lt;Student&gt;&gt; queries = new ArrayList&lt;&gt;(); queries.add(query1); queries.add(query2); AVQuery&lt;Student&gt; query = AVQuery.or(queries); List&lt;Student&gt; students = query.find(); 二次排序 query.orderByDescending(Student.NAME) .addDescendingOrder(Student.AGE) .limit(5); List&lt;Student&gt; students = query.find(); ARRAY类型字段的查询匹配 query.whereSizeEqual(&quot;hobbies&quot;, 2).limit(10); 某个字段的多条件匹配 //字符匹配 query.whereStartsWith(&quot;name&quot;, &quot;M&quot;) .whereEndsWith(&quot;name&quot;, &quot;e&quot;) .whereContains(&quot;name&quot;, &quot;i&quot;); ...... //包含其中之一 query.whereContainedIn(&quot;name&quot;, Arrays.asList(&quot;Mike&quot;, &quot;Jane&quot;)); List&lt;Student&gt; students = query.find(); ...... //全部包含 query.whereContainsAll(&quot;hobbies&quot;, Arrays.asList(&quot;swimming&quot;, &quot;running&quot;)); List&lt;Student&gt; students = query.find(); 通过正则表达式查询匹配 query.whereMatches(&quot;name&quot;, &quot;^M.*&quot;); 开启全局省流量模式 // 应该放在 Application 的 onCreate 中，开启全局省流量模式 AVOSCloud.setLastModifyEnabled(true); Student student = getFirstStudent(); // 此处服务器应该返回了所有数据 AVQuery&lt;Student&gt; q = AVQuery.getQuery(Student.class); Student student1 = q.get(student.getObjectId()); log(&quot;从服务器获取了对象：&quot; + prettyJSON(student1)); // 客户端把该对象的udpatedAt传给服务器，服务器判断对象未改变，于是返回 304 和空数据，客户端返回本地缓存的数据，节省流量 Student student2 = q.get(student.getObjectId()); ...... q.limit(5); // 此处服务器应该返回了所有数据 List&lt;Student&gt; students = q.find(); // 服务器记录表的修改时间，如果两次查询之间表未被修改且参数一样，则以下查询将从本地缓存获取数据 List&lt;Student&gt; students1 = q.find(); 设置查询策略，本地缓存或网络 AVQuery&lt;Student&gt; q = AVQuery.getQuery(Student.class); //1.CACHE_THEN_NETWORK //查询首先尝试从缓存中获取，然后再从网络获取。在这种情况下，FindCallback 会被实际调用两次： //首先是缓存的结果，其次是网络查询的结果。这个缓存策略只能用在异步的 findInBackground 方法中。 q.setCachePolicy(AVQuery.CachePolicy.CACHE_THEN_NETWORK); // 单位毫秒 q.setMaxCacheAge(1000 * 60 * 60); // 一小时 q.limit(1); q.findInBackground(new FindCallback&lt;Student&gt;() { int count = 0; @Override public void done(List&lt;Student&gt; list, AVException e) { if (count == 0) { log(&quot;第一次从缓存中获取了结果：&quot; + prettyJSON(list)); } else { log(&quot;第二次从网络获取了结果：&quot; + prettyJSON(list)); } count++; } }); ...... //2.CACHE_ELSE_NETWORK //查询首先尝试从缓存中获取，如果失败，则从网络获取，如果两者都失败，则引发一个 AVException。 q.setCachePolicy(AVQuery.CachePolicy.CACHE_ELSE_NETWORK); // 单位毫秒 q.setMaxCacheAge(1000 * 60 * 60); // 一小时 q.limit(1); if (q.hasCachedResult()) { log(&quot;有本地缓存，将从本地获取&quot;); } else { log(&quot;无本地缓存，将从服务器获取&quot;); } List&lt;Student&gt; students = q.find(); ...... //3.NETWORK_ELSE_CACHE //查询首先尝试从网络获取，如果失败，则从缓存中查找；如果两者都失败，则应发一个 AVException。 q.setCachePolicy(AVQuery.CachePolicy.NETWORK_ELSE_CACHE); // 单位毫秒 q.setMaxCacheAge(1000 * 60 * 60); // 一小时 q.limit(1); if (q.hasCachedResult()) { log(&quot;有本地缓存，无网络时将从本地获取&quot;); } else { log(&quot;无本地缓存，将从服务器获取&quot;); } ...... //4.NETWORK_ONLY //查询不走缓存，从网路中获取，但是查询结果会写入缓存。 q.setCachePolicy(AVQuery.CachePolicy.NETWORK_ONLY); // 单位毫秒 q.setMaxCacheAge(1000 * 60 * 60); // 一小时 q.limit(1); if (q.hasCachedResult()) { log(&quot;有本地缓存，但无视之&quot;); } else { log(&quot;无本地缓存，也无视之&quot;); } ...... //5.CACHE_ONLY //查询只从缓存获取，不走网络。如果缓存中没有结果，引发一个 AVException。 q.setCachePolicy(AVQuery.CachePolicy.CACHE_ONLY); // 单位毫秒 q.setMaxCacheAge(1000 * 60 * 60); // 一小时 q.limit(1); if (q.hasCachedResult()) { log(&quot;有本地缓存，将从本地获取结果&quot;); } else { log(&quot;无本地缓存，将抛出异常，请先运行上一个例子，从网络获取结果保存到本地&quot;); } ...... //6.IGNORE_CACHE //默认的缓存策略，查询不走缓存，查询结果也不存储在缓存。 log(&quot;此策略才网络获取结果，并不保存结果到本地&quot;); q.setCachePolicy(AVQuery.CachePolicy.IGNORE_CACHE); // 单位毫秒 q.setMaxCacheAge(1000 * 60 * 60); // 一小时 q.limit(1); 清除缓存 //清除当前查询缓存 AVQuery&lt;Student&gt; q = AVQuery.getQuery(Student.class); q.limit(1); q.clearCachedResult(); ...... //清除所有缓存 AVQuery.clearAllCachedResults(); log(&quot;已删除所有的缓存&quot;); whereMatchesKeyInQuery的使用，相应的有whereDoesNotMatchKeyInQuery //Add a constraint to the query that requires a particular key&apos;s value matches a value for a key in the results //of another AVQuery //当前查询的某个字段与另外一个查询的某个字段的值相匹配 AVQuery q1 = AVQuery.getQuery(&quot;Person&quot;); AVQuery q2 = AVQuery.getQuery(&quot;Something&quot;); q2.whereMatchesKeyInQuery(&quot;belongTo&quot;, &quot;name&quot;, q1); 注册用户 AVUser user = new AVUser(); user.setUsername(&quot;waylanpunch&quot;); user.setPassword(&quot;111111&quot;); user.signUp(); Assert.assertFalse(user.getObjectId().isEmpty()); String username = user.getUsername(); 登录 AVUser.logOut(); AVUser.logInInBackground(username, password, new LogInCallback&lt;AVUser&gt;() { @Override public void done(AVUser avUser, AVException e) { if (e != null) { log(e.getMessage()); } else { log(&quot;登录成功 user：&quot; + avUser.toString()); } } }); 当前已登录的用户 AVUser user = AVUser.getCurrentUser(); 注销当前已登录的用户 AVUser.logOut(); 删除当前已登录的用户 user.delete(); log(&quot;已删除当前用户&quot;); 修改用户数据 AVQuery&lt;AVUser&gt; q = AVUser.getQuery(); AVUser first = q.getFirst(); log(&quot;获取了一个用户，但未登录该用户&quot;); first.put(&quot;city&quot;, &quot;ShangHai&quot;); try { first.save(); } catch (AVException e) { if (e.getCode() == AVException.SESSION_MISSING) { log(&quot;尝试修改未登录用户的数据，发生错误：&quot; + e.getMessage()); } else { throw e; } } log(&quot;结论：不能修改未登录用户的数据&quot;); ...... //修改密码 user.updatePassword(oldPassword, newPassword); 验证注册用户手机号码 // 请在网站勾选 &quot;验证注册用户手机号码&quot; 选项，否则不会发送验证短信 final AVUser user = new AVUser(); user.setUsername(&quot;test&quot;); user.setPassword(&quot;test&quot;); user.setMobilePhoneNumber(&quot;15866778899&quot;); user.signUpInBackground(new SignUpCallback() { @Override public void done(AVException e) { if (e == null) { AVUser.verifyMobilePhoneInBackground(&quot;verifycode&quot;, new AVMobilePhoneVerifyCallback() { @Override public void done(AVException e) { if (e == null) { log(&quot;注册成功, user:&quot; + user); } } }); } } }); 输入手机号码+密码登录 AVUser.loginByMobilePhoneNumberInBackground(&quot;15866778899&quot;, demoPassword, new LogInCallback&lt;AVUser&gt;() { @Override public void done(AVUser avUser, AVException e) { if (e == null) { log(&quot;登录成功, user:&quot; + avUser); } } }); 输入手机号码+验证码登录 AVUser.requestLoginSmsCodeInBackground(&quot;15866778899&quot;, new RequestMobileCodeCallback() { @Override public void done(AVException e) { if (e == null) { AVUser.loginBySMSCodeInBackground(&quot;15866778899&quot;, smsCode, new LogInCallback&lt;AVUser&gt;() { @Override public void done(AVUser avUser, AVException e) { if (e == null) { log(&quot;登录成功, user: &quot; + avUser); } } }); } } }); 使用手机号码重置密码 AVUser.requestPasswordResetBySmsCodeInBackground(&quot;15866778899&quot;, new RequestMobileCodeCallback() { @Override public void done(AVException e) { if (e == null) { final String newPassword = &quot;abcdefg&quot;; AVUser.resetPasswordBySmsCodeInBackground(smsCode, newPassword, new UpdatePasswordCallback() { @Override public void done(AVException e) { if (e == null) { log(&quot;密码更改成功，新密码 &quot; + newPassword); log(&quot;试着用手机号和新密码登录吧&quot;); } } }); } } }); 邮箱验证 //请确认控制台已开启注册时开启邮箱验证，这样才能收到验证邮件 final AVUser user = new AVUser(); user.setUsername(text); user.setPassword(demoPassword); user.setEmail(text); user.signUpInBackground(new SignUpCallback() { @Override public void done(AVException e) { if (e == null) { log(&quot;注册成功，user: &quot; + user); } } }); 邮箱登录 AVUser.logInInBackground(&quot;waylanpunch@gmail.com&quot;, &quot;testpassword&quot;, new LogInCallback&lt;AVUser&gt;() { @Override public void done(AVUser avUser, AVException e) { if (e == null) { log(&quot;登录成功 user:&quot; + avUser); } } }); 使用邮箱进行密码重置 AVUser.requestPasswordResetInBackground(text, new RequestPasswordResetCallback() { @Override public void done(AVException e) { if (e == null) { log(&quot;重置密码的邮件已发送到邮箱 &quot; + text); } } }); 匿名登录 AVAnonymousUtils.logIn(new LogInCallback&lt;AVUser&gt;() { @Override public void done(AVUser avUser, AVException e) { if (e == null) { log(&quot;创建了一个匿名用户并登录，user:&quot; + avUser); } } }); 文件上传 //文件转换成字节数组 byte[] data = DemoUtils.readFile(file); final AVFile avFile = new AVFile(file.getName(), data); avFile.saveInBackground(new SaveCallback() { @Override public void done(AVException e) { if (e == null) { fileUrl = avFile.getUrl(); objectId = avFile.getObjectId(); log(&quot;文件上传成功 url:&quot; + fileUrl); } else { log(e.getMessage()); } } }, new ProgressCallback() { @Override public void done(Integer percentDone) { log(&quot;uploading: &quot; + percentDone); } }); 文件下载 AVFile avFile = new AVFile(&quot;my_download_file&quot;, fileUrl, null); byte[] bytes = avFile.getData(); log(&quot;下载文件完毕，总字节数：&quot; + bytes.length); 文件删除 // 需要控制台开启权限 AVFile avFile = AVFile.withObjectId(objectId); avFile.delete(); 根据文件绝对路径上传 File tmpFile = ...... AVFile file = AVFile.withAbsoluteLocalPath(&quot;filename&quot;, tmpFile.getAbsolutePath()); file.save(); log(&quot;从文件的路径中构造了 AVFile，并保存成功。file:&quot; + toString(file)); 直接上传文件 File tmpFile = ...... AVFile file = AVFile.withFile(&quot;filename&quot;, tmpFile); file.save(); log(&quot;用文件构造了 AVFile，并保存成功。file:&quot; + toString(file)); AVObject转换成AVFile AVQuery&lt;AVObject&gt; q = new AVQuery&lt;&gt;(&quot;_File&quot;); AVObject first = q.getFirst(); log(&quot;获取了文件 AVObject：&quot; + first); AVFile file = AVFile.withAVObject(first); ...... //根据ObjectId转换 AVFile file = AVFile.withObjectId(first.getObjectId()); 修改AVFile元数据 Bitmap bitmap = ...... bytes = ......bitmap...... AVFile file = new AVFile(&quot;filename&quot;, bytes); file.addMetaData(&quot;width&quot;, bitmap.getWidth()); file.addMetaData(&quot;height&quot;, bitmap.getHeight()); file.save(); AVFile获取图片缩略图 AVFile avatar = ...... String url = avatar.getThumbnailUrl(true, 200, 200); log(&quot;最大宽度为200 、最大高度为200的缩略图 url:&quot; + url); //[http://docs.qiniu.com/api/v6/image-process.html](http://docs.qiniu.com/api/v6/image-process.html &quot;七牛文档&quot;) log(&quot;其它图片处理见七牛文档&quot;); POINTER类型存储另外一个对象一个实例的ObjectId AVObject post = new AVObject(&quot;Post&quot;); post.put(&quot;author&quot;, user); post.save(); ARRAY类型存储另外一个对象多个实例的ObjectId AVObject post = new AVObject(&quot;Post&quot;); post.addAll(&quot;likes&quot;, users); post.save(); ：注意add与put的区别，一个是在原ARRAY数组末尾新增，一个是直接赋值 add(java.lang.String key, java.lang.Object value) //Atomically adds an object to the end of the array associated with a given key. put(java.lang.String key, java.lang.Object value) //Add a key-value pair to this object. ：ARRAY可以存储多个POINTER类型 联表查询 //返回的数据将只包含ClassName和ObjectId AVQuery&lt;Post&gt; query = AVQuery.getQuery(&quot;Post&quot;); query.whereExists(&quot;likes&quot;); log(&quot;将不包含 likes 字段的具体数据&quot;); Post first = query.getFirst(); ...... //返回的数据除了ClassName和ObjectId字段，还包含其他所有字段 query.whereExists(Post.LIKES); log(&quot;让返回结果包含了 likes 字段的具体数据，不单单是赞的人的 objectId&quot;); query.include(Post.LIKES); Post first = query.getFirst(); ：注意 POINTER ： 一对一的关系 ARRAY ： 一对多的关系 AVRelation ：多对多的关系 AVRelation类型的使用，添加数据 Post post = query1.getFirst(); Student student = query2.getFirst(); AVRelation&lt;Student&gt; rewardStudents = post.getRelation(&quot;rewards&quot;); rewardStudents.add(student); post.save(); AVRelation类型的使用，移除数据 rewardStudents.remove(student); post.save(); AVRelation类型的使用，查询数据 AVRelation&lt;Student&gt; students = post.getRelation(&quot;rewards&quot;); AVQuery&lt;Student&gt; query = students.getQuery(); List&lt;Student&gt; stuList = query.find(); ...... int count = query.count(); ...... AVQuery&lt;Post&gt; postQuery = AVRelation.reverseQuery(Post.class, &quot;rewards&quot;, student); List&lt;Post&gt; posts = postQuery.find(); ：注意，reverseQuery(java.lang.Class&lt;M&gt; theParentClazz, java.lang.String relationKey, AVObject child) Create a query that can be used to query the parent objects in this relation. 类的继承，创建一个类SubUser继承自AVUser public class SubUser extends AVUser { public static final Creator CREATOR = AVObjectCreator.instance; ...... } ：注意，SubUser继承自AVUser类 Armor armor = new Armor(); armor.setDisplayName(&quot;avos cloud demo object.&quot;); armor.setBroken(false); armor.save(); SubUser subUser = new SubUser(); String nickName = &quot;testSignupSubUser&quot;; subUser.setUsername(username); subUser.setPassword(password); subUser.setNickName(nickName); subUser.setArmor(armor); subUser.signUp(); SubUser cloudUser = AVUser.logIn(username, password, SubUser.class); AVUser currentUser = AVUser.getCurrentUser(); ...... //可以利用创建的子类SubUser登录，因为SubUser继承了AVUser所有属性和方法 SubUser.logInInBackground(username, password, new LogInCallback&lt;AVUser&gt;() { @Override public void done(AVUser avUser, AVException e) { AVUser currentUser = AVUser.getCurrentUser(); Assert.assertTrue(currentUser instanceof SubUser);//Error } }); ：注意，Armor继承自AVObject类。 public class Armor extends AVObject { public static final Creator CREATOR = AVObjectCreator.instance; ...... } 使用SQL语句查询 //1. select String cql = &quot;select * from _User&quot;; AVCloudQueryResult result = AVQuery.doCloudQuery(cql); //AVCloudQueryResult以Json对象展示 result:[{ &quot;username&quot;: &quot;p1nrxk2393jpi8twib0f0wwpu&quot;, &quot;authData&quot;: { &quot;anonymous&quot;: { &quot;id&quot;: &quot;nmey8BRBOHXJLNQnjWw0LqB&quot; } }, &quot;emailVerified&quot;: false, &quot;className&quot;: &quot;_User&quot;, &quot;mobilePhoneVerified&quot;: false, &quot;updatedAt&quot;: &quot;2016-04-05T05:28:29.189Z&quot;, &quot;createdAt&quot;: &quot;2016-04-05T05:28:29.189Z&quot;, &quot;objectId&quot;: &quot;57034cfd71cfe4005cd64e05&quot; },{ &quot;emailVerified&quot;: false, &quot;className&quot;: &quot;_User&quot;, &quot;mobilePhoneVerified&quot;: false, &quot;username&quot;: &quot;XiaoMing&quot;, &quot;updatedAt&quot;: &quot;2016-04-05T05:28:45.473Z&quot;, &quot;createdAt&quot;: &quot;2016-04-05T05:28:45.473Z&quot;, &quot;objectId&quot;: &quot;57034d0d5bbb50004dc9f001&quot; }, ...... }] ...... //2. count String cql = &quot;select count(*) from _User&quot;; AVCloudQueryResult result = AVQuery.doCloudQuery(cql); {&quot;results&quot;:[],&quot;className&quot;:&quot;_User&quot;,&quot;count&quot;:19} ...... //3. where String cql = String.format(&quot;select * from _User where username in (?,?)&quot;); AVCloudQueryResult result = AVQuery.doCloudQuery(cql, &quot;test1&quot;, &quot;test2&quot;); ...... //4. order by String cql = String.format(&quot;select * from _User where createdAt &lt; date(?) order by createdAt limit ?&quot;); AVCloudQueryResult result = AVQuery.doCloudQuery(cql, &quot;2016-05-01T00:00:00.0000Z&quot;, 3); //AVCloudQueryResult以Json对象展示 result:[{ &quot;username&quot;: &quot;p1nrxk2393jpi8twib0f0wwpu&quot;, &quot;authData&quot;: { &quot;anonymous&quot;: { &quot;id&quot;: &quot;nmey8BRBOHXJLNQnjWw0LqB&quot; } }, &quot;emailVerified&quot;: false, &quot;className&quot;: &quot;_User&quot;, &quot;mobilePhoneVerified&quot;: false, &quot;updatedAt&quot;: &quot;2016-04-05T05:28:29.189Z&quot;, &quot;createdAt&quot;: &quot;2016-04-05T05:28:29.189Z&quot;, &quot;objectId&quot;: &quot;57034cfd71cfe4005cd64e05&quot; },{ &quot;emailVerified&quot;: false, &quot;className&quot;: &quot;_User&quot;, &quot;mobilePhoneVerified&quot;: false, &quot;username&quot;: &quot;XiaoMing&quot;, &quot;updatedAt&quot;: &quot;2016-04-05T05:28:45.473Z&quot;, &quot;createdAt&quot;: &quot;2016-04-05T05:28:45.473Z&quot;, &quot;objectId&quot;: &quot;57034d0d5bbb50004dc9f001&quot; },{ &quot;username&quot;: &quot;9lsrmw91febck0fduf81o9fq9&quot;, &quot;authData&quot;: { &quot;anonymous&quot;: { &quot;id&quot;: &quot;zwAzy6L4MGVgsIhbmQLWMXB&quot; } }, &quot;emailVerified&quot;: false, &quot;className&quot;: &quot;_User&quot;, &quot;mobilePhoneVerified&quot;: false, &quot;updatedAt&quot;: &quot;2016-04-06T01:01:59.100Z&quot;, &quot;createdAt&quot;: &quot;2016-04-06T01:01:53.809Z&quot;, &quot;objectId&quot;: &quot;57046001128fe100524f097d&quot; },] 获取服务器时间 Date date = AVOSCloud.getServerDate(); 设置网络响应时长 // 得放到 Application 里 AVOSCloud.setNetworkTimeout(10);]]></content>
      <tags>
        <tag>LeanCloud</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在Android Studio中为APP设置全局字体]]></title>
    <url>%2F2016%2F05%2F24%2F2016-05-24-android-font-setting%2F</url>
    <content type="text"><![CDATA[1.添加库Calligraphydependencies { compile &apos;uk.co.chrisjenx:calligraphy:2.2.0&apos; } 2.添加字体文件到assets/fonts/路径 fonts/RobotoSlab-Thin.ttf 3.自定义Application，在onCreate里面配置默认字体CalligraphyConfig.initDefault(new CalligraphyConfig.Builder() .setDefaultFontPath(&quot;fonts/RobotoSlab-Thin.ttf&quot;) .setFontAttrId(R.attr.fontPath) .build() ); 4.自定义Activity基类BaseActivity，重写attachBaseContext方法 在BaseActivity中重写attachBaseContext方法，使APP中的所有Activity继承自BaseActivity，字体会自动引入到APP全局。 @Override protected void attachBaseContext(Context newBase) { super.attachBaseContext(CalligraphyContextWrapper.wrap(newBase)); } 5.使用5.1.直接引用xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; …… &lt;TextView android:text=&quot;@string/hello_world&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; fontPath=&quot;fonts/RobotoSlab-Thin.ttf&quot;/&gt; 5.2.在TextAppearance中定义字体样式&lt;style name=&quot;TextAppearance.FontPath&quot; parent=&quot;android:TextAppearance&quot;&gt; &lt;!-- Custom Attr--&gt; &lt;item name=&quot;fontPath&quot;&gt;fonts/RobotoSlab-Thin.ttf&lt;/item&gt; &lt;/style&gt; …… &lt;TextView android:text=&quot;@string/hello_world&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:textAppearance=&quot;@style/TextAppearance.FontPath&quot;/&gt; 5.3.在Styles中定义字体样式&lt;style name=&quot;TextViewCustomFont&quot;&gt; &lt;item name=&quot;fontPath&quot;&gt;fonts/RobotoSlab-Thin.ttf&lt;/item&gt; &lt;/style&gt; …… xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; …… &lt;TextView android:text=&quot;@string/hello_world&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; style=&quot;@style/TextViewCustomFont&quot;/&gt; 5.4.在Theme中定义字体样式&lt;style name=&quot;AppTheme&quot; parent=&quot;android:Theme.Holo.Light.DarkActionBar&quot;&gt; &lt;item name=&quot;android:textViewStyle&quot;&gt;@style/AppTheme.Widget.TextView&lt;/item&gt; &lt;/style&gt; &lt;style name=&quot;AppTheme.Widget&quot;/&gt; &lt;style name=&quot;AppTheme.Widget.TextView&quot; parent=&quot;android:Widget.Holo.Light.TextView&quot;&gt; &lt;item name=&quot;fontPath&quot;&gt;fonts/RobotoSlab-Thin.ttf&lt;/item&gt; &lt;/style&gt;]]></content>
      <tags>
        <tag>Font</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[手机窗体状态栏颜色渲染]]></title>
    <url>%2F2016%2F05%2F22%2F2016-05-22-window-color%2F</url>
    <content type="text"><![CDATA[if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.LOLLIPOP) { Window window = MyActivity.this.getWindow(); window.addFlags(WindowManager.LayoutParams.FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS); window.clearFlags(WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS); window.setStatusBarColor(ContextCompat.getColor(MyActivity.this, R.color.colorPrimaryDark)); }]]></content>
  </entry>
  <entry>
    <title><![CDATA[一种图片模糊处理的实现]]></title>
    <url>%2F2016%2F05%2F22%2F2016-05-22-fast-blur%2F</url>
    <content type="text"><![CDATA[public Bitmap fastblur(Context context, Bitmap sentBitmap, int radius) { Bitmap bitmap = sentBitmap.copy(sentBitmap.getConfig(), true); if (radius &lt; 1) { return (null); } int w = bitmap.getWidth(); int h = bitmap.getHeight(); int[] pix = new int[w * h]; bitmap.getPixels(pix, 0, w, 0, 0, w, h); int wm = w - 1; int hm = h - 1; int wh = w * h; int div = radius + radius + 1; int r[] = new int[wh]; int g[] = new int[wh]; int b[] = new int[wh]; int rsum, gsum, bsum, x, y, i, p, yp, yi, yw; int vmin[] = new int[Math.max(w, h)]; int divsum = (div + 1) &gt;&gt; 1; divsum *= divsum; int temp = 256 * divsum; int dv[] = new int[temp]; for (i = 0; i &lt; temp; i++) { dv[i] = (i / divsum); } yw = yi = 0; int[][] stack = new int[div][3]; int stackpointer; int stackstart; int[] sir; int rbs; int r1 = radius + 1; int routsum, goutsum, boutsum; int rinsum, ginsum, binsum; for (y = 0; y &lt; h; y++) { rinsum = ginsum = binsum = routsum = goutsum = boutsum = rsum = gsum = bsum = 0; for (i = -radius; i &lt;= radius; i++) { p = pix[yi + Math.min(wm, Math.max(i, 0))]; sir = stack[i + radius]; sir[0] = (p &amp; 0xff0000) &gt;&gt; 16; sir[1] = (p &amp; 0x00ff00) &gt;&gt; 8; sir[2] = (p &amp; 0x0000ff); rbs = r1 - Math.abs(i); rsum += sir[0] * rbs; gsum += sir[1] * rbs; bsum += sir[2] * rbs; if (i &gt; 0) { rinsum += sir[0]; ginsum += sir[1]; binsum += sir[2]; } else { routsum += sir[0]; goutsum += sir[1]; boutsum += sir[2]; } } stackpointer = radius; for (x = 0; x &lt; w; x++) { r[yi] = dv[rsum]; g[yi] = dv[gsum]; b[yi] = dv[bsum]; rsum -= routsum; gsum -= goutsum; bsum -= boutsum; stackstart = stackpointer - radius + div; sir = stack[stackstart % div]; routsum -= sir[0]; goutsum -= sir[1]; boutsum -= sir[2]; if (y == 0) { vmin[x] = Math.min(x + radius + 1, wm); } p = pix[yw + vmin[x]]; sir[0] = (p &amp; 0xff0000) &gt;&gt; 16; sir[1] = (p &amp; 0x00ff00) &gt;&gt; 8; sir[2] = (p &amp; 0x0000ff); rinsum += sir[0]; ginsum += sir[1]; binsum += sir[2]; rsum += rinsum; gsum += ginsum; bsum += binsum; stackpointer = (stackpointer + 1) % div; sir = stack[(stackpointer) % div]; routsum += sir[0]; goutsum += sir[1]; boutsum += sir[2]; rinsum -= sir[0]; ginsum -= sir[1]; binsum -= sir[2]; yi++; } yw += w; } for (x = 0; x &lt; w; x++) { rinsum = ginsum = binsum = routsum = goutsum = boutsum = rsum = gsum = bsum = 0; yp = -radius * w; for (i = -radius; i &lt;= radius; i++) { yi = Math.max(0, yp) + x; sir = stack[i + radius]; sir[0] = r[yi]; sir[1] = g[yi]; sir[2] = b[yi]; rbs = r1 - Math.abs(i); rsum += r[yi] * rbs; gsum += g[yi] * rbs; bsum += b[yi] * rbs; if (i &gt; 0) { rinsum += sir[0]; ginsum += sir[1]; binsum += sir[2]; } else { routsum += sir[0]; goutsum += sir[1]; boutsum += sir[2]; } if (i &lt; hm) { yp += w; } } yi = x; stackpointer = radius; for (y = 0; y &lt; h; y++) { pix[yi] = (0xff000000 &amp; pix[yi]) | (dv[rsum] &lt;&lt; 16) | (dv[gsum] &lt;&lt; 8) | dv[bsum]; rsum -= routsum; gsum -= goutsum; bsum -= boutsum; stackstart = stackpointer - radius + div; sir = stack[stackstart % div]; routsum -= sir[0]; goutsum -= sir[1]; boutsum -= sir[2]; if (x == 0) { vmin[y] = Math.min(y + r1, hm) * w; } p = x + vmin[y]; sir[0] = r[p]; sir[1] = g[p]; sir[2] = b[p]; rinsum += sir[0]; ginsum += sir[1]; binsum += sir[2]; rsum += rinsum; gsum += ginsum; bsum += binsum; stackpointer = (stackpointer + 1) % div; sir = stack[stackpointer]; routsum += sir[0]; goutsum += sir[1]; boutsum += sir[2]; rinsum -= sir[0]; ginsum -= sir[1]; binsum -= sir[2]; yi += w; } } bitmap.setPixels(pix, 0, w, 0, 0, w, h); return (bitmap); }]]></content>
  </entry>
  <entry>
    <title><![CDATA[GitHub for Windows安装失败解决]]></title>
    <url>%2F2016%2F05%2F22%2F2016-05-22-github-for-windows-installation%2F</url>
    <content type="text"><![CDATA[在http://windows.github.com/下载的GitHub客户端安装程序可能出现安装错误，日志显示 http://github-windows.s3.amazonaws.com/GitHub.application 无法下载。用Internet Explorer无法访问此地址，用其它浏览器下载打开后无法部署（提示错误，详细信息显示DeploymentDownloadException或InvalidDeploymentException异常）。 打开控制面板 → Internet选项 → “安全”选项卡。 选择“受信任的站点”→点击“站点”按钮。 弹出的窗口中的文本框中输入点击“添加” https://github-windows.s3.amazonaws.com/；或者去除复选框“对该区域中的所有站点要求服务器验证(https:)”的钩，直接加入 github-windows.s3.amazonaws.com 。 在 Internet Explorer 中打开 http://github-windows.s3.amazonaws.com/GitHub.application，即开始正常下载安装。]]></content>
      <tags>
        <tag>Github</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用WebView加载HTTPS链接]]></title>
    <url>%2F2016%2F05%2F18%2F2016-05-18-webview-https%2F</url>
    <content type="text"><![CDATA[WebView webView = (WebView)findViewById(R.id.webview); // setting WebViewClient webView.setWebViewClient(new DemoWebViewClient()); webView.getSettings().setDomStorageEnabled(true); webView.getSettings().setJavaScriptEnabled(true); webView.loadUrl(&quot;https://github.com&quot;); DemoWebViewClient是继承WebViewClient类的类，实现了onReceivedSslError方法 private class DemoWebViewClient extends WebViewClient { @Override public void onPageStarted(WebView view, String url, Bitmap favicon) { LogUtil.d(&quot;WebView&quot;, &quot;onPageStarted &quot; + url); } @Override public boolean shouldOverrideUrlLoading(WebView view, String url) { LogUtil.d(&quot;WebView&quot;, &quot;in shouldOverrideUrlLoading&quot;); view.loadUrl(url); return true; } @Override public void onReceivedSslError(WebView view, SslErrorHandler handler, SslError error) { LogUtil.d(&quot;WebView&quot;, &quot;onReceivedSslError&quot;); handler.proceed(); // Ignore SSL certificate errors } @Override public void onPageFinished(WebView view, String url) { LogUtil.d(&quot;WebView&quot;, &quot;onPageFinished &quot; + url); } } 添加网络访问权限 &lt;uses-permission android:name=&quot;android.permission.INTERNET&quot; /&gt;]]></content>
      <tags>
        <tag>Android</tag>
        <tag>WebView</tag>
        <tag>HTTPS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用Hexo、Github搭建博客全过程]]></title>
    <url>%2F2016%2F05%2F17%2F2016-05-17-githubpages%2F</url>
    <content type="text"><![CDATA[一直没时间搭建自己的博客，很羡慕别人的博客写得这么漂亮。今天发现使用Hexo和Github来搭建静态博客还不错，故记录下详细过程，以供参考。 注册Github、添加SSH key 、创建.github.io注册自然不用多说，直接来添加SSH key，windows可通过Git Bash来执行以下命令生成SSH key ssh-keygen -t rsa -C &quot;waylanpunch@youremail.com&quot; 一路回车将id_rsa.pub复制添加到github-settings-ssh keys即可 创建repository，格式为waylanpunch.github.io 安装Hexo执行以下命令： npm install-g hexo 初始化： hexo init 生成静态资源： hexo g 启动服务： hexo s 启动完成后可通过 http://localhost:4000/ 来访问 配置_config.yml配置一些基本信息就不多说了，直接说怎么配置上传github，打开_config.yml，找到deploy，按照以下内容添加修改即可 deploy: type: git repository: git@github.com:waylanpunch/waylanpunch.github.io.git branch: master hexo需执行以下命令,否则上传不到github npm install hexo-deployer-git --save 执行以下命令部署到github hexo deploy 然后访问waylanpunch.github.io就可以看到效果啦！ 以后每次部署需执行下面三步命令： hexo clean hexo g hexo d 我个人没有独立域名所以写不出绑定教程了。 安装主题ok，到这里hexo的安装已经告一段落了，但俗话说的好，人靠衣装马靠鞍，接下来我们要去换一款主题，这里以NexT为例 cd your-hexo-site git clone https://github.com/iissnan/hexo-theme-next themes/next 然后将_config.yml里的theme改为next即可。 使用Hexo写作执行以下命令生成编辑文件 hexo new post filename 文件类型参考路径\scaffolds\，默认有draft.md、page.md和post.md三种类型进入\source_posts\文件夹下，编辑刚才创建的Markdown文件 然后再执行 hexo clean hexo g hexo d 访问waylanpunch.github.io就可以看到部署的文章了 参考的教程在这里：简书]]></content>
      <tags>
        <tag>Hexo</tag>
        <tag>Github</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Can't find resource for bundle 'org.ocpsoft.prettytime.i18n.Resources_zh_CN']]></title>
    <url>%2F2016%2F05%2F17%2F2016-05-17-prettytime-resources-error%2F</url>
    <content type="text"><![CDATA[Android Studio菜单Build-&gt;Generate Signed APK，安装到设备之后程序崩溃 java.util.MissingResourceException Can&apos;t find resource for bundle &apos;org.ocpsoft.prettytime.i18n.Resources_zh_CN&apos;, key &apos;&apos; java.util.ResourceBundle.missingResourceException(ResourceBundle.java:238) java.util.ResourceBundle.getBundle(ResourceBundle.java:230) java.util.ResourceBundle.getBundle(ResourceBundle.java:159) b.a.a.b.b.b(Unknown Source) b.a.a.b.b.a(Unknown Source) b.a.a.c.a(Unknown Source) b.a.a.c.a(Unknown Source) b.a.a.c.b(Unknown Source) b.a.a.c.&lt;init&gt;(Unknown Source) com.way.heard.e.j.a(Unknown Source) com.way.heard.a.u.a(Unknown Source) com.way.heard.a.u.a(Unknown Source) android.support.v7.widget.eb.a(Unknown Source) android.support.v7.widget.eb.b(Unknown Source) android.support.v7.widget.es.a(Unknown Source) android.support.v7.widget.es.c(Unknown Source) android.support.v7.widget.cy.a(Unknown Source) android.support.v7.widget.LinearLayoutManager.a(Unknown Source) android.support.v7.widget.LinearLayoutManager.a(Unknown Source) android.support.v7.widget.LinearLayoutManager.c(Unknown Source) android.support.v7.widget.RecyclerView.G(Unknown Source) android.support.v7.widget.RecyclerView.k(Unknown Source) android.support.v7.widget.RecyclerView.onLayout(Unknown Source) android.view.View.layout(View.java:16727) android.view.ViewGroup.layout(ViewGroup.java:5452) android.support.v4.widget.SwipeRefreshLayout.onLayout(Unknown Source) android.view.View.layout(View.java:16727) android.view.ViewGroup.layout(ViewGroup.java:5452) android.widget.FrameLayout.layoutChildren(FrameLayout.java:336) android.widget.FrameLayout.onLayout(FrameLayout.java:273) android.view.View.layout(View.java:16727) android.view.ViewGroup.layout(ViewGroup.java:5452) android.widget.FrameLayout.layoutChildren(FrameLayout.java:336) android.widget.FrameLayout.onLayout(FrameLayout.java:273) android.view.View.layout(View.java:16727) android.view.ViewGroup.layout(ViewGroup.java:5452) android.support.design.widget.CoordinatorLayout.c(Unknown Source) android.support.design.widget.CoordinatorLayout.a(Unknown Source) android.support.design.widget.dh.a(Unknown Source) android.support.design.widget.AppBarLayout$ScrollingViewBehavior.a(Unknown Source) android.support.design.widget.CoordinatorLayout.onLayout(Unknown Source) android.view.View.layout(View.java:16727) android.view.ViewGroup.layout(ViewGroup.java:5452) android.support.v4.widget.DrawerLayout.onLayout(Unknown Source) android.view.View.layout(View.java:16727) android.view.ViewGroup.layout(ViewGroup.java:5452) android.widget.FrameLayout.layoutChildren(FrameLayout.java:336) android.widget.FrameLayout.onLayout(FrameLayout.java:273) android.view.View.layout(View.java:16727) android.view.ViewGroup.layout(ViewGroup.java:5452) android.widget.LinearLayout.setChildFrame(LinearLayout.java:1743) android.widget.LinearLayout.layoutVertical(LinearLayout.java:1586) android.widget.LinearLayout.onLayout(LinearLayout.java:1495) android.view.View.layout(View.java:16727) android.view.ViewGroup.layout(ViewGroup.java:5452) android.widget.FrameLayout.layoutChildren(FrameLayout.java:336) android.widget.FrameLayout.onLayout(FrameLayout.java:273) android.view.View.layout(View.java:16727) android.view.ViewGroup.layout(ViewGroup.java:5452) android.widget.LinearLayout.setChildFrame(LinearLayout.java:1743) android.widget.LinearLayout.layoutVertical(LinearLayout.java:1586) android.widget.LinearLayout.onLayout(LinearLayout.java:1495) android.view.View.layout(View.java:16727) android.view.ViewGroup.layout(ViewGroup.java:5452) android.widget.FrameLayout.layoutChildren(FrameLayout.java:336) android.widget.FrameLayout.onLayout(FrameLayout.java:273) com.android.internal.policy.PhoneWindow$DecorView.onLayout(PhoneWindow.java:2728) android.view.View.layout(View.java:16727) android.view.ViewGroup.layout(ViewGroup.java:5452) android.view.ViewRootImpl.performLayout(ViewRootImpl.java:2288) android.view.ViewRootImpl.performTraversals(ViewRootImpl.java:2025) android.view.ViewRootImpl.doTraversal(ViewRootImpl.java:1174) android.view.ViewRootImpl$TraversalRunnable.run(ViewRootImpl.java:6241) android.view.Choreographer$CallbackRecord.run(Choreographer.java:873) android.view.Choreographer.doCallbacks(Choreographer.java:676) android.view.Choreographer.doFrame(Choreographer.java:606) android.view.Choreographer$FrameDisplayEventReceiver.run(Choreographer.java:859) android.os.Handler.handleCallback(Handler.java:739) android.os.Handler.dispatchMessage(Handler.java:95) android.os.Looper.loop(Looper.java:168) android.app.ActivityThread.main(ActivityThread.java:5845) java.lang.reflect.Method.invoke(Native Method) com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:797) com.android.internal.os.ZygoteInit.main(ZygoteInit.java:687) 解决办法为在proguard-rules文件中添加 -keep class org.ocpsoft.prettytime.i18n.**]]></content>
      <tags>
        <tag>PrettyTime</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[点击键盘Enter键执行两次事件的解决方案]]></title>
    <url>%2F2016%2F05%2F15%2F2016-05-15-Do%2F</url>
    <content type="text"><![CDATA[EditText控件添加属性 android:singleLine=&quot;true&quot; 弹出的软盘输入法中回车键为next，直到最后一个获取焦点后显示为Done，点击Done后，软盘输入键盘便隐藏。 etTitle.setOnKeyListener(newView.OnKeyListener() { @Override public booleanonKey(View v, intkeyCode,KeyEvent event) { if(keyCode == KeyEvent.KEYCODE_ENTER) { LogUtil.d(TAG,&quot;initView debug, OnKeyListener, KEYCODE_ENTER&quot;); InputMethodManager imm = (InputMethodManager) v.getContext().getSystemService(Context.INPUT_METHOD_SERVICE); if(imm.isActive()) { imm.hideSoftInputFromWindow(v.getApplicationWindowToken(),0); } return true; } return false; } }); APP运行后执行两次Enter事件： 04-17 22:14:43.796 4925-4925/com.. D/com...ui.activities.MainActivity: initView debug, OnKeyListener, KEYCODE_ENTER 04-17 22:14:43.812 4925-4925/com.. D/com...ui.activities.MainActivity: initView debug, OnKeyListener, KEYCODE_ENTER 由于Key有Down和Up事件，所以会执行两次。我们只需监听Down事件即可。 解决方案： etTitle.setOnKeyListener(newView.OnKeyListener() { @Override public booleanonKey(View v, intkeyCode,KeyEvent event) { if(keyCode == KeyEvent.KEYCODE_ENTER &amp;&amp; event.getAction() == KeyEvent.ACTION_DOWN) ******* 输出一次： 04-17 22:25:06.837 19413-19413/com.. D/com...ui.activities.MainActivity: initView debug, OnKeyListener, KEYCODE_ENTER]]></content>
      <tags>
        <tag>Android</tag>
        <tag>KeyEvent</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Moon Jekyll Theme]]></title>
    <url>%2F2016%2F04%2F06%2F2016-03-21-moon-theme%2F</url>
    <content type="text"><![CDATA[Moon is a minimal, one column jekyll theme. I’m not a developer or designer. And I don’t add footer to show who did this theme. If you like this theme or using it, please give a star for motivation, It makes me happy. Installation Fork the Moon repo Edit _config.yml file. Remove sample posts from _posts folder and add yours. Edit index.md file in about folder. Change repo name to YourUserName.github.io That’s all. Preview123456&#123;% capture images %&#125; https://cloud.githubusercontent.com/assets/754514/14509716/61ac6c8e-01d6-11e6-879f-8308883de790.png https://cloud.githubusercontent.com/assets/754514/14509717/61ad05ae-01d6-11e6-85ae-5a817dd8763b.png https://cloud.githubusercontent.com/assets/754514/14509714/61a89708-01d6-11e6-8fcd-74b002a060df.png&#123;% endcapture %&#125;&#123;% include gallery images=images caption=&quot;Screenshots of Moon Theme&quot; cols=3 %&#125; 12345&#123;% capture images %&#125; https://cloud.githubusercontent.com/assets/754514/14509718/61b09a20-01d6-11e6-8da1-4202ae4d83cd.png https://cloud.githubusercontent.com/assets/754514/14509715/61aa9d00-01d6-11e6-81a6-c6837edf2e84.png&#123;% endcapture %&#125;&#123;% include gallery images=images caption=&quot;Moon Theme on Small Screen Size&quot; cols=2 %&#125; See a live version of Moon hosted on GitHub. Site SetupA quick checklist of the files you’ll want to edit to get up and running. Site Wide Configuration_config.yml is your friend. Open it up and personalize it. Most variables are self explanatory but here’s an explanation of each if needed: titleThe title of your site… shocker! Example title: My Awesome Site bioThe description to show on your homepage. descriptionThe description to use for meta tags and navigation menu. urlUsed to generate absolute urls in sitemap.xml, feed.xml, and for generating canonical URLs in &lt;head&gt;. When developing locally either comment this out or use something like http://localhost:4000 so all assets load properly. Don’t include a trailing /. Examples: 123456&#123;% highlight yaml %&#125;url: http://taylantatli.me/Moonurl: http://localhost:4000url: //cooldude.github.iourl:&#123;% endhighlight %&#125; reading_timeSet true to show reading time for posts. And set words_per_minute, default is 200. logoYour site’s logo. It will show on homepage and navigation menu. Also used for twitter meta tags. backgroundImage for background. If you don’t set it, color will be used as a background. Google Analytics and Webmaster ToolsGoogle Analytics UA and Webmaster Tool verification tags can be entered in _config.yml. For more information on obtaining these meta tags check Google Webmaster Tools and Bing Webmaster Tools support. MathJaxIt’s enabled. But if you don’t want to use it. Set it false in _config.yml. Disqus CommentsSet your disqus shortname in _config.yml to use comments. Navigation LinksTo set what links appear in the top navigation edit _data/navigation.yml. Use the following format to set the URL and title for as many links as you’d like. External links will open in a new window. 12345678910111213141516&#123;% highlight yaml %&#125;- title: Home url: /- title: Blog url: /blog/- title: Projects url: /projects/- title: About url: /about/- title: Moon url: http://taylantatli.me/Moon&#123;% endhighlight %&#125; Layouts and ContentMoon Theme use Jekyll Compress to compress html output. But it can cause errors if you use “linenos” (line numbers). I suggest don’t use line numbers for codes, because it won’t look good with this theme, also i didn’t give a proper style for them. If you insist to use line numbers, just remove layout: compress string from layouts. It will disable compressing. Feature ImageYou can set feature image per post. Just add feature: some link to your post’s front matter. feature: /assets/img/some-image.png or feaure: http://example.com/some-image.png This also will be used for twitter card: CommentsTo show disqus comments for your post add comments: true to your post’s front matter. Questions?Found a bug or aren’t quite sure how something works? By all means file a GitHub Issue. And if you make something cool with this theme feel free to let me know. LicenseThis theme is free and open source software, distributed under the MIT License. So feel free to use this Jekyll theme on your site without linking back to me or including a disclaimer.]]></content>
      <tags>
        <tag>jekyll</tag>
        <tag>moon</tag>
        <tag>blog</tag>
        <tag>about</tag>
        <tag>theme</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Markdown Syntax]]></title>
    <url>%2F2016%2F03%2F15%2F2016-03-20-markdown-syntax%2F</url>
    <content type="text"><![CDATA[HTML ElementsBelow is just about everything you’ll need to style in the theme. Check the source code to see the many embedded elements within paragraphs. Heading 1Heading 2Heading 3Heading 4Heading 5Heading 6Body textLorem ipsum dolor sit amet, test link adipiscing elit. This is strong. Nullam dignissim convallis est. Quisque aliquam. {: .image-right} This is emphasized. Donec faucibus. Nunc iaculis suscipit dui. 53 = 125. Water is H2O. Nam sit amet sem. Aliquam libero nisi, imperdiet at, tincidunt nec, gravida vehicula, nisl. The New York Times (That’s a citation). Underline.Maecenas ornare tortor. Donec sed tellus eget sapien fringilla nonummy. Mauris a ante. Suspendisse quam sem, consequat at, commodo vitae, feugiat in, nunc. Morbi imperdiet augue quis tellus. HTML and CSS are our tools. Mauris a ante. Suspendisse quam sem, consequat at, commodo vitae, feugiat in, nunc. Morbi imperdiet augue quis tellus. Praesent mattis, massa quis luctus fermentum, turpis mi volutpat justo, eu volutpat enim diam eget metus. Blockquotes Lorem ipsum dolor sit amet, test link adipiscing elit. Nullam dignissim convallis est. Quisque aliquam. List TypesOrdered Lists Item one sub item one sub item two sub item three Item two Unordered Lists Item one Item two Item three Tables Header1 Header2 Header3 cell1 cell2 cell3 cell4 cell5 cell6 —- cell1 cell2 cell3 cell4 cell5 cell6 ===== Foot1 Foot2 Foot3 {: rules=”groups”} Code Snippets1234567&#123;% highlight css %&#125;#container &#123; float: left; margin: 0 -240px 0 0; width: 100%;&#125;&#123;% endhighlight %&#125; ButtonsMake any link standout more when applying the .btn class. 123&#123;% highlight html %&#125;&lt;a href=&quot;#&quot; class=&quot;btn btn-success&quot;&gt;Success Button&lt;/a&gt;&#123;% endhighlight %&#125; Primary ButtonSuccess ButtonWarning ButtonDanger ButtonInfo Button KBDYou can also use &lt;kbd&gt; tag for keyboard buttons. 123&#123;% highlight html %&#125;&lt;kbd&gt;W&lt;/kbd&gt;&lt;kbd&gt;A&lt;/kbd&gt;&lt;kbd&gt;S&lt;/kbd&gt;&lt;kbd&gt;D&lt;/kbd&gt;&#123;% endhighlight %&#125; Press WASD to move your car. Midtown Maddness!! NoticesWatch out! You can also add notices by appending {: .notice} to a paragraph.{: .notice}]]></content>
      <tags>
        <tag>test</tag>
        <tag>sample</tag>
        <tag>markdown</tag>
        <tag>jekyll</tag>
        <tag>syntax</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[A Post with a Video]]></title>
    <url>%2F2016%2F03%2F15%2F2013-06-25-video-post%2F</url>
    <content type="text"><![CDATA[Video embeds are responsive and scale with the width of the main content block with the help of FitVids. Not sure if this only effects Kramdown or if it’s an issue with Markdown in general. But adding YouTube video embeds causes errors when building your Jekyll site. To fix add a space between the &lt;iframe&gt; tags and remove allowfullscreen. Example below: 123&#123;% highlight html %&#125;&lt;iframe width=&quot;560&quot; height=&quot;315&quot; src=&quot;//www.youtube.com/embed/SU3kYxJmWuQ&quot; frameborder=&quot;0&quot;&gt; &lt;/iframe&gt;&#123;% endhighlight %&#125;]]></content>
      <tags>
        <tag>sample</tag>
        <tag>post</tag>
        <tag>video</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MathJax Example]]></title>
    <url>%2F2015%2F08%2F10%2F2015-08-10-mathjax-example%2F</url>
    <content type="text"><![CDATA[MathJax is a simple way of including Tex/LaTex/MathML based mathematics in HTML webpages. To get up and running you need to include the MathJax script in the header of your github pages page, and then write some maths. For LaTex, there are two delimiters you need to know about, one for block or displayed mathematics \[ ... \], and the other for inline mathematics \( ... \). UsageTo enable MathJax support be sure Kramdown is your Markdown flavor of choice and MathJax is set to true in your _config.yml file. 12markdown: kramdownmathjax: true 12Here is an example MathJax inline rendering \\( 1/x^&#123;2&#125; \\), and here is a block rendering: \\[ \frac&#123;1&#125;&#123;n^&#123;2&#125;&#125; \\] Here is an example MathJax inline rendering \( 1/x^{2} \), and here is a block rendering:\[ \frac{1}{n^{2}} \] The only thing to look out for is the escaping of the backslash when using markdown, so the delimiters become \\[ ... \\] and \\( ... \\) for inline and block maths respectively. $$\begin{align} &amp; \phi(x,y) = \phi \left(\sum_{i=1}^n x_ie_i, \sum_{j=1}^n y_je_j \right) = \sum_{i=1}^n \sum_{j=1}^n x_i y_j \phi(e_i, e_j) = \ &amp; (x_1, \ldots, x_n) \left( \begin{array}{ccc} \phi(e_1, e_1) &amp; \cdots &amp; \phi(e_1, e_n) \ \vdots &amp; \ddots &amp; \vdots \ \phi(e_n, e_1) &amp; \cdots &amp; \phi(e_n, e_n) \end{array} \right) \left( \begin{array}{c} y_1 \ \vdots \ y_n \end{array} \right)\end{align}$$]]></content>
      <tags>
        <tag>test</tag>
        <tag>markdown</tag>
        <tag>mathjax</tag>
        <tag>example</tag>
        <tag>jekyll</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Syntax Highlighting Post]]></title>
    <url>%2F2013%2F08%2F16%2F2013-08-16-code-highlighting-post%2F</url>
    <content type="text"><![CDATA[Syntax highlighting is a feature that displays source code, in different colors and fonts according to the category of terms. This feature facilitates writing in a structured language such as a programming language or a markup language as both structures and syntax errors are visually distinct. Highlighting does not affect the meaning of the text itself; it is intended only for human readers.^1 Highlighted Code BlocksTo modify styling and highlight colors edit /assets/css/syntax.css. 1234567&#123;% highlight css %&#125;#container &#123; float: left; margin: 0 -240px 0 0; width: 100%;&#125;&#123;% endhighlight %&#125; 123456789101112&#123;% highlight html %&#125;&#123;% raw %&#125;&lt;nav class=&quot;pagination&quot; role=&quot;navigation&quot;&gt; &#123;% if page.previous %&#125; &lt;a href=&quot;&#123;&#123; site.url &#125;&#125;&#123;&#123; page.previous.url &#125;&#125;&quot; class=&quot;btn&quot; title=&quot;&#123;&#123; page.previous.title &#125;&#125;&quot;&gt;Previous article&lt;/a&gt; &#123;% endif %&#125; &#123;% if page.next %&#125; &lt;a href=&quot;&#123;&#123; site.url &#125;&#125;&#123;&#123; page.next.url &#125;&#125;&quot; class=&quot;btn&quot; title=&quot;&#123;&#123; page.next.title &#125;&#125;&quot;&gt;Next article&lt;/a&gt; &#123;% endif %&#125;&lt;/nav&gt;&lt;!-- /.pagination --&gt;&#123;% endraw %&#125;&#123;% endhighlight %&#125; 12345678910111213141516171819&#123;% highlight ruby %&#125;module Jekyll class TagIndex &lt; Page def initialize(site, base, dir, tag) @site = site @base = base @dir = dir @name = &apos;index.html&apos; self.process(@name) self.read_yaml(File.join(base, &apos;_layouts&apos;), &apos;tag_index.html&apos;) self.data[&apos;tag&apos;] = tag tag_title_prefix = site.config[&apos;tag_title_prefix&apos;] || &apos;Tagged: &apos; tag_title_suffix = site.config[&apos;tag_title_suffix&apos;] || &apos;&amp;#8211;&apos; self.data[&apos;title&apos;] = &quot;#&#123;tag_title_prefix&#125;#&#123;tag&#125;&quot; self.data[&apos;description&apos;] = &quot;An archive of posts tagged #&#123;tag&#125;.&quot; end endend&#123;% endhighlight %&#125; Standard Code Block{% raw %} {% if page.previous %} Previous article {% endif %} {% if page.next %} Next article {% endif %} {% endraw %} Fenced Code BlocksTo modify styling and highlight colors edit /assets/css/syntax.css. Line numbers and a few other things can be modified in _config.yml. Consult Jekyll’s documentation for more information. 12345#container &#123; float: left; margin: 0 -240px 0 0; width: 100%;&#125; 12345678&#123;% raw %&#125;&lt;nav class="pagination" role="navigation"&gt; &#123;% if page.previous %&#125; &lt;a href="&#123;&#123; site.url &#125;&#125;&#123;&#123; page.previous.url &#125;&#125;" class="btn" title="&#123;&#123; page.previous.title &#125;&#125;"&gt;Previous article&lt;/a&gt; &#123;% endif %&#125; &#123;% if page.next %&#125; &lt;a href="&#123;&#123; site.url &#125;&#125;&#123;&#123; page.next.url &#125;&#125;" class="btn" title="&#123;&#123; page.next.title &#125;&#125;"&gt;Next article&lt;/a&gt; &#123;% endif %&#125;&lt;/nav&gt;&lt;!-- /.pagination --&gt;&#123;% endraw %&#125; 1234567891011121314151617module Jekyll class TagIndex &lt; Page def initialize(site, base, dir, tag) @site = site @base = base @dir = dir @name = 'index.html' self.process(@name) self.read_yaml(File.join(base, '_layouts'), 'tag_index.html') self.data['tag'] = tag tag_title_prefix = site.config['tag_title_prefix'] || 'Tagged: ' tag_title_suffix = site.config['tag_title_suffix'] || '&amp;#8211;' self.data['title'] = "#&#123;tag_title_prefix&#125;#&#123;tag&#125;" self.data['description'] = "An archive of posts tagged #&#123;tag&#125;." end endend GitHub Gist EmbedAn example of a Gist embed below.]]></content>
      <tags>
        <tag>sample post</tag>
        <tag>code</tag>
        <tag>highlighting</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[A Post with Images]]></title>
    <url>%2F2013%2F05%2F22%2F2013-05-22-sample-post-images%2F</url>
    <content type="text"><![CDATA[Here are some examples of what a post with images might look like. If you want to display two or three images next to each other responsively use figure with the appropriate class. Each instance of figure is auto-numbered and displayed in the caption. Figures (for images or video)One Up Morning Fog Emerging From Trees by A Guy Taking Pictures, on Flickr. Vero laborum commodo occupy. Semiotics voluptate mumblecore pug. Cosby sweater ullamco quinoa ennui assumenda, sapiente occupy delectus lo-fi. Ea fashion axe Marfa cillum aliquip. Retro Bushwick keytar cliche. Before they sold out sustainable gastropub Marfa readymade, ethical Williamsburg skateboard brunch qui consectetur gentrify semiotics. Mustache cillum irony, fingerstache magna pour-over keffiyeh tousled selfies. Two UpApply the half class like so to display two images side by side that share the same caption. 1234567&#123;% highlight html %&#125;&lt;figure class=&quot;half&quot;&gt; &lt;a href=&quot;/images/image-filename-1-large.jpg&quot;&gt;&lt;img src=&quot;/images/image-filename-1.jpg&quot;&gt;&lt;/a&gt; &lt;a href=&quot;/images/image-filename-2-large.jpg&quot;&gt;&lt;img src=&quot;/images/image-filename-2.jpg&quot;&gt;&lt;/a&gt; &lt;figcaption&gt;Caption describing these two images.&lt;/figcaption&gt;&lt;/figure&gt;&#123;% endhighlight %&#125; And you’ll get something that looks like this: Two images. Three UpApply the third class like so to display three images side by side that share the same caption. 12345678&#123;% highlight html %&#125;&lt;figure class=&quot;third&quot;&gt; &lt;img src=&quot;/images/image-filename-1.jpg&quot;&gt; &lt;img src=&quot;/images/image-filename-2.jpg&quot;&gt; &lt;img src=&quot;/images/image-filename-3.jpg&quot;&gt; &lt;figcaption&gt;Caption describing these three images.&lt;/figcaption&gt;&lt;/figure&gt;&#123;% endhighlight %&#125; And you’ll get something that looks like this: Three images. Alternative wayAnother way to achieve the same result is to include gallery Liquid template. In this case youdon’t have to write any HTML tags – just copy a small block of code, adjust the parameters (see below)and fill the block with any number of links to images. You can mix relative and external links. Here is the block you might want to use: 12345678910&#123;% highlight liquid %&#125;&#123;% raw %&#125;&#123;% capture images %&#125; http://vignette2.wikia.nocookie.net/naruto/images/9/97/Hinata.png http://vignette4.wikia.nocookie.net/naruto/images/7/79/Hinata_Part_II.png http://vignette1.wikia.nocookie.net/naruto/images/1/15/J%C5%ABho_S%C5%8Dshiken.png&#123;% endcapture %&#125;&#123;% include gallery images=images caption=&quot;Test images&quot; cols=3 %&#125;&#123;% endraw %&#125;&#123;% endhighlight %&#125; Parameters: caption: Sets the caption under the gallery (see figcaption HTML tag above); cols: Sets the number of columns of the gallery.Available values: [1..3]. It will look something like this:123456&#123;% capture images %&#125; http://vignette2.wikia.nocookie.net/naruto/images/9/97/Hinata.png http://vignette4.wikia.nocookie.net/naruto/images/7/79/Hinata_Part_II.png http://vignette1.wikia.nocookie.net/naruto/images/1/15/J%C5%ABho_S%C5%8Dshiken.png&#123;% endcapture %&#125;&#123;% include gallery images=images caption=&quot;Test images&quot; cols=3 %&#125;]]></content>
      <tags>
        <tag>sample post</tag>
        <tag>test</tag>
        <tag>images</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Post with Image Feature]]></title>
    <url>%2F2012%2F05%2F23%2F2012-05-23-readability-feature-post%2F</url>
    <content type="text"><![CDATA[Portland in shoreditch Vice, labore typewriter pariatur hoodie fap sartorial Austin. Pinterest literally occupy Schlitz forage. Odio ad blue bottle vinyl, 90’s narwhal commodo bitters pour-over nostrud. Ugh est hashtag in, fingerstache adipisicing laboris esse Pinterest shabby chic Portland. Shoreditch bicycle rights anim, flexitarian laboris put a bird on it vinyl cupidatat narwhal. Hashtag artisan skateboard, flannel Bushwick nesciunt salvia aute fixie do plaid post-ironic dolor McSweeney’s. Cliche pour-over chambray nulla four loko skateboard sapiente hashtag. Vero laborum commodo occupy. Semiotics voluptate mumblecore pug. Cosby sweater ullamco quinoa ennui assumenda, sapiente occupy delectus lo-fi. Ea fashion axe Marfa cillum aliquip. Retro Bushwick keytar cliche. Before they sold out sustainable gastropub Marfa readymade, ethical Williamsburg skateboard brunch qui consectetur gentrify semiotics. Mustache cillum irony, fingerstache magna pour-over keffiyeh tousled selfies. Cupidatat 90’s lo-fi authentic try-hardIn pug Portland incididunt mlkshk put a bird on it vinyl quinoa. Terry Richardson shabby chic +1, scenester Tonx excepteur tempor fugiat voluptate fingerstache aliquip nisi next level. Farm-to-table hashtag Truffaut, Odd Future ex meggings gentrify single-origin coffee try-hard 90’s. Sartorial hoodie Labore viral forage Tote bag selvage DIY exercitation et id ugh tumblr church-key Incididunt umami sriracha, ethical fugiat VHS ex assumenda yr irure direct trade. Marfa Truffaut bicycle rights, kitsch placeat Etsy kogi asymmetrical. Beard locavore flexitarian, kitsch photo booth hoodie plaid ethical readymade leggings yr. Aesthetic odio dolore, meggings disrupt qui readymade stumptown brunch Terry Richardson pour-over gluten-free. Banksy american apparel in selfies, biodiesel flexitarian organic meh wolf quinoa gentrify banjo kogi. Readymade tofu ex, scenester dolor umami fingerstache occaecat fashion axe Carles jean shorts minim. Keffiyeh fashion axe nisi Godard mlkshk dolore. Lomo you probably haven’t heard of them eu non, Odd Future Truffaut pug keytar meggings McSweeney’s Pinterest cred. Etsy literally aute esse, eu bicycle rights qui meggings fanny pack. Gentrify leggings pug flannel duis. Forage occaecat cardigan quiFashion axe hella gastropub lo-fi kogi 90’s aliquip +1 veniam delectus tousled. Cred sriracha locavore gastropub kale chips, iPhone mollit sartorial. Anim dolore 8-bit, pork belly dolor photo booth aute flannel small batch. Dolor disrupt ennui, tattooed whatever salvia Banksy sartorial roof party selfies raw denim sint meh pour-over. Ennui eu cardigan sint, gentrify iPhone cornhole. Whatever velit occaecat quis deserunt gastropub, leggings elit tousled roof party 3 wolf moon kogi pug blue bottle ea. Fashion axe shabby chic Austin quinoa pickled laborum bitters next level, disrupt deep v accusamus non fingerstache. Tote bag asymmetrical elit sunt. Occaecat authentic Marfa, hella McSweeney’s next level irure veniam master cleanse. Sed hoodie letterpress artisan wolf leggings, 3 wolf moon commodo ullamco. Anim occupy ea labore Terry Richardson. Tofu ex master cleanse in whatever pitchfork banh mi, occupy fugiat fanny pack Austin authentic. Magna fugiat 3 wolf moon, labore McSweeney’s sustainable vero consectetur. Gluten-free disrupt enim, aesthetic fugiat jean shorts trust fund keffiyeh magna try-hard. Hoodie DuisActually salvia consectetur, hoodie duis lomo YOLO sunt sriracha. Aute pop-up brunch farm-to-table odio, salvia irure occaecat. Sriracha small batch literally skateboard. Echo Park nihil hoodie, aliquip forage artisan laboris. Trust fund reprehenderit nulla locavore. Stumptown raw denim kitsch, keffiyeh nulla twee dreamcatcher fanny pack ullamco 90’s pop-up est culpa farm-to-table. Selfies 8-bit do pug odio. Thundercats Ho!Fingerstache thundercats Williamsburg, deep v scenester Banksy ennui vinyl selfies mollit biodiesel duis odio pop-up. Banksy 3 wolf moon try-hard, sapiente enim stumptown deep v ad letterpress. Squid beard brunch, exercitation raw denim yr sint direct trade. Raw denim narwhal id, flannel DIY McSweeney’s seitan. Letterpress artisan bespoke accusamus, meggings laboris consequat Truffaut qui in seitan. Sustainable cornhole Schlitz, twee Cosby sweater banh mi deep v forage letterpress flannel whatever keffiyeh. Sartorial cred irure, semiotics ethical sed blue bottle nihil letterpress. Occupy et selvage squid, pug brunch blog nesciunt hashtag mumblecore skateboard yr kogi. Ugh small batch swag four loko. Fap post-ironic qui tote bag farm-to-table american apparel scenester keffiyeh vero, swag non pour-over gentrify authentic pitchfork. Schlitz scenester lo-fi voluptate, tote bag irony bicycle rights pariatur vero Vice freegan wayfarers exercitation nisi shoreditch. Chambray tofu vero sed. Street art swag literally leggings, Cosby sweater mixtape PBR lomo Banksy non in pitchfork ennui McSweeney’s selfies. Odd Future Banksy non authentic. Aliquip enim artisan dolor post-ironic. Pug tote bag Marfa, deserunt pour-over Portland wolf eu odio intelligentsia american apparel ugh ea. Sunt viral et, 3 wolf moon gastropub pug id. Id fashion axe est typewriter, mlkshk Portland art party aute brunch. Sint pork belly Cosby sweater, deep v mumblecore kitsch american apparel. Try-hard direct trade tumblr sint skateboard. Adipisicing bitters excepteur biodiesel, pickled gastropub aute veniam.]]></content>
      <tags>
        <tag>sample post</tag>
        <tag>readability</tag>
        <tag>test</tag>
        <tag>image</tag>
        <tag>feature</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Testing Readability with a Bunch of Text]]></title>
    <url>%2F2012%2F05%2F22%2F2012-05-22-readability-post%2F</url>
    <content type="text"><![CDATA[Portland in shoreditch Vice, labore typewriter pariatur hoodie fap sartorial Austin. Pinterest literally occupy Schlitz forage. Odio ad blue bottle vinyl, 90’s narwhal commodo bitters pour-over nostrud. Ugh est hashtag in, fingerstache adipisicing laboris esse Pinterest shabby chic Portland. Shoreditch bicycle rights anim, flexitarian laboris put a bird on it vinyl cupidatat narwhal. Hashtag artisan skateboard, flannel Bushwick nesciunt salvia aute fixie do plaid post-ironic dolor McSweeney’s. Cliche pour-over chambray nulla four loko skateboard sapiente hashtag. Vero laborum commodo occupy. Semiotics voluptate mumblecore pug. Cosby sweater ullamco quinoa ennui assumenda, sapiente occupy delectus lo-fi. Ea fashion axe Marfa cillum aliquip. Retro Bushwick keytar cliche. Before they sold out sustainable gastropub Marfa readymade, ethical Williamsburg skateboard brunch qui consectetur gentrify semiotics. Mustache cillum irony, fingerstache magna pour-over keffiyeh tousled selfies. Cupidatat 90’s lo-fi authentic try-hardIn pug Portland incididunt mlkshk put a bird on it vinyl quinoa. Terry Richardson shabby chic +1, scenester Tonx excepteur tempor fugiat voluptate fingerstache aliquip nisi next level. Farm-to-table hashtag Truffaut, Odd Future ex meggings gentrify single-origin coffee try-hard 90’s. Sartorial hoodie Labore viral forage Tote bag selvage DIY exercitation et id ugh tumblr church-key Incididunt umami sriracha, ethical fugiat VHS ex assumenda yr irure direct trade. Marfa Truffaut bicycle rights, kitsch placeat Etsy kogi asymmetrical. Beard locavore flexitarian, kitsch photo booth hoodie plaid ethical readymade leggings yr. Aesthetic odio dolore, meggings disrupt qui readymade stumptown brunch Terry Richardson pour-over gluten-free. Banksy american apparel in selfies, biodiesel flexitarian organic meh wolf quinoa gentrify banjo kogi. Readymade tofu ex, scenester dolor umami fingerstache occaecat fashion axe Carles jean shorts minim. Keffiyeh fashion axe nisi Godard mlkshk dolore. Lomo you probably haven’t heard of them eu non, Odd Future Truffaut pug keytar meggings McSweeney’s Pinterest cred. Etsy literally aute esse, eu bicycle rights qui meggings fanny pack. Gentrify leggings pug flannel duis. Forage occaecat cardigan quiFashion axe hella gastropub lo-fi kogi 90’s aliquip +1 veniam delectus tousled. Cred sriracha locavore gastropub kale chips, iPhone mollit sartorial. Anim dolore 8-bit, pork belly dolor photo booth aute flannel small batch. Dolor disrupt ennui, tattooed whatever salvia Banksy sartorial roof party selfies raw denim sint meh pour-over. Ennui eu cardigan sint, gentrify iPhone cornhole. Whatever velit occaecat quis deserunt gastropub, leggings elit tousled roof party 3 wolf moon kogi pug blue bottle ea. Fashion axe shabby chic Austin quinoa pickled laborum bitters next level, disrupt deep v accusamus non fingerstache. Tote bag asymmetrical elit sunt. Occaecat authentic Marfa, hella McSweeney’s next level irure veniam master cleanse. Sed hoodie letterpress artisan wolf leggings, 3 wolf moon commodo ullamco. Anim occupy ea labore Terry Richardson. Tofu ex master cleanse in whatever pitchfork banh mi, occupy fugiat fanny pack Austin authentic. Magna fugiat 3 wolf moon, labore McSweeney’s sustainable vero consectetur. Gluten-free disrupt enim, aesthetic fugiat jean shorts trust fund keffiyeh magna try-hard. Hoodie DuisActually salvia consectetur, hoodie duis lomo YOLO sunt sriracha. Aute pop-up brunch farm-to-table odio, salvia irure occaecat. Sriracha small batch literally skateboard. Echo Park nihil hoodie, aliquip forage artisan laboris. Trust fund reprehenderit nulla locavore. Stumptown raw denim kitsch, keffiyeh nulla twee dreamcatcher fanny pack ullamco 90’s pop-up est culpa farm-to-table. Selfies 8-bit do pug odio. Thundercats Ho!Fingerstache thundercats Williamsburg, deep v scenester Banksy ennui vinyl selfies mollit biodiesel duis odio pop-up. Banksy 3 wolf moon try-hard, sapiente enim stumptown deep v ad letterpress. Squid beard brunch, exercitation raw denim yr sint direct trade. Raw denim narwhal id, flannel DIY McSweeney’s seitan. Letterpress artisan bespoke accusamus, meggings laboris consequat Truffaut qui in seitan. Sustainable cornhole Schlitz, twee Cosby sweater banh mi deep v forage letterpress flannel whatever keffiyeh. Sartorial cred irure, semiotics ethical sed blue bottle nihil letterpress. Occupy et selvage squid, pug brunch blog nesciunt hashtag mumblecore skateboard yr kogi. Ugh small batch swag four loko. Fap post-ironic qui tote bag farm-to-table american apparel scenester keffiyeh vero, swag non pour-over gentrify authentic pitchfork. Schlitz scenester lo-fi voluptate, tote bag irony bicycle rights pariatur vero Vice freegan wayfarers exercitation nisi shoreditch. Chambray tofu vero sed. Street art swag literally leggings, Cosby sweater mixtape PBR lomo Banksy non in pitchfork ennui McSweeney’s selfies. Odd Future Banksy non authentic. Aliquip enim artisan dolor post-ironic. Pug tote bag Marfa, deserunt pour-over Portland wolf eu odio intelligentsia american apparel ugh ea. Sunt viral et, 3 wolf moon gastropub pug id. Id fashion axe est typewriter, mlkshk Portland art party aute brunch. Sint pork belly Cosby sweater, deep v mumblecore kitsch american apparel. Try-hard direct trade tumblr sint skateboard. Adipisicing bitters excepteur biodiesel, pickled gastropub aute veniam.]]></content>
      <tags>
        <tag>sample post</tag>
        <tag>readability</tag>
        <tag>test</tag>
      </tags>
  </entry>
</search>
